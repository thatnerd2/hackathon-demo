namespace Microsoft.DynamicsOnline.Deployment.Service.DeploymentApi.Service.Controllers
{
    using System;
    using System.Collections.Concurrent;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.Diagnostics.CodeAnalysis;
    using System.Diagnostics.Contracts;
    using System.Globalization;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Security.Cryptography.X509Certificates;
    using System.ServiceModel;
    using System.Text;
    using System.Threading.Tasks;
    using System.Web;
    using System.Web.Http;
    using System.Web.Http.OData;
    using System.Web.Http.OData.Query;
    using System.Web.Script.Serialization;
    using Microsoft.Azure.Management.Authorization;
    using Microsoft.Azure.Management.Compute.Models;
    using Microsoft.Azure.Management.Dns.Models;
    using Microsoft.Azure.Management.Network.Models;
    using Microsoft.Azure.Management.RecoveryServices.Models;
    using Microsoft.Azure.Management.ResourceManager;
    using Microsoft.Azure.Management.ResourceManager.Models;
    using Microsoft.Dynamics.Cloud.Deployment.Controllers.Cloud;
    using Microsoft.Dynamics.Cloud.Infrastructure.ARM.Manager;
    using Microsoft.Dynamics.Cloud.Infrastructure.ARM.Manager.Models;
    using Microsoft.Dynamics.Cloud.Infrastructure.AzureKeyVault;
    using Microsoft.Dynamics.Cloud.Infrastructure.CDSManager;
    using Microsoft.Dynamics.Cloud.Infrastructure.CDSManager.CdsBapDataContracts;
    using Microsoft.Dynamics.Cloud.Infrastructure.CDSManager.CdsBapEnums;
    using Microsoft.Dynamics.Cloud.Infrastructure.ElasticPoolManager;
    using Microsoft.Dynamics.Cloud.Infrastructure.OData.WebRole.Filters;
    using Microsoft.Dynamics.Cloud.Infrastructure.Utilities.Types;
    using Microsoft.Dynamics.Platform.DataMovement.SharedLibrary.Enums;
    using Microsoft.DynamicsOnline.Deployment.Diagnostics;
    using Microsoft.DynamicsOnline.Deployment.ObjectModel;
    using Microsoft.DynamicsOnline.Deployment.ObjectModel.Exceptions;
    using Microsoft.DynamicsOnline.Deployment.ObjectModel.Extensions;
    using Microsoft.DynamicsOnline.Deployment.Service.AzureDAL;
    using Microsoft.DynamicsOnline.Deployment.Service.AzureModel;
    using Microsoft.DynamicsOnline.Deployment.Service.AzureModel.AzureDAL;
    using Microsoft.DynamicsOnline.Deployment.Service.AzureModel.AzureSDKExtensions;
    using Microsoft.DynamicsOnline.Deployment.Service.AzureModel.AzureServiceManagementExtensions;
    using Microsoft.DynamicsOnline.Deployment.Service.AzureModel.Extensions;
    using Microsoft.DynamicsOnline.Deployment.Service.Catalog.Managers;
    using Microsoft.DynamicsOnline.Deployment.Service.Catalog.Model;
    using Microsoft.DynamicsOnline.Deployment.Service.DeploymentApi.Model;
    using Microsoft.DynamicsOnline.Deployment.Service.Engine;
    using Microsoft.DynamicsOnline.Deployment.Service.Engine.Backup;
    using Microsoft.DynamicsOnline.Deployment.Service.Engine.Tasks;
    using Microsoft.DynamicsOnline.Deployment.Service.Engine.Tasks.Modules;
    using Microsoft.DynamicsOnline.Deployment.Service.Library;
    using Microsoft.DynamicsOnline.Deployment.Service.Library.Enums;
    using Microsoft.DynamicsOnline.Deployment.Service.Library.Model;
    using Microsoft.DynamicsOnline.Deployment.Service.OData;
    using Microsoft.DynamicsOnline.Deployment.Service.OData.Filters;
    using Microsoft.DynamicsOnline.Deployment.Storage;
    using Microsoft.DynamicsOnline.Deployment.WindowsAzure.ServiceManagement;
    using Microsoft.DynamicsOnline.Infrastructure;
    using Microsoft.DynamicsOnline.Infrastructure.Configuration;
    using Microsoft.DynamicsOnline.Infrastructure.Diagnostics;
    using Microsoft.DynamicsOnline.Infrastructure.Extensions;
    using Microsoft.DynamicsOnline.Infrastructure.PublicTypes;
    using Microsoft.DynamicsOnline.Infrastructure.Security;
    using Microsoft.DynamicsOnline.Infrastructure.Storage;
    using Microsoft.DynamicsOnline.Infrastructure.Storage.AzureStorage;
    using Microsoft.DynamicsOnline.Security.Common;
    using Microsoft.Rest.Azure;
    using Microsoft.WindowsAzure.Storage;
    using Microsoft.WindowsAzure.Storage.Blob;
    using Microsoft.WindowsAzure.Storage.Table;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Linq;
    using ComputeUsage = Microsoft.Azure.Management.Compute.Models.Usage;
    using Credential = Microsoft.DynamicsOnline.Deployment.Service.Library.Model.Credential;
    using DeploymentConstants = Microsoft.DynamicsOnline.Deployment.Service.Library.Constants;
    using DeploymentEnvironment = Microsoft.DynamicsOnline.RainierDeployment.EntityModel.Environment;
    using NetworkModels = Microsoft.Azure.Management.Network.Models;
    using ODataConstants = Dynamics.Cloud.Infrastructure.OData.Helpers.Constants;
    using Plan = Azure.Management.ResourceManager.Models.Plan;
    using RE = System.Text.RegularExpressions;
    using RecordSet = Azure.Management.Dns.Models.RecordSet;
    using RecoveryServicesBackup = Microsoft.Azure.Management.RecoveryServices.Backup.Models;
    using ServiceManagement = Microsoft.DynamicsOnline.Deployment.WindowsAzure.ServiceManagement;
    using Sku = Azure.Management.ResourceManager.Models.Sku;
    using Storage = Microsoft.Azure.Management.Storage.Models;
    using StorageAccountType = Model.StorageAccountType;
    using Tasks = Microsoft.DynamicsOnline.Deployment.Service.Engine.Tasks;

    /// <summary>
    /// OData Controller for the TopologyInstance class.
    /// </summary>
    [DeploymentUnhandledExceptionFilter]
    public class TopologyInstancesController : DeploymentServiceController
    {
        /// <summary> Name of the topology instance parameter for actions.</summary>
        internal const string TopologyInstanceParameter = "TopologyInstance";

        /// <summary> Name of the instance name parameter for actions.</summary>
        internal const string InstanceNameParameter = "InstanceName";

        /// <summary> The user alias parameter for actions.</summary>
        internal const string UserAliasParameter = "UserAlias";

        /// <summary> The name of the deployment item parameter for actions.</summary>
        internal const string DeploymentItemNameParameter = "DeploymentItemName";

        /// <summary> The name of the certificate identifier parameter for actions.</summary>
        internal const string CertificateIdentifierParameter = "CertificateIdentifier";

        /// <summary> The name of the username parameter for actions.</summary>
        internal const string UsernameParameter = "Username";

        /// <summary> Name of the upgrade deployment topology parameter for actions.</summary>
        internal const string UpgradeTopologyParameter = "UpgradeTopology";

        /// <summary> Name of the network security group parameter for actions.</summary>
        internal const string NetworkSecurityGroupParameter = "NetworkSecurityGroup";

        /// <summary> Name of the network security group parameter from client for actions.</summary>
        internal const string NetworkSecurityGroupClientModelParameter = "NetworkSecurityGroupClientModel";

        /// <summary> Name of the parameter that indicates whether SQL rules should be included. </summary>
        internal const string IncludeSQLRulesParameter = "IncludeSQLRules";

        /// <summary> Name of the database item name (e.g. AxDB, etc). </summary>
        internal const string DbItemName = "DbItemName";

        /// <summary> Name of the dns entry parameter. </summary>
        internal const string DnsEntryParameter = "DnsEntry";

        /// <summary> Skip LookupTable check parameter. </summary>
        internal const string SkipLookupTableCheck = "SkipLookupTableCheck";

        /// <summary> Name of the activity id parameter for actions.</summary>
        internal const string LastRotationActivityId = "LastRotationActivityId";

        /// <summary> Name of the activity id parameter for actions.</summary>
        internal const string LastRestartServiceActivityId = "LastRestartServiceActivityId";

        /// <summary> The maximum length allowed for service account user name.</summary>
        internal const int UserNameLength = 20;

        /// <summary> The maximum length allowed for virtual network name.</summary>
        internal const int VirtualNetworkNameMaxLength = 64;

        /// <summary> The name of the core usage property in Azure.</summary>
        internal const string CoreUsageName = "cores";

        /// <summary> The name of the Virtual Network property in Azure.</summary>
        internal const string VNETUsageName = "VirtualNetworks";

        /// <summary> The name of the Application Gateway property in Azure.</summary>
        internal const string AppGateUsageName = "ApplicationGateways";

        /// <summary> The name of the Network Interfaces property in Azure.</summary>
        internal const string NICUsageName = "NetworkInterfaces";

        /// <summary> The name of the Network Security Group property in Azure.</summary>
        internal const string NSGUsageName = "NetworkSecurityGroups";

        /// <summary> The name of the Dynamic Public IP Address usage property in Azure.</summary>
        internal const string DynamicPublicIPUsageName = "PublicIPAddresses";

        /// <summary> The name of the Static Public IP Address usage property in Azure.</summary>
        internal const string StaticPublicIPUsageName = "StaticPublicIPAddresses";

        /// <summary> The name of the Load Balancer usage property in Azure.</summary>
        internal const string LBUsageName = "LoadBalancers";

        /// <summary> The IP Range Regular Expression to validate the IP Range.</summary>
        internal const string IPRangeRegEx = "([0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3})/([0-9]{1,2})";

        /// <summary>The topology name regular expression to validate the topology name.</summary>
        internal const string TopologyNameRegEx = "^[A-Za-z][A-Za-z0-9-]{1,61}[A-Za-z0-9]$";

        /// <summary>The name of the flag used to refresh network security group.</summary>
        internal const string ForceCopy = "ForceCopy";

        /// <summary>The name of the flag used to forcefully start the backup job right away.</summary>
        internal const string ForceStartBackup = "ForceStartBackup";

        /// <summary>The account name regular expression.</summary>
        /// <remarks>See https://msdn.microsoft.com/en-us/library/bb726984.aspx .</remarks>
        internal const string AccountNameRegEx = @"^[^""/\\\[\]:;\|=,\+\*\?<>%@]{1,20}$";

        /// <summary>The invalid user name characters.</summary>
        private static readonly List<char> invalidUserNameCharacters = new List<char>() { '*', '(', ')', '[', ']', ':', ';', '<', '>', '?', '/', '\\', '@' };

        /// <summary>The invalid VM name characters.</summary>
        private static readonly List<char> invalidVmCharacters = new List<char>() { '`', '~', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '=', '+', '_', '[', ']', '{', '}', '\\', '|', ';', ':', '.', '\'', '"', ',', '<', '>', '/', '?', ' ' };

        /// <summary>The invalid https port numbers.</summary>\
        /// <remarks>Based on this information https://technet.microsoft.com/en-us/library/Cc959828.aspx.</remarks>
        private static readonly List<int> invalidHttpsPortNumbers = new List<int>() { 445, 464 };

        /// <summary>
        /// List of resource providers for Migration RDFE to ARM.
        /// </summary>
        private static readonly string[] MigrationResourceProviders = new string[] { "Microsoft.ClassicInfrastructureMigrate" };

        /// <summary>
        /// Set of known SSL Certificates.
        /// </summary>
        private static readonly IEnumerable<string> knownSslCertificateNames = new string[] { Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.AxAosServiceSslCertificate };

        /// <summary>
        /// List to hold the offhour info like region name, start and end time.
        /// </summary>
        private static Lazy<List<RegionOffHoursInfo>> regionOffHours = new Lazy<List<RegionOffHoursInfo>>(() => PopulateRegionOffHours());

        #region CRUD

        /// <summary>
        /// Gets a list of topology instance entities from Azure Storage.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the azure subscription in where the topology is (to be) deployed.</param>
        /// <param name="options">Query options: includes Environment group for the topology instances we query.</param>
        /// <returns>A list of TopologyInstance objects.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.RetailApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        public HttpResponseMessage Get(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            ODataQueryOptions<TopologyInstance> options)
        {
            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Fetching all topology instances table items for tenant [{0}] in azure subscription [{1}]", tenantId, azureSubscriptionId);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupFilter(options);
                IEnumerable<TopologyInstanceTableItem> tableRows = TopologyInstanceDAC.GetTableItemsForTenant(tenantId, azureSubscriptionId, environmentGroup, filterOutDeleted: true);

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Fetched all topology instances table items for tenant [{0}] in azure subscription [{1}]", tenantId, azureSubscriptionId);

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Fetching all topology instances blobs for tenant [{0}] in azure subscription [{1}]", tenantId, azureSubscriptionId);

                var retVal = new ConcurrentBag<TopologyInstance>();
                Parallel.ForEach(
                    tableRows,
                    tableRow =>
                    {
                        if (!string.IsNullOrWhiteSpace(tableRow.TopologyInstance))
                        {
                            string serializedData = BlobHelper.ReadBlob(new Uri(tableRow.TopologyInstance), WellKnownStorageAccounts.DeploymentServiceStorage);

                            if (!string.IsNullOrWhiteSpace(serializedData))
                            {
                                TopologyInstance topologyInstance = Serialization.DeserializeFromString<TopologyInstance>(serializedData);
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Processing table row [{0}]", tableRow.ToString());

                                topologyInstance.DecryptData();
                                topologyInstance.ResolveProperties(tenantRegistration);
                                topologyInstance.ResolveResources();
                                retVal.Add(topologyInstance);
                            }
                        }
                    });

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Fetched all topology instances blobs for tenant [{0}] in azure subscription [{1}]", tenantId, azureSubscriptionId);

                return Request.CreateResponse(HttpStatusCode.OK, retVal.ToList());
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to get topologies in Azure Subscription '{0}' of tenant '{1}'. ErrorCode='{2}'",
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to get topologies in Azure Subscription '{0}' of tenant '{1}'.",
                    azureSubscriptionId,
                    tenantId);
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Gets a topology instance entity from Azure Storage.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the azure subscription in where the topology is (to be) deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology to get.</param>
        /// <param name="options">Query options: includes Environment group for the topology instances we query.</param>
        /// <returns>A TopologyInstance object.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.RetailApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ElasticPoolMigrationService |
            DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.HealthServiceUnitService | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.SSRSConfigService | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ERPMicroservicesApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage Get(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataQueryOptions<TopologyInstance> options)
        {
            try
            {
                TopologyInstance entity;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupFilter(options);
                string accountName = this.Request.Headers.Contains(ODataConstants.HttpHeaders.AccountName)
                    ? this.Request.Headers.GetValues(ODataConstants.HttpHeaders.AccountName).FirstOrDefault()
                    : null;

                string topologyInstanceETag;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out entity, out error, out topologyInstanceRow, out topologyInstanceETag))
                {
                    return error;
                }
                else
                {
                    entity.ResolveProperties(tenantRegistration);
                    entity.ResolveResources();

                    OperationsInstance operationsInstance;
                    if (!this.CreateOrGetOperationsInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out operationsInstance, out error))
                    {
                        return error;
                    }
                    else
                    {
                        if (!string.IsNullOrWhiteSpace(accountName))
                        {
                            this.ResolveJITCredential(entity, accountName, operationsInstance);
                        }

                        entity.OperationStatus = operationsInstance.OperationStatus;
                        entity.OperationState = operationsInstance.OperationState;
                    }

                    HttpResponseMessage response = Request.CreateResponse(HttpStatusCode.OK, entity);

                    // Set blob ETag if returned on retrieval of a single topology instance.
                    if (!string.IsNullOrEmpty(topologyInstanceETag))
                    {
                        response.Headers.ETag = new EntityTagHeaderValue(topologyInstanceETag);
                    }

                    return response;
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to get topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to get topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Creates/updates a topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology will be deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="entity">Topology Instance object to be updated.</param>
        /// <returns>The updated object.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ElasticPoolMigrationService,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        public HttpResponseMessage Put(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            TopologyInstance entity)
        {
            Contract.Requires(entity != null);
            Contract.Requires(entity.InstanceId == topologyInstanceId);

            try
            {
                AzureTable<TopologyInstanceTableItem> table = TopologyInstanceDAC.GetTopologyInstanceTable();
                TopologyInstanceTableItem tableRow = this.GetTopologyTableItem(table, tenantId, azureSubscriptionId, topologyInstanceId, entity.EnvironmentGroup);

                // if it doesn't, create it
                if (tableRow == null)
                {
                    TopologyInstanceTableItem item;
                    this.CreateTopologyInstanceTableItem(tenantId, azureSubscriptionId, entity, DeploymentRequest.DeploymentAction.Undefined, out item);
                    table.Upsert(item);

                    return Request.CreateResponse(HttpStatusCode.Created, entity);
                }

                if (string.IsNullOrWhiteSpace(tableRow.TopologyInstance))
                {
                    return this.CreateErrorResponse(HttpStatusCode.InternalServerError, "Table row exists, but blob Uri is empty!?");
                }

                // Otherwise, just update the blob
                this.UploadTopologyBlob(tenantId, azureSubscriptionId, entity);

                // Mark the record as deleted
                if (entity.DeploymentState == DeploymentState.Deleted)
                {
                    tableRow.LastDeploymentState = entity.DeploymentState.ToString();
                    tableRow.LastDeploymentStatus = entity.DeploymentStatus.ToString();
                    tableRow.DeleteDatetime = DateTime.UtcNow;
                    tableRow.CurrentActivityId = Tracer.GetCorrelationActivityId();
                    table.Upsert(tableRow);

                    this.DeletePackageDeploymentTableItems(tableRow.TenantId, tableRow.AzureSubscriptionId, tableRow.TopologyInstanceId, entity.EnvironmentGroup);
                }

                return Request.CreateResponse(HttpStatusCode.OK, entity);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to put topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to put topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Deletes a topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology will be deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="options">Query options: includes Environment group for the topology instances we delete.</param>
        /// <returns>
        /// An empty response.
        /// </returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        public HttpResponseMessage Delete(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataQueryOptions<TopologyInstance> options)
        {
            try
            {
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupFilter(options);

                TopologyInstance topologyInstance;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to delete topology instance '{0}' because it was not found.", topologyInstanceId);
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to delete '{0}' because deployment instance '{1}' was not found.", topologyInstanceId, deploymentInstance.DeploymentId);
                    return errorMessage;
                }

                // Remove shared resources if 'MigratedToSf'
                topologyInstance = this.RemoveSharedResourcesFromMigratedTopology(topologyInstance);

                // If the environment is a primary, check if we have an active staging.
                // Staging environment should be deleted first, before the primary is attempting the delete
                if (topologyInstance.EnvironmentGroup == EnvironmentGroup.Primary)
                {
                    TopologyInstance stagingTopologyInstance;
                    TopologyInstanceTableItem stagingTopologyInstanceRow;
                    if (this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Staging, out stagingTopologyInstance, out errorMessage, out stagingTopologyInstanceRow))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Found an active staging environment for topology instance '{0}' during delete of the primary environment.", topologyInstanceId);
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_DeleteStagingBeforePrimary, topologyInstanceId);
                    }

                    errorMessage = null;
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Falling back to legacy delete method.");
                return this.LegacyDelete(tenantId, azureSubscriptionId, topologyInstance, topologyInstanceRow, deploymentInstance, deploymentInstanceBlobUri);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to delete topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to delete topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Deletes a topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology will be deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="deleteAzureArtifacts">If set to <c>true</c> the Azure artifacts created during deployment will be cleaned up.</param>
        /// <param name="options">Query options: includes Environment group for the topology instances we delete.</param>
        /// <returns>
        /// An empty response.
        /// </returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        public HttpResponseMessage Delete(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            [FromODataUri] bool deleteAzureArtifacts,
            ODataQueryOptions<TopologyInstance> options)
        {
            try
            {
                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.Delete;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;
                TopologyInstance topologyInstance;

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupFilter(options);

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to delete topology instance '{0}' because it was not found.", topologyInstanceId);
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to delete '{0}' because deployment instance '{1}' was not found.", topologyInstanceId, deploymentInstance.DeploymentId);
                    return errorMessage;
                }

                // Remove shared resources if 'MigratedToSf'
                topologyInstance = this.RemoveSharedResourcesFromMigratedTopology(topologyInstance);

                // If the environment is a primary, check if we have an active staging.
                // Staging environment should be deleted first, before the primary is attempting the delete
                if (topologyInstance.EnvironmentGroup == EnvironmentGroup.Primary)
                {
                    TopologyInstance stagingTopologyInstance;
                    TopologyInstanceTableItem stagingTopologyInstanceRow;
                    if (this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Staging, out stagingTopologyInstance, out errorMessage, out stagingTopologyInstanceRow))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Found an active staging environment for topology instance '{0}' during delete of the primary environment.", topologyInstanceId);
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_DeleteStagingBeforePrimary, topologyInstanceId);
                    }

                    errorMessage = null;
                }

                if (topologyInstance.HasCustomizationValue(CommonCustomizationNames.IsSwapped, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment is currently Swapped. Rollback or Commit is expected.", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNotSwapped, action);
                }
                else if (topologyInstance.HasCustomizationValue(CommonCustomizationNames.RollbackInProgress, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment did not complete Rollback. Rollback or Commit is expected.", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNotRollback, action);
                }

                if (!deleteAzureArtifacts)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Falling back to legacy delete method because the state of topology instance '{0}' is not set to Deallocated.", topologyInstanceId);
                    return this.LegacyDelete(tenantId, azureSubscriptionId, topologyInstance, topologyInstanceRow, deploymentInstance, deploymentInstanceBlobUri);
                }

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (deploymentInstance.DeploymentState != DeploymentState.Deallocated && deploymentInstance.DeploymentState != DeploymentState.MigratedToSF)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresDeallocatedState, action);
                }

                string taskDefinitionName;
                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                    taskDefinitionName = DeploymentManagementPipedMasterWorkflow.TaskNameConstant;
                }
                else
                {
                    taskDefinitionName = DeploymentManagementMasterWorkflow.TaskNameConstant;
                }

                // Validate that the environment can be deleted
                if (!this.ValidateTopologyForDelete(topologyInstance, tenantRegistration, out errorMessage))
                {
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstance.InstanceId, action, errorMessage);
                    return errorMessage;
                }

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, taskDefinitionName, out errorMessage, DeploymentState.Deleting))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to delete topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to delete topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        #endregion CRUD

        #region Actions

        /// <summary>
        /// Gets a list of the topologies the customer has deployed. Method returns TopologyInstanceClient form, summary of TopologyInstance and associated DeploymentInstance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to. This can be Guid.Empty,it will return al topologies for this tenant.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>List of topologies (client) that have been deployed by the customer.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        public HttpResponseMessage GetTopologyInstancesClient(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Fetching all topology instances (Client) for tenant [{0}] in azure subscription [{1}]", tenantId, azureSubscriptionId);

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                AzureTable<TopologyInstanceTableItem> table = TopologyInstanceDAC.GetTopologyInstanceTable();
                List<TopologyInstanceTableItem> tableRows = TopologyInstanceDAC.GetTableItemsForTenant(tenantId, azureSubscriptionId, environmentGroup, filterOutDeleted: true).ToList();

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Retrieving topology instances, deployment instances blobs for tenant [{0}] in azure subscription [{1}]", tenantId, azureSubscriptionId);

                ConcurrentBag<TopologyInstanceClient> topologiesBag = new ConcurrentBag<TopologyInstanceClient>();

                // Two cases here to tackle:
                // 1. TIClientOverflow is already set/migrated - use the table row to create the TopologyInstanceClient.
                // 2. TIClientOverflow is empty - new to migrate it on the fly.
                List<TopologyInstanceTableItem> tableRowsMigrated = tableRows.Where(tr => !string.IsNullOrEmpty(tr.TIClientOverflow)).ToList();
                List<TopologyInstanceTableItem> tableRowsToMigrate = tableRows.Where(tr => string.IsNullOrEmpty(tr.TIClientOverflow)).ToList();

                // TIClientOverflow is already set/migrated
                foreach (TopologyInstanceTableItem tableRow in tableRowsMigrated)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Processing migrated topology table row [{0}]", tableRow.ToString());

                    topologiesBag.Add(TopologyInstanceClientExtensions.CreateFromTopologyInstanceRow(tableRow));
                }

                // TIClientOverflow is empty / not migrated - create directly form blobs, set the client overflow.
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Found [{0}] topologies without TIClientOverflow set/migrated, processing them in parallel.", tableRowsToMigrate.Count);

                // list of
                ConcurrentBag<Tuple<TopologyInstanceTableItem, string>> processedRowResults = new ConcurrentBag<Tuple<TopologyInstanceTableItem, string>>();

                Parallel.ForEach(
                    tableRowsToMigrate,
                    tableRow =>
                    {
                        TopologyInstance topologyInstance = null;
                        HttpResponseMessage error;

                        // usually we decrypt the data and resolve calculated properties.
                        // no need (yet) to topologyInstance.DecryptData(); topologyInstance.ResolveProperties(); topologyInstance.ResolveResources().
                        if (!this.GetTopologyInstance(tableRow, out topologyInstance, out error, decryptData: false))
                        {
                            // add to results, traces will be done later.
                            processedRowResults.Add(Tuple.Create(tableRow, this.GetMessageError(error)));
                        }
                        else
                        {
                            // Calculate the TICLientOverflow and add new instance client to the bag.
                            tableRow.TIClientOverflow = topologyInstance.TIClientOverflowToString();
                            topologiesBag.Add(TopologyInstanceClientExtensions.CreateFromTopologyInstanceRow(tableRow));

                            // try saving the row, with version check.
                            // If not successful, trace only, still return the instanceClient object, it iwill be migrated at a later time.
                            TableResult upsertResult = table.UpdateWithVersionCheck(tableRow);
                            if (!HttpUtilities.IsSuccessStatusCode((HttpStatusCode)upsertResult.HttpStatusCode))
                            {
                                processedRowResults.Add(Tuple.Create(tableRow, string.Format(CultureInfo.InvariantCulture, "Table row could not be updated because of status code [{0}]", upsertResult.HttpStatusCode)));
                            }
                            else
                            {
                                processedRowResults.Add(Tuple.Create(tableRow, HttpStatusCode.OK.ToString()));
                            }
                        }
                    });

                // trace the results of the parallel processing
                foreach (Tuple<TopologyInstanceTableItem, string> result in processedRowResults)
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Processes in parallel topology table row [{0}: result [{1}].",
                        result.Item1.ToString(),
                        result.Item2);
                }

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Fetched all topology instances clients for tenant [{0}] in azure subscription [{1}], count rows processed [{2}], count of client objects [{3}].",
                    tenantId,
                    azureSubscriptionId,
                    tableRows.Count,
                    topologiesBag.Count);

                List<TopologyInstanceClient> listInstances = topologiesBag.OrderByDescending(t => (t.EndTime != null) ? t.EndTime.Value : (t.StartTime != null ? t.StartTime.Value : DateTime.UtcNow)).ToList();
                return Request.CreateResponse(HttpStatusCode.OK, listInstances);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to get topologies (Client) in Azure Subscription '{0}' of tenant '{1}'. ErrorCode='{2}'",
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to get topologies (Client) in Azure Subscription '{0}' of tenant '{1}'.",
                    azureSubscriptionId,
                    tenantId);
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Gets a topology the customer has deployed. Method returns TopologyInstanceClient form, summary of TopologyInstance and associated DeploymentInstance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to. This can be Guid.Empty,it will return al topologies for this tenant.</param>
        /// <param name="topologyInstanceId">Topology Instance Id.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>List of topologies (client) that have been deployed by the customer.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ERPMicroservicesApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.CSPReleaseValidation,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        public HttpResponseMessage GetTopologyInstanceClient(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Fetching topology instance (Client) for Id [{0}], tenant [{1}] in azure subscription [{2}]", topologyInstanceId, tenantId, azureSubscriptionId);

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                AzureTable<TopologyInstanceTableItem> table = TopologyInstanceDAC.GetTopologyInstanceTable();
                TopologyInstanceTableItem existingInstance = this.GetTopologyInstanceTableItem(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup);

                if (existingInstance == null)
                {
                    return this.CreateErrorResponse(HttpStatusCode.NotFound, "Unable to fetch topology instance from table for supplied parameters.");
                }

                if (string.IsNullOrEmpty(existingInstance.TIClientOverflow))
                {
                    TopologyInstance topologyInstance = null;
                    HttpResponseMessage error;
                    if (!this.GetTopologyInstance(existingInstance, out topologyInstance, out error, decryptData: false))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, this.GetMessageError(error));
                    }
                    else
                    {
                        existingInstance.TIClientOverflow = topologyInstance.TIClientOverflowToString();
                        TableResult upsertResult = table.UpdateWithVersionCheck(existingInstance);
                        if (!HttpUtilities.IsSuccessStatusCode((HttpStatusCode)upsertResult.HttpStatusCode))
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Table row could not be updated because of status code [{0}]", upsertResult.HttpStatusCode);
                        }
                        else
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Table row successfully updated. Status code [{0}]", upsertResult.HttpStatusCode);
                        }
                    }
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Fetched topology instance (Client) for Id [{0}], tenant [{1}] in azure subscription [{2}]", topologyInstanceId, tenantId, azureSubscriptionId);
                TopologyInstanceClient tiClient = TopologyInstanceClientExtensions.CreateFromTopologyInstanceRow(existingInstance);
                return Request.CreateResponse(HttpStatusCode.OK, tiClient);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to get topology (Client) for Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to get topology (Client) for Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Gets a topology the customer has deployed. This is another version GetTopologyInstanceClient method which also works for deleted environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to. This can be Guid.Empty,it will return al topologies for this tenant.</param>
        /// <param name="topologyInstanceId">Topology Instance Id.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>List of topologies (client) that have been deployed by the customer.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ERPMicroservicesApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        public HttpResponseMessage GetTopologyInstanceStatus(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Fetching topology instance (Client) inclduing deleted environment for Id [{0}], tenant [{1}] in azure subscription [{2}]", topologyInstanceId, tenantId, azureSubscriptionId);

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                AzureTable<TopologyInstanceTableItem> table = TopologyInstanceDAC.GetTopologyInstanceTable();
                TopologyInstanceTableItem existingInstance = this.GetTopologyInstanceTableItem(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, false);

                if (existingInstance == null)
                {
                    return this.CreateErrorResponse(HttpStatusCode.NotFound, "Unable to fetch topology instance from table for supplied parameters.");
                }

                if (string.IsNullOrEmpty(existingInstance.TIClientOverflow))
                {
                    TopologyInstance topologyInstance = null;
                    HttpResponseMessage error;
                    if (!this.GetTopologyInstance(existingInstance, out topologyInstance, out error, decryptData: false))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, this.GetMessageError(error));
                    }
                    else
                    {
                        existingInstance.TIClientOverflow = topologyInstance.TIClientOverflowToString();
                        TableResult upsertResult = table.UpdateWithVersionCheck(existingInstance);
                        if (!HttpUtilities.IsSuccessStatusCode((HttpStatusCode)upsertResult.HttpStatusCode))
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Table row could not be updated because of status code [{0}]", upsertResult.HttpStatusCode);
                        }
                        else
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Table row successfully updated. Status code [{0}]", upsertResult.HttpStatusCode);
                        }
                    }
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Fetched topology instance (Client) for Id [{0}], tenant [{1}] in azure subscription [{2}]", topologyInstanceId, tenantId, azureSubscriptionId);
                TopologyInstanceClient tiClient = TopologyInstanceClientExtensions.CreateFromTopologyInstanceRow(existingInstance);
                return Request.CreateResponse(HttpStatusCode.OK, tiClient);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to get topology (Client) for Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to get topology (Client) for Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action for database restore from Source e.g. Prod to target e.g. Sandbox environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the target tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the target azure subscription in where the database is (to be) restored to.</param>
        /// <param name="topologyInstanceId">Identifier of the target topology instance.</param>
        /// <param name="parameters">The additional parameters for the request.</param>
        /// <returns> A HttpResponse based on the action carried out.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage RestoreDatabaseFromSourceToTarget(
        [FromODataUri] Guid tenantId,
        [FromODataUri] Guid azureSubscriptionId,
        [FromODataUri] string topologyInstanceId,
        ODataActionParameters parameters)
        {
            try
            {
                Guid sourceTenantId = parameters.ContainsKey(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.SourceTenantIdParameterName) ? (Guid)parameters[Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.SourceTenantIdParameterName] : Guid.Empty;
                Guid sourceAzureSubscriptionId = parameters.ContainsKey(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.SourceAzureSubscriptionIdParameterName) ? (Guid)parameters[Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.SourceAzureSubscriptionIdParameterName] : Guid.Empty;
                string sourceTopologyInstanceId = parameters.ContainsKey(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.SourceTopologyInstanceIdParameterName) ? (string)parameters[Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.SourceTopologyInstanceIdParameterName] : null;
                bool? copyMRDatabase = parameters.ContainsKey(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.CopyMRDatabase) ? (bool?)parameters[Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.CopyMRDatabase] : null;

                if (sourceTenantId.Equals(Guid.Empty) || sourceAzureSubscriptionId.Equals(Guid.Empty) || String.IsNullOrWhiteSpace(sourceTopologyInstanceId) ||
                    tenantId.Equals(Guid.Empty) || azureSubscriptionId.Equals(Guid.Empty) || String.IsNullOrWhiteSpace(topologyInstanceId))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Restore database call is missing input parameter");
                    return this.CreateErrorResponse(ServiceErrorCode.DataManagement_RestoreDatabase_MissingInputParameter);
                }

                HttpResponseMessage errorMessage;
                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.RestoreDatabaseFromSourceToTargetServer;

                // Fetch and validate source environment information.
                TenantRegistration sourceTenantRegistration = this.FetchTenantRegistrationFromCache(sourceTenantId, sourceAzureSubscriptionId);
                TopologyInstance sourceTopologyInstance;
                DeploymentInstance sourceDeploymentInstance;
                Uri sourceDeploymentInstanceBlobUri;
                TopologyInstanceTableItem sourceTopologyInstanceRow;

                // RestoreDatabaseFromSourceToTarget not supported for staging
                if (!this.ValidateAndFetchDeploymentDetails(sourceTenantId, sourceAzureSubscriptionId, sourceTopologyInstanceId, EnvironmentGroup.Primary, out sourceTopologyInstance, out errorMessage, out sourceTopologyInstanceRow, out sourceDeploymentInstance, out sourceDeploymentInstanceBlobUri, action))
                {
                    return errorMessage;
                }

                // Fetch and validate target environment information.
                TenantRegistration targetTenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

                TopologyInstance targetTopologyInstance;
                DeploymentInstance targetDeploymentInstance;
                Uri targetDeploymentInstanceBlobUri;
                TopologyInstanceTableItem targetTopologyInstanceRow;

                if (!this.ValidateAndFetchDeploymentDetails(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out targetTopologyInstance, out errorMessage, out targetTopologyInstanceRow, out targetDeploymentInstance, out targetDeploymentInstanceBlobUri, action))
                {
                    return errorMessage;
                }

                // Now that source and target environment information is fetched and validated schedule data management task.
                DeploymentInstance requestDeploymentInstance = new DeploymentInstance(targetTopologyInstance.InstanceId);
                requestDeploymentInstance.Initialize(targetTopologyInstance);
                requestDeploymentInstance.DeploymentAction = DeploymentRequest.DeploymentAction.RestoreDatabaseFromSourceToTargetServer.ToString();
                DeploymentRequest request = new DeploymentRequest(targetTenantRegistration, targetTopologyInstance, requestDeploymentInstance, action);
                request.Deployment.DeploymentActionParameters.Add(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.SourceAxDbTopologyInstanceParameter, CommonUtilities.SerializeObject(sourceTopologyInstance));
                request.Deployment.DeploymentActionParameters.Add(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.SourceTenantRegistrationParameter, CommonUtilities.SerializeObject(sourceTenantRegistration));
                if (copyMRDatabase != null)
                {
                    request.Deployment.DeploymentActionParameters.Add(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.CopyMRDatabase, CommonUtilities.SerializeObject(copyMRDatabase));
                }

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                if (!this.TryUploadBlobAndScheduleTask(request, targetTopologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out errorMessage, DeploymentState.Servicing))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed restore database from Source to target environment. Paremeters:'{0}'. ErrorCode='{1}'",
                    parameters.ToString(),
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to deploy the topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology will be deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "Using lowercase to normalize Azure case-sensitivity, not globalization purposes.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage Deploy(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            TopologyInstance topologyInstance = null;
            TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.Deploy;

            try
            {
                HttpResponseMessage errorResponseMessage;
                topologyInstance = Serialization.DeserializeFromString<TopologyInstance>((string)parameters[TopologyInstanceParameter]);

                if (topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.OrganizationId, out string msodsTenantIdString) &&
                    Guid.TryParse(msodsTenantIdString, out Guid msodsTenantId) &&
                    ConfigurationTableItemHelper.IsDeploymentRestricted(msodsTenantId, tenantId))
                {
                    return this.CreateErrorResponse(ServiceErrorCode.TenantDisabledForDeployment);
                }

                // Staging Deployments: update ResourceGroupName, PopulateUpgradeTopology
                if (topologyInstance != null && topologyInstance.EnvironmentGroup == EnvironmentGroup.Staging &&
                    !this.ProcessStagingDeployment(tenantId, azureSubscriptionId, topologyInstance, tenantRegistration, out errorResponseMessage))
                {
                    return errorResponseMessage;
                }

                // Elastic Pool Deployments use the customization to define the Resource Group.
                string resourceGroupName;
                if (topologyInstance.ARM != null)
                {
                    if (topologyInstance.ShouldCreateElasticPools() && topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.ElasticSQLServerResourceGroup, out resourceGroupName) && !string.IsNullOrWhiteSpace(resourceGroupName))
                    {
                        topologyInstance.ARM.ResourceGroupName = resourceGroupName;
                        string azureSQLServerLocation = topologyInstance.GetARMLocation(isDisasterRecovery: false);

                        topologyInstance.SetCustomizationValue(CommonCustomizationNames.AzureSQLServerLocation, azureSQLServerLocation);
                    }
                    else if (string.IsNullOrEmpty(topologyInstance.ARM.ResourceGroupName))
                    {
                        topologyInstance.ARM.ResourceGroupName = topologyInstance.InstanceId;
                    }
                }

                if (!this.TryProcessCloudServiceLocation(topologyInstance, tenantRegistration, out errorResponseMessage))
                {
                    return errorResponseMessage;
                }

                // Stamp topology with the DR Recovery region.
                topologyInstance.UpdateTopologyWithDisasterRecoveryMetadata();

                this.OnDeploymentScheduling(topologyInstance, tenantRegistration);

                this.PopulateCloudServiceInstances(topologyInstance, tenantRegistration);

                DeploymentInstance deploymentInstance = new DeploymentInstance(topologyInstance);
                deploymentInstance.RestartAction = action.ToString();

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                TopologyInstanceTableItem topologyInstanceRow;
                if (!this.TryProcessCustomizations(topologyInstance, DeploymentRequest.DeploymentAction.Deploy, out errorResponseMessage) ||
                    !this.TryProcessImageGalleryCustomization(tenantRegistration, topologyInstance, out errorResponseMessage) ||
                    !this.TryProcessDynamicBuildTopology(topologyInstance, out errorResponseMessage) ||
                    !this.TryProcessCredentials(topologyInstance, out errorResponseMessage) ||
                    (!topologyInstance.IsStaging() && !this.TryProcessElasticPoolSettings(topologyInstance, out errorResponseMessage)) ||
                    !this.AllocateCloudServiceNames(request, out errorResponseMessage) ||
                    !this.TryProcessDeploymentFeature(request, action, out errorResponseMessage) ||
                    !this.ValidateTopologyForDeploy(tenantId, azureSubscriptionId, topologyInstance, tenantRegistration, action, out errorResponseMessage) ||
                    !this.CreateTopologyInstanceTableItem(tenantRegistration.TenantId, tenantRegistration.AzureSubscriptionId, topologyInstance, action, out topologyInstanceRow) ||
                    !this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentServiceMasterWorkflow.TaskNameConstant, out errorResponseMessage))
                {
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstance.InstanceId, action, errorResponseMessage);

                    // We are calling OnValidationFailed here because all of the methods above benefit from the OnValidationFailed implementation that
                    // rolls back the resources allocated in external services. Since we need to rollback on failures besides validation, ideally we would instead
                    // have an event called OnActionCommitFailure that we would call whenever a deployment actions fails to commit.
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, null);

                    return errorResponseMessage;
                }

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to deploy topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorResponseMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorResponseMessage);

                if (topologyInstance != null && tenantRegistration != null)
                {
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, null);
                }

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorResponseMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to deploy topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                if (topologyInstance != null && tenantRegistration != null)
                {
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, null);
                }

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to redeploy the topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology will be deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "Using lowercase to normalize Azure case-sensitivity, not globalization purposes.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage Redeploy(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Action used to deploy the topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology will be deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage DeployDisasterRecovery(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            TopologyInstance topologyInstance = null;
            TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.DeployDisasterRecovery;

            try
            {
                TopologyInstanceTableItem topologyInstanceRow;
                HttpResponseMessage errorResponseMessage;

                // Deploy DR not supported for staging
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorResponseMessage, out topologyInstanceRow))
                {
                    return errorResponseMessage;
                }

                if (!topologyInstance.IsDisasterRecoveryEnabled())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Topology [{0}] is not enabled for disaster recovery.", topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresDisasterRecoveryEnabled);
                }

                // Set Disaster Recovery location
                if (string.IsNullOrWhiteSpace(topologyInstance.DisasterRecoveryLocation))
                {
                    topologyInstance.DisasterRecoveryLocation = AzureSQLLocations.GetGeoReplicationLocation(topologyInstance.CloudStorageLocation);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Set disaster recovery location to [{0}].", topologyInstance.DisasterRecoveryLocation);
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                DeploymentInstance deploymentInstance = new DeploymentInstance(topologyInstance);
                deploymentInstance.RestartAction = action.ToString();

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (!this.TryProcessCustomizations(topologyInstance, action, out errorResponseMessage) ||
                    !this.ValidateTopologyForDeployDR(topologyInstance, tenantRegistration, out errorResponseMessage) ||
                    !this.TryProcessDeploymentFeature(request, action, out errorResponseMessage) ||
                    !this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentServiceMasterWorkflow.TaskNameConstant, out errorResponseMessage))
                {
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorResponseMessage);

                    // We are calling OnValidationFailed here because all of the methods above benefit from the OnValidationFailed implementation that
                    // rolls back the resources allocated in external services. Since we need to rollback on failures besides validation, ideally we would instead
                    // have an event called OnActionCommitFailure that we would call whenever a deployment actions fails to commit.
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, null);

                    return errorResponseMessage;
                }

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to deploy disaster recovery for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorResponseMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorResponseMessage);

                if (topologyInstance != null && tenantRegistration != null)
                {
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, null);
                }

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorResponseMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to deploy disaster recovery for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                if (topologyInstance != null && tenantRegistration != null)
                {
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, null);
                }

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action for deleting environment metadata.
        /// </summary>
        /// <param name="tenantId">Identifier of the target tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the target azure subscription in where the database is (to be) restored to.</param>
        /// <param name="topologyInstanceId">Identifier of the target topology instance.</param>
        /// <param name="parameters">The additional parameters for the request.</param>
        /// <returns> A HttpResponse based on the action carried out.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage DeleteTopologyMetadata(
        [FromODataUri] Guid tenantId,
        [FromODataUri] Guid azureSubscriptionId,
        [FromODataUri] string topologyInstanceId,
        ODataActionParameters parameters)
        {
            try
            {
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;
                TopologyInstance topologyInstance;

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                bool skipResourceGroup = this.GetParameterOrDefault(parameters, Library.Model.ServiceConstants.SkipResourceGroupParameterName, false);
                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.DeleteMetadata;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to delete topology metadata for instance '{0}' because it was not found.", topologyInstanceId);
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to delete meadata for '{0}' because deployment instance '{1}' was not found.", topologyInstanceId, deploymentInstance.DeploymentId);
                    return errorMessage;
                }

                // If the environment is a primary, check if we have an active staging.
                // Staging environment should be deleted first, before the primary is attempting the delete
                if (topologyInstance.EnvironmentGroup == EnvironmentGroup.Primary)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Verifying that we are not attempting to delete the metadata for '{0}' if an active staging exists.", topologyInstanceId);
                    TopologyInstance stagingTopologyInstance;
                    TopologyInstanceTableItem stagingTopologyInstanceRow;
                    if (this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Staging, out stagingTopologyInstance, out errorMessage, out stagingTopologyInstanceRow))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Found an active staging environment for topology instance '{0}' during delete of the primary environment's metadata.", topologyInstanceId);
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_DeleteStagingBeforePrimary, topologyInstanceId);
                    }

                    errorMessage = null;
                }

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (!skipResourceGroup)
                {
                    if (request.Topology.ShouldUseAzureResourceManager())
                    {
                        if (TryEnsureDeploymentApplicationRole(request.TenantRegistration))
                        {
                            using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager())
                            {
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Verifying that the resource group for topology instance '{0}' has been deleted.", topologyInstanceId);
                                if (manager.Resource.Value.CheckResourceGroupExistence(topologyInstance.ARM.ResourceGroupName))
                                {
                                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Found an existing resource group for topology instance '{0}' during delete of the environment's metadata.", topologyInstanceId);
                                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_DeleteResourceGroupBeforeMetadata, topologyInstanceId);
                                }
                            }
                        }
                        else
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Skipping azure subscription check as EnsureDeploymentApplicationRole check has failed for subscription '{0}'", request.TenantRegistration.AzureSubscriptionId);
                        }
                    }
                }
                else
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Skipping checking resource group existance for topology instance '{0}' .", topologyInstanceId);
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Proceeding with scheduling task for deletion of metadata for topology instance '{0}'.", topologyInstanceId);
                string taskDefinitionName = DeploymentManagementPipedMasterWorkflow.TaskNameConstant;
                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, taskDefinitionName, out errorMessage, DeploymentState.Deleting))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to delete topology metadata Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to delete topology metadata Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action for purging of the data on topology instance level.
        /// </summary>
        /// <param name="tenantId">Identifier of the target tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the target azure subscription in where the database is (to be) restored to.</param>
        /// <param name="topologyInstanceId">Identifier of the target topology instance.</param>
        /// <param name="parameters">The additional parameters for the request.</param>
        /// <returns> A HttpResponse based on the action carried out.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage PurgeTopologyInstance(
        [FromODataUri] Guid tenantId,
        [FromODataUri] Guid azureSubscriptionId,
        [FromODataUri] string topologyInstanceId,
        ODataActionParameters parameters)
        {
            try
            {
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;
                TopologyInstance topologyInstance;

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                //getting the topologyinstance.
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, filterOutDeleted: false, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to delete topology data for instance '{0}' because it was not found.", topologyInstanceId);
                    return errorMessage;
                }

                //getting the deploymentinstance.
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to delete topology data for '{0}' because deployment instance '{1}' was not found.", topologyInstanceId, deploymentInstance.DeploymentId);
                    return errorMessage;
                }

                //checking that the environment is in deleted state.we can purge only after the delete. 
                if (!(deploymentInstance.DeploymentState == DeploymentState.Deleted && deploymentInstance.DeploymentStatus == Model.DeploymentStatus.Succeeded))
                {
                    Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Skipping [PurgeTopologyInstance] with TenantId: [{0}], AzureSubscriptionId: [{1}] because the topology [{2}] is still active.", tenantId, azureSubscriptionId, topologyInstanceId);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresDeletedState, DeploymentRequest.DeploymentAction.Delete);
                }

                //Creating the request.
                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, DeploymentRequest.DeploymentAction.Delete);

                //Creating the task.
                if (!this.TryScheduleTaskWithoutRollback(request, PurgeTopologyInstanceTask.TaskNameConstant, PurgeTopologyInstanceTask.GenerateTaskName(request), out errorMessage))
                {
                    return errorMessage;
                }

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to delete topology metadata Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to delete topology metadata Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to retrieve the RDP file of an instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetRDPFile(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                string instanceName = (string)parameters[InstanceNameParameter];
                string deploymentItemName = this.GetParameterOrDefault(parameters, TopologyInstancesController.DeploymentItemNameParameter, String.Empty);
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Received RDP file request for tenant [{0}] subscription [{1}] topology instance [{2}] deployment item [{3}] instance name [{4}] EnvironmentGroup [{5}]",
                    tenantId,
                    azureSubscriptionId,
                    topologyInstanceId,
                    deploymentItemName,
                    instanceName,
                    environmentGroup);

                TopologyInstance entity;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out entity, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (entity.ShouldUseAzureResourceManager())
                {
                    Instance instance = null;
                    if (!String.IsNullOrWhiteSpace(deploymentItemName))
                    {
                        var deploymentItem = entity.DeploymentItems.GetFirst(deploymentItemName);
                        if (deploymentItem != null)
                        {
                            instance = deploymentItem.GetInstance(instanceName);
                        }
                    }
                    else
                    {
                        // Backwards compatibility. If DeploymentItem is not sent, default to the first instance with the given name.
                        instance = entity.DeploymentItems.SelectMany(di => di.Instances).FirstOrDefault(inst => String.Equals(inst.MachineName, instanceName, StringComparison.OrdinalIgnoreCase));
                    }

                    if (instance == null)
                    {
                        Tracer.WriteExecutionEvent(
                              TraceComponent.DeploymentServiceApi,
                              "Error during download RDP file for Subscription [{0}] Resource Group [{1}] Virtual Machine instance [{2}] Deployment Item name [{3}]: instance not found",
                              azureSubscriptionId.ToString(),
                              entity.ARM.ResourceGroupName,
                              instanceName,
                              deploymentItemName);

                        return this.CreateErrorResponse(ServiceErrorCode.AzureResourceNotFound);
                    }

                    string rdpFileText = this.FormARMRDPFile(instance, entity);

                    if (String.IsNullOrEmpty(rdpFileText))
                    {
                        Tracer.WriteExecutionEvent(
                          TraceComponent.DeploymentServiceApi,
                          "Error during download RDP file for Subscription [{0}] Resource Group [{1}] Virtual Machine instance [{2}]: RDP access is not configured",
                          azureSubscriptionId.ToString(),
                          entity.ARM.ResourceGroupName,
                          instanceName);

                        return this.CreateErrorResponse(ServiceErrorCode.AzureResourceNotFound);
                    }

                    var response = Request.CreateResponse(HttpStatusCode.OK, Encoding.UTF8.GetBytes(rdpFileText));
                    response.Content.Headers.ContentDisposition = new System.Net.Http.Headers.ContentDispositionHeaderValue("attachment")
                    {
                        FileName = String.Format(CultureInfo.InvariantCulture, "{0}.rdp", instance.MachineName)
                    };

                    return response;
                }
                else
                {
                    TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

                    DeploymentItem deploymentItem = null;
                    if (!string.IsNullOrWhiteSpace(deploymentItemName))
                    {
                        deploymentItem = entity.DeploymentItems.GetFirst(deploymentItemName);
                    }

                    string cloudServiceName = entity.GetCloudServiceName(deploymentItem, instanceName);

                    if (string.IsNullOrWhiteSpace(cloudServiceName))
                    {
                        return this.CreateErrorResponse(ServiceErrorCode.MissingCloudServiceName);
                    }

                    IServiceManagement azureProxy;
                    ServiceManagement.Deployment azureDeployment;
                    Func<IServiceManagement, ServiceManagement.Deployment> getDeployment = (proxy) => proxy.GetDeploymentBySlot(azureSubscriptionId.ToString(), cloudServiceName, DeploymentSlotType.Production);

                    if (!this.ValidateTenantRegistrationCertificate(tenantRegistration, out errorMessage, out azureProxy, out azureDeployment, getDeployment))
                    {
                        return errorMessage;
                    }

                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Downloading RDP file for Subscription [{0}] CloudService [{1}] Deployment [{2}] Instance [{3}]",
                        azureSubscriptionId.ToString(),
                        cloudServiceName,
                        azureDeployment.Name,
                        instanceName);

                    byte[] rdpFile;
                    System.IO.Stream rdpStream;

                    try
                    {
                        rdpStream = azureProxy.DownloadRDPFile(azureSubscriptionId.ToString(), cloudServiceName, azureDeployment.Name, instanceName);
                    }
                    catch (EndpointNotFoundException ex)
                    {
                        Tracer.WriteExecutionEvent(
                            TraceComponent.DeploymentServiceApi,
                            "Error during download RDP file for Subscription [{0}] CloudService [{1}] Deployment [{2}] Instance [{3}] Exception [{4}]",
                            azureSubscriptionId.ToString(),
                            cloudServiceName,
                            azureDeployment.Name,
                            instanceName,
                            ex);

                        return this.CreateErrorResponse(ServiceErrorCode.AzureResourceNotFound);
                    }

                    using (System.IO.MemoryStream ms = new System.IO.MemoryStream())
                    {
                        rdpStream.CopyTo(ms);
                        rdpFile = ms.ToArray();
                    }

                    return Request.CreateResponse(HttpStatusCode.OK, rdpFile);
                }
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to start a deployment instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage Start(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.Start;

            try
            {
                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                string environmentDisabled = null;
                if (!topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.IsEnvironmentDisabled, out environmentDisabled))
                {
                    environmentDisabled = null;
                }

                bool isEnvironmentDisabled;
                if (environmentDisabled != null && bool.TryParse(environmentDisabled, out isEnvironmentDisabled) && isEnvironmentDisabled)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, DeploymentState.Disabled);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_EnvironmentInDisabledState, action);
                }

                string environmentRestartDisabled = null;
                if (!topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.IsEnvironmentRestartDisabled, out environmentRestartDisabled))
                {
                    environmentRestartDisabled = null;
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "EnvironmentRestartDisabled Customization: [{0}]", environmentRestartDisabled);

                bool isEnvironmentRestartDisabled = false;
                if (environmentRestartDisabled != null && bool.TryParse(environmentRestartDisabled, out isEnvironmentRestartDisabled) && isEnvironmentRestartDisabled)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, DeploymentState.Disabled);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_EnvironmentInDisabledState, action);
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (deploymentInstance.DeploymentState != DeploymentState.Stopped &&
                    deploymentInstance.DeploymentState != DeploymentState.Deallocated &&
                    deploymentInstance.DeploymentStatus != Microsoft.DynamicsOnline.Deployment.Service.DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    if (!(deploymentInstance.DeploymentState == DeploymentState.Finished &&
                         deploymentInstance.DeploymentStatus == Microsoft.DynamicsOnline.Deployment.Service.DeploymentApi.Model.DeploymentStatus.Succeeded))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresDeallocatedState, action);
                    }
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

                List<TopologyInstance> ongoingTopologyInstances;
                this.GetDeployingTopologyInstances(tenantRegistration.TenantId, out ongoingTopologyInstances);

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                string taskDefinitionName;
                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                    taskDefinitionName = DeploymentManagementPipedMasterWorkflow.TaskNameConstant;
                }
                else
                {
                    taskDefinitionName = DeploymentManagementMasterWorkflow.TaskNameConstant;
                }

                // Only core validation is needed for RDFE Start
                if ((!topologyInstance.ShouldUseAzureResourceManager() && !this.ValidateTopologyCoresAvailability(tenantRegistration, topologyInstance, ongoingTopologyInstances, out errorMessage, topologyInstance.GetCoreCount())) ||
                    !this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, taskDefinitionName, out errorMessage, DeploymentState.Starting))
                {
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to start topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to start topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to stop a deployment instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage Stop(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            return this.StopTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, parameters, DeploymentState.Stopping);
        }

        /// <summary>
        /// Action used to deallocate a deployment instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage Deallocate(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            return this.StopTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, parameters, DeploymentState.Deallocating);
        }

        /// <summary>
        /// Action used to failover a topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage Failover(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Failing over topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.Failover;

                string failoverModeString = parameters.ContainsKey(CommonDeploymentActionParameters.FailOverMode) ? (string)parameters[CommonDeploymentActionParameters.FailOverMode] : FailoverMetadata.All.ToString();
                FailoverMetadata.Mode failOverMode;

                if (!Enum.TryParse(failoverModeString, out failOverMode))
                {
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, CommonDeploymentActionParameters.FailOverMode, failoverModeString);
                }

                string gracefulSQLFailoverstring = parameters.ContainsKey(CommonDeploymentActionParameters.GracefulSQLFailover) ? (string)parameters[CommonDeploymentActionParameters.GracefulSQLFailover] : null;

                DeploymentState deploymentState = DeploymentState.Recovering;

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;

                // Failover not supported for Staging
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                string disasterRecoveryReady;
                if (!topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.DisasterRecoveryReady, out disasterRecoveryReady) || !String.Equals(disasterRecoveryReady, true.ToString(), StringComparison.OrdinalIgnoreCase))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but it does not have customization [{2}] set to true.", action, topologyInstance, CommonCustomizationNames.DisasterRecoveryReady);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresDisasterRecoveryReady);
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (deploymentInstance.DeploymentState != DeploymentState.Stopped &&
                    deploymentInstance.DeploymentState != DeploymentState.Finished &&
                    deploymentInstance.DeploymentState != DeploymentState.SafeMode &&
                    deploymentInstance.DeploymentStatus != Microsoft.DynamicsOnline.Deployment.Service.DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete &&
                    deploymentInstance.DeploymentStatus != Microsoft.DynamicsOnline.Deployment.Service.DeploymentApi.Model.DeploymentStatus.StateTransitionIncompleteInDR)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance);
                deploymentInstance.RestartAction = action.ToString();
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.FailOverMode, failoverModeString);
                if (!string.IsNullOrWhiteSpace(gracefulSQLFailoverstring))
                {
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.GracefulSQLFailover, gracefulSQLFailoverstring);
                }

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (!this.ValidateTopologyForFailover(request, failOverMode, out errorMessage) ||
                    !this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out errorMessage, deploymentState))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to fail over topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to fail over topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to failback a topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage Failback(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Failing back topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.Failback;

                DeploymentState deploymentState = DeploymentState.Restoring;

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;

                // Failback not supported for staging
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (deploymentInstance.DeploymentState != DeploymentState.SafeMode &&
                    deploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete &&
                    deploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncompleteInDR)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresSafeModeState, deploymentState);
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance);
                deploymentInstance.RestartAction = action.ToString();

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out errorMessage, deploymentState))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to fail back topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to fail back topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to swap a topology instance staging and production slots.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage Swap(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Swapping topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.SwapStaging;
                DeploymentState deploymentState = DeploymentState.Swapping;

                HttpResponseMessage errorMessage;

                TopologyInstance primaryTopologyInstance;
                TopologyInstanceTableItem primaryTopologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out primaryTopologyInstance, out errorMessage, out primaryTopologyInstanceRow))
                {
                    return errorMessage;
                }

                DeploymentInstance primaryDeploymentInstance;
                Uri deploymentInstanceBlobUri;
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, primaryTopologyInstanceRow, EnvironmentGroup.Primary, out primaryDeploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (primaryDeploymentInstance.DeploymentState == DeploymentState.Swapped)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment is currently Swapped. Rollback of staging environment is expected.", action, primaryTopologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNotSwapped, action);
                }
                else if (primaryDeploymentInstance.DeploymentState != DeploymentState.Finished &&
                         primaryDeploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but the primary deployment is currently in state [{2}].", action, primaryTopologyInstance, primaryDeploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }

                // Bail out if we already swapped the environments
                if (primaryTopologyInstance.HasCustomizationValue(CommonCustomizationNames.IsSwapped, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment is currently Swapped. Rollback or Commit of staging environment is expected.", action, primaryTopologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNotSwapped, action);
                }
                else if (primaryTopologyInstance.HasCustomizationValue(CommonCustomizationNames.RollbackInProgress, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment did not complete Rollback. Rollback or Commit is expected.", action, primaryTopologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNotRollback, action);
                }

                TopologyInstance stagingTopologyInstance;
                TopologyInstanceTableItem stagingTopologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Staging, out stagingTopologyInstance, out errorMessage, out stagingTopologyInstanceRow))
                {
                    return errorMessage;
                }

                // staging environment should be in finished state, deployed successfully
                DeploymentInstance existingStagingDeploymentInstance;
                Uri stagingDeploymentInstanceBlobUri;
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, stagingTopologyInstanceRow, EnvironmentGroup.Staging, out existingStagingDeploymentInstance, out stagingDeploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (existingStagingDeploymentInstance.DeploymentState != DeploymentState.Finished)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but the staging deployment is currently in state [{2}].", action, stagingTopologyInstance, existingStagingDeploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }

                if (existingStagingDeploymentInstance.DeploymentStatus != Model.DeploymentStatus.Succeeded && existingStagingDeploymentInstance.DeploymentStatus != Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but the staging deployment is currently in status [{2}].", action, stagingTopologyInstance, existingStagingDeploymentInstance.DeploymentStatus);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresSucceededStatus, deploymentState);
                }

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                if (FeatureConfiguration.ServicingConfiguration.HasDatabaseUpgradeApplicationVersionCheck(tenantRegistration)
                    && this.ValidateApplicationVersionExistsForAxDatabaseUpgrade(tenantRegistration, primaryTopologyInstance) == false)
                {
                    throw new ServiceException(ServiceErrorCode.OperationNotAllowed_ApplicationVersionNotFound);
                }

                // call migration library to ensure the original topology was updated to latest object model
                MigrationLibrary.MigrateTopology(primaryTopologyInstance);

                primaryDeploymentInstance = new DeploymentInstance(primaryTopologyInstance.InstanceId);
                primaryDeploymentInstance.Initialize(primaryTopologyInstance);

                DeploymentInstance stagingDeploymentInstance = new DeploymentInstance(stagingTopologyInstance.InstanceId);
                stagingDeploymentInstance.Initialize(stagingTopologyInstance);

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, primaryTopologyInstance, primaryDeploymentInstance, action);

                // Check if Swap API is disabled
                if (this.IsAPIDisabled(request, action, out errorMessage))
                {
                    Tracer.WriteWarningEvent(TraceComponent.DeploymentServiceApi, null, "The operation {0} is currently disabled.", action);
                    return errorMessage;
                }

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                // Back the topologies, primary and staging.
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Backing up primary and staging topologies before scheduling the swap workflow.");
                DeploymentRequest stagingRequest = new DeploymentRequest(tenantRegistration, stagingTopologyInstance, stagingDeploymentInstance, action);
                CommonHelper.BackupTopologyInstanceXml(request, stagingRequest);

                UploadBlobScheduleTaskInput primaryInput = new UploadBlobScheduleTaskInput()
                {
                    TopologyInstanceRow = primaryTopologyInstanceRow,
                    TopologyInstance = primaryTopologyInstance,
                    DeploymentInstance = primaryDeploymentInstance,
                    InitialDeploymentState = deploymentState,
                };

                UploadBlobScheduleTaskInput stagingInput = new UploadBlobScheduleTaskInput()
                {
                    TopologyInstanceRow = stagingTopologyInstanceRow,
                    TopologyInstance = stagingTopologyInstance,
                    DeploymentInstance = stagingDeploymentInstance,
                    InitialDeploymentState = deploymentState,
                };

                IEnumerable<UploadBlobScheduleTaskInput> inputs = new UploadBlobScheduleTaskInput[] { primaryInput, stagingInput };

                if (!this.TryUploadBlobAndScheduleTask(request, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, inputs, out errorMessage))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to swap topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to swap topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to rollback a swapped topology instance staging and production slots.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage RollbackSwap(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Rolling back topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.SwapRollback;
                DeploymentState deploymentState = DeploymentState.SwapRollingBack;

                HttpResponseMessage errorMessage;

                TopologyInstance primaryTopologyInstance;
                TopologyInstanceTableItem primaryTopologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out primaryTopologyInstance, out errorMessage, out primaryTopologyInstanceRow))
                {
                    return errorMessage;
                }

                DeploymentInstance primaryDeploymentInstance;
                Uri deploymentInstanceBlobUri;
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, primaryTopologyInstanceRow, EnvironmentGroup.Primary, out primaryDeploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                // Allow rollback for Finished state as we may run servicing in between swap and rollback
                // only if environment is swapped
                if (primaryDeploymentInstance.DeploymentState != DeploymentState.Swapped &&
                    primaryDeploymentInstance.DeploymentState != DeploymentState.Finished &&
                    primaryDeploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but the primary deployment is currently in state [{2}].", action, primaryTopologyInstance, primaryDeploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }
                else if (primaryDeploymentInstance.DeploymentState == DeploymentState.Finished &&
                         !primaryTopologyInstance.HasCustomizationValue(CommonCustomizationNames.IsSwapped, true.ToString()) &&
                         !primaryTopologyInstance.HasCustomizationValue(CommonCustomizationNames.RollbackInProgress, true.ToString()))
                {
                    // if finished (any successfull action can take us here), allow operation only if environment was swapped.
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but the the environment was not swapped yet.", action, primaryTopologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresSwapped, deploymentState);
                }

                TopologyInstance stagingTopologyInstance;
                TopologyInstanceTableItem stagingTopologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Staging, out stagingTopologyInstance, out errorMessage, out stagingTopologyInstanceRow))
                {
                    return errorMessage;
                }

                // staging environment should be in finished state, deployed successfully
                DeploymentInstance existingStagingDeploymentInstance;
                Uri stagingDeploymentInstanceBlobUri;
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, stagingTopologyInstanceRow, EnvironmentGroup.Staging, out existingStagingDeploymentInstance, out stagingDeploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (existingStagingDeploymentInstance.DeploymentState != DeploymentState.Swapped &&
                    existingStagingDeploymentInstance.DeploymentState != DeploymentState.Finished &&
                    existingStagingDeploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but the staging deployment is currently in state [{2}].", action, stagingTopologyInstance, existingStagingDeploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }
                else if (existingStagingDeploymentInstance.DeploymentState == DeploymentState.Finished &&
                         !stagingTopologyInstance.HasCustomizationValue(CommonCustomizationNames.IsSwapped, true.ToString()) &&
                         !stagingTopologyInstance.HasCustomizationValue(CommonCustomizationNames.RollbackInProgress, true.ToString()))
                {
                    // if finished (any successfull action can take us here), allow operation only if environment was swapped.
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but the the environment was not swapped yet.", action, stagingTopologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresSwapped, deploymentState);
                }

                List<FeatureConfigurationModel> previousPrimaryFeatures = primaryDeploymentInstance.DeploymentFeaturesUsed;
                primaryDeploymentInstance = new DeploymentInstance(primaryTopologyInstance.InstanceId);
                primaryDeploymentInstance.Initialize(primaryTopologyInstance);
                primaryDeploymentInstance.DeploymentFeaturesUsed = previousPrimaryFeatures;

                // Set CorrelationActivityID early in case we need to take an XML Backup.
                primaryDeploymentInstance.CorrelationActivityId = Tracer.GetCorrelationActivityId();

                DeploymentInstance stagingDeploymentInstance = new DeploymentInstance(stagingTopologyInstance.InstanceId);
                stagingDeploymentInstance.Initialize(stagingTopologyInstance);
                stagingDeploymentInstance.DeploymentFeaturesUsed = existingStagingDeploymentInstance.DeploymentFeaturesUsed;

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, primaryTopologyInstance, primaryDeploymentInstance, action);

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                // If the staging topology has the XML Swap guard, undo the XML swapping.
                bool topologiesSwapped = false;
                if (stagingTopologyInstance.HasCustomizationValue(CommonCustomizationNames.IsSwapped, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Staging topology [{0}] has XML Swap guard. Reverting XML swap before starting tasks.", stagingTopologyInstance);
                    DeploymentRequest stagingRequest = new DeploymentRequest(tenantRegistration, stagingTopologyInstance, stagingDeploymentInstance, action);
                    CommonHelper.SwapTopologyInstanceXml(request, stagingRequest, isLastRetry: true);
                    CommonHelper.SwapVersionInfoJson(request, stagingRequest, isLastRetry: true);

                    // fix issue during swap/rollback where the topology name is not swapped properly and topology instance row has the old topology name.
                    primaryTopologyInstanceRow.TIClientOverflow = stagingTopologyInstance.TIClientOverflowToString();
                    primaryTopologyInstanceRow.TopologyName = stagingTopologyInstance.TopologyName;

                    stagingTopologyInstanceRow.TIClientOverflow = primaryTopologyInstance.TIClientOverflowToString();
                    stagingTopologyInstanceRow.TopologyName = primaryTopologyInstance.TopologyName;

                    request.Topology.TryRemoveCustomization(CommonCustomizationNames.IsSwapped);
                    stagingRequest.Topology.TryRemoveCustomization(CommonCustomizationNames.IsSwapped);

                    request = stagingRequest;

                    // flag indicating the topologies have been swapped. The primary topology/deployment instances now have environment group staging and viceversa.
                    topologiesSwapped = true;
                }
                else
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Staging topology [{0}] does not have an XML Swap guard. This is most likely a failed Swap rollback. Skipping XML Swap.", action, stagingTopologyInstance);
                }

                primaryTopologyInstance.SetCustomizationValue(CommonCustomizationNames.RollbackInProgress, true);
                stagingTopologyInstance.SetCustomizationValue(CommonCustomizationNames.RollbackInProgress, true);

                // if swapped, primaryTopologyInstance/primaryDeploymentInstance are marked for staging now, use proper row to upload the deployment instance.
                // otherwise the deployment instance for primary is uploading to staging and viceversa, causing incorrect updates during the workflow.
                UploadBlobScheduleTaskInput primaryInput = new UploadBlobScheduleTaskInput()
                {
                    TopologyInstanceRow = topologiesSwapped ? stagingTopologyInstanceRow : primaryTopologyInstanceRow,
                    TopologyInstance = primaryTopologyInstance,
                    DeploymentInstance = primaryDeploymentInstance,
                    InitialDeploymentState = deploymentState,
                };

                UploadBlobScheduleTaskInput stagingInput = new UploadBlobScheduleTaskInput()
                {
                    TopologyInstanceRow = topologiesSwapped ? primaryTopologyInstanceRow : stagingTopologyInstanceRow,
                    TopologyInstance = stagingTopologyInstance,
                    DeploymentInstance = stagingDeploymentInstance,
                    InitialDeploymentState = deploymentState,
                };

                IEnumerable<UploadBlobScheduleTaskInput> inputs = new UploadBlobScheduleTaskInput[] { primaryInput, stagingInput };

                if (!this.TryUploadBlobAndScheduleTask(request, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, inputs, out errorMessage))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to roll back topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to roll back topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to commit a swapped topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage CommitSwap(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Committing swapped topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.SwapCommit;
                DeploymentState deploymentState = DeploymentState.CommitingSwap;

                HttpResponseMessage errorMessage;

                TopologyInstance primaryTopologyInstance;
                TopologyInstanceTableItem primaryTopologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out primaryTopologyInstance, out errorMessage, out primaryTopologyInstanceRow))
                {
                    return errorMessage;
                }

                DeploymentInstance primaryDeploymentInstance;
                Uri deploymentInstanceBlobUri;
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, primaryTopologyInstanceRow, EnvironmentGroup.Primary, out primaryDeploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                // Allow finished state because we may execute servicing in between swap and commit
                if (primaryDeploymentInstance.DeploymentState != DeploymentState.Swapped &&
                    primaryDeploymentInstance.DeploymentState != DeploymentState.Finished &&
                    primaryDeploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] instance corresponding to topology [{1}] but the primary deployment is currently in state [{2}].", action, primaryTopologyInstance, primaryDeploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresSwapped, deploymentState);
                }

                // Bail out if we did not execute swap yet
                if (!primaryTopologyInstance.HasCustomizationValue(CommonCustomizationNames.IsSwapped, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment is not Swapped.", action, primaryTopologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresSwapped, action);
                }

                TopologyInstance stagingTopologyInstance;
                TopologyInstanceTableItem stagingTopologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Staging, out stagingTopologyInstance, out errorMessage, out stagingTopologyInstanceRow))
                {
                    return errorMessage;
                }

                // staging environment should be in finished state, deployed successfully
                DeploymentInstance existingStagingDeploymentInstance;
                Uri stagingDeploymentInstanceBlobUri;
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, stagingTopologyInstanceRow, EnvironmentGroup.Staging, out existingStagingDeploymentInstance, out stagingDeploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                primaryDeploymentInstance = new DeploymentInstance(primaryTopologyInstance.InstanceId);
                primaryDeploymentInstance.Initialize(primaryTopologyInstance);

                DeploymentInstance stagingDeploymentInstance = new DeploymentInstance(stagingTopologyInstance.InstanceId);
                stagingDeploymentInstance.Initialize(stagingTopologyInstance);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, primaryTopologyInstance, primaryDeploymentInstance, action);

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                // Back the topologies, primary and staging.
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Backing up primary and staging topologies before scheduling the commit workflow.");
                DeploymentRequest stagingRequest = new DeploymentRequest(tenantRegistration, stagingTopologyInstance, stagingDeploymentInstance, action);
                CommonHelper.BackupTopologyInstanceXml(request, stagingRequest);

                // check here if we can do migration of the storage account (primary is ARM and staging (the original) is RDFE).
                if (primaryTopologyInstance.ShouldUseAzureResourceManager() &&
                    !stagingTopologyInstance.ShouldUseAzureResourceManager())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Registering Azure resource providers [{0}], for topology [{1}], subscription ID [{2}].", TopologyInstancesController.MigrationResourceProviders, primaryTopologyInstance, tenantRegistration.AzureSubscriptionId.ToString());

                    if (!this.TryRegisterRequiredARMResourceProviderNamespaces(tenantRegistration, primaryTopologyInstance, TopologyInstancesController.MigrationResourceProviders, out errorMessage))
                    {
                        Tracer.WriteExecutionEvent(
                                        TraceComponent.DeploymentServiceApi,
                                        "Attempted to register Azure resource providers for topology [{0}], subscription ID [{1}], but not all providers could be registered. Error message [{2}].",
                                        primaryTopologyInstance.InstanceId,
                                        tenantRegistration.AzureSubscriptionId.ToString(),
                                        errorMessage);
                        return errorMessage;
                    }

                    // add a customization to indicate the migration needed for RDFE storage account
                    primaryTopologyInstance.SetCustomizationValue(CommonCustomizationNames.SwapCommitMigrateStorageAccountRDFEtoARM, true);
                }

                UploadBlobScheduleTaskInput primaryInput = new UploadBlobScheduleTaskInput()
                {
                    TopologyInstanceRow = primaryTopologyInstanceRow,
                    TopologyInstance = primaryTopologyInstance,
                    DeploymentInstance = primaryDeploymentInstance,
                    InitialDeploymentState = deploymentState,
                };

                UploadBlobScheduleTaskInput stagingInput = new UploadBlobScheduleTaskInput()
                {
                    TopologyInstanceRow = stagingTopologyInstanceRow,
                    TopologyInstance = stagingTopologyInstance,
                    DeploymentInstance = stagingDeploymentInstance,
                    InitialDeploymentState = deploymentState,
                };

                IEnumerable<UploadBlobScheduleTaskInput> inputs = new UploadBlobScheduleTaskInput[] { primaryInput, stagingInput };

                if (!this.TryUploadBlobAndScheduleTask(request, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, inputs, out errorMessage))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to commit topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to commit topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to validate the data upgrade.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage ValidateDataUpgrade(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Validating Data Upgrade before committing swapped topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ValidateDataUpgrade;
                DeploymentState deploymentState = DeploymentState.ValidatingDataUpgrade;

                HttpResponseMessage errorMessage;

                TopologyInstance primaryTopologyInstance;
                TopologyInstanceTableItem primaryTopologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out primaryTopologyInstance, out errorMessage, out primaryTopologyInstanceRow))
                {
                    return errorMessage;
                }

                DeploymentInstance primaryDeploymentInstance;
                Uri deploymentInstanceBlobUri;
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, primaryTopologyInstanceRow, EnvironmentGroup.Primary, out primaryDeploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                // Allow finished state because we may execute servicing in between swap and commit
                if (primaryDeploymentInstance.DeploymentState != DeploymentState.Swapped &&
                    primaryDeploymentInstance.DeploymentState != DeploymentState.Finished &&
                    primaryDeploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] instance corresponding to topology [{1}] but the primary deployment is currently in state [{2}].", action, primaryTopologyInstance, primaryDeploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresSwapped, deploymentState);
                }

                // Bail out if we did not execute swap yet
                if (!primaryTopologyInstance.HasCustomizationValue(CommonCustomizationNames.IsSwapped, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment is not Swapped.", action, primaryTopologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresSwapped, action);
                }

                TopologyInstance stagingTopologyInstance;
                TopologyInstanceTableItem stagingTopologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Staging, out stagingTopologyInstance, out errorMessage, out stagingTopologyInstanceRow))
                {
                    return errorMessage;
                }

                // staging environment should be in finished state, deployed successfully
                DeploymentInstance existingStagingDeploymentInstance;
                Uri stagingDeploymentInstanceBlobUri;
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, stagingTopologyInstanceRow, EnvironmentGroup.Staging, out existingStagingDeploymentInstance, out stagingDeploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                primaryDeploymentInstance = new DeploymentInstance(primaryTopologyInstance.InstanceId);
                primaryDeploymentInstance.Initialize(primaryTopologyInstance);

                DeploymentInstance stagingDeploymentInstance = new DeploymentInstance(stagingTopologyInstance.InstanceId);
                stagingDeploymentInstance.Initialize(stagingTopologyInstance);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, primaryTopologyInstance, primaryDeploymentInstance, action);

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                UploadBlobScheduleTaskInput primaryInput = new UploadBlobScheduleTaskInput()
                {
                    TopologyInstanceRow = primaryTopologyInstanceRow,
                    TopologyInstance = primaryTopologyInstance,
                    DeploymentInstance = primaryDeploymentInstance,
                    InitialDeploymentState = deploymentState,
                };

                UploadBlobScheduleTaskInput stagingInput = new UploadBlobScheduleTaskInput()
                {
                    TopologyInstanceRow = stagingTopologyInstanceRow,
                    TopologyInstance = stagingTopologyInstance,
                    DeploymentInstance = stagingDeploymentInstance,
                    InitialDeploymentState = deploymentState,
                };

                IEnumerable<UploadBlobScheduleTaskInput> inputs = new UploadBlobScheduleTaskInput[] { primaryInput, stagingInput };

                if (!this.TryUploadBlobAndScheduleTask(request, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, inputs, out errorMessage))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to commit topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to commit topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to cleanup failover resources for a topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage CleanupFailoverResources(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Cleaning up failover resources for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.CleanupFailoverResources;

                DeploymentState deploymentState = DeploymentState.Active;

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;

                // Cleanup failover not supported for staging
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (deploymentInstance.DeploymentState != DeploymentState.Finished &&
                    deploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance);
                deploymentInstance.RestartAction = action.ToString();

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out errorMessage, deploymentState))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to cleanup failover resources for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to cleanup failover resources for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to scale out a deployment instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The topology instance.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        [SuppressMessage("Microsoft.MSInternal", "CA908", Justification = "Not a precompiled assembly")]
        public HttpResponseMessage ScaleOut(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            DeploymentInstance deploymentInstance = null;
            TopologyInstance topologyInstance = null;
            TopologyInstanceTableItem topologyInstanceRow = null;
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ScaleOut;
            TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

            try
            {
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                IEnumerable<ScaleoutParameter> scaleoutParameters = this.GetParameterOrDefault<IEnumerable<ScaleoutParameter>>(parameters, CommonDeploymentActionParameters.ScaleoutData, null);
                if (scaleoutParameters == null || !scaleoutParameters.Any())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "No Scaleout parameters provided in input, topology instance [{0}].", topologyInstance.ToString());
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutOperationNoInputParameters, topologyInstance.ToString(), CommonDeploymentActionParameters.ScaleoutData);
                    return errorMessage;
                }

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (deploymentInstance.DeploymentState != DeploymentState.Finished && deploymentInstance.DeploymentState != DeploymentState.SafeMode && deploymentInstance.DeploymentStatus != Model.DeploymentStatus.StateTransitionIncompleteInDR)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, action);
                }

                if (!topologyInstance.ShouldUseAzureResourceManager())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to perform a scale out operation on RDFE that is not supported");
                    return this.CreateErrorResponse(ServiceErrorCode.ScaleOutOperationNotSupported);
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                // verify input parameters and update relevant fields in topology from param topology
                if (!this.ProcessScaleOutInput(scaleoutParameters, topologyInstance, tenantRegistration, environmentGroup, out errorMessage))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "ScaleOut input processing failed with error message [{0}]. ", this.GetMessageError(errorMessage));
                    return errorMessage;
                }

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance);
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.EnvironmentGroup, environmentGroup.ToString());
                deploymentInstance.RestartAction = action.ToString();

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                // DeploymentState.ScalingOut: The default deployment status is Undefined or Queued and will stay that way untill the end of the flow.
                // Changed to DeploymentState.ScalingOut to indicate we are executing the scaleout
                if (!this.ValidateTopologyConsistency(topologyInstance, azureSubscriptionId, tenantRegistration, action, out errorMessage) ||
                    !this.TryProcessCustomizations(topologyInstance, action, out errorMessage) ||
                    !this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentServiceVMScaleoutWorkflow.TaskNameConstant, out errorMessage, DeploymentState.ScalingOut))
                {
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, topologyInstance);

                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to scale out topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                if (tenantRegistration != null && topologyInstance != null)
                {
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, topologyInstance);
                }

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to scale out topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to update a deployment instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The topology instance.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        [SuppressMessage("Microsoft.MSInternal", "CA908", Justification = "Not a precompiled assembly")]
        public HttpResponseMessage Update(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            TopologyInstance paramEntity = null;
            DeploymentInstance deploymentInstance = null;
            TopologyInstance topologyInstance = null;
            TopologyInstanceTableItem topologyInstanceRow = null;
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.Update;
            TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

            try
            {
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;

                paramEntity = Serialization.DeserializeFromString<TopologyInstance>((string)parameters[TopologyInstanceParameter]);

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, paramEntity.EnvironmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, paramEntity.EnvironmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (deploymentInstance.DeploymentState != DeploymentState.Finished)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, action);
                }

                if (!topologyInstance.ShouldUseAzureResourceManager())
                {
                    IServiceManagement azureProxy;
                    AzureSubcription subscription;
                    Func<IServiceManagement, AzureSubcription> getSubscription = (proxy) => proxy.GetAzureSubscription(tenantRegistration.AzureSubscriptionId);

                    if (!this.ValidateTenantRegistrationCertificate(tenantRegistration, out errorMessage, out azureProxy, out subscription, getSubscription))
                    {
                        return errorMessage;
                    }
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                // Check count of available IPs
                if (topologyInstance.ShouldUseAzureResourceManager() &&
                    topologyInstance.UsesExistingInfrastructure(CommonCustomizationNames.VnetName, CommonCustomizationNames.UseExistingVnet))
                {
                    int deltaBetweenVMs = paramEntity.GetVirtualMachineCount() - topologyInstance.GetVirtualMachineCount();
                    if (!this.ValidateARMAvailableIPs(deltaBetweenVMs, topologyInstance, tenantRegistration, out errorMessage))
                    {
                        return errorMessage;
                    }
                }

                // update relevant fields in topology from param topology
                foreach (var deploymentItem in topologyInstance.DeploymentItems)
                {
                    var paramItem = paramEntity.DeploymentItems.FirstOrDefault(di => string.Equals(di.ItemName, deploymentItem.ItemName, StringComparison.OrdinalIgnoreCase));

                    if (paramItem != null)
                    {
                        string instanceCount;
                        if (paramItem.TryGetCustomizationValue(CommonCustomizationNames.InstanceCount, out instanceCount))
                        {
                            Tracer.WriteExecutionEvent(
                                TraceComponent.DeploymentServiceApi,
                                "Setting value of [{0}] for customization [{1}] from parameter topology instance into one we fetched from storage.",
                                instanceCount,
                                CommonCustomizationNames.InstanceCount);
                            deploymentItem.SetCustomizationValue(CommonCustomizationNames.InstanceCount, instanceCount);
                        }

                        string roleSize;
                        if (paramItem.TryGetCustomizationValue(CommonCustomizationNames.RoleSize, out roleSize))
                        {
                            Tracer.WriteExecutionEvent(
                                TraceComponent.DeploymentServiceApi,
                                "Setting value of [{0}] for customization [{1}] from parameter topology instance into one we fetched from storage.",
                                roleSize,
                                CommonCustomizationNames.RoleSize);
                            deploymentItem.SetCustomizationValue(CommonCustomizationNames.RoleSize, roleSize);
                        }
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Could not find matching item with name [{0}] in parameter topology instance.", deploymentItem.ItemName);
                    }
                }

                this.PopulateCloudServiceInstances(topologyInstance, tenantRegistration);

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance);
                deploymentInstance.RestartAction = action.ToString();

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                List<TopologyInstance> ongoingTopologyInstances;
                this.GetDeployingTopologyInstances(tenantRegistration.TenantId, out ongoingTopologyInstances);

                Lazy<bool> coresAvailable = new Lazy<bool>(() =>
                {
                    if (request.Topology.ShouldUseAzureResourceManager())
                    {
                        using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager())
                        {
                            return this.ValidateTopologyARMCoresAvailabilityForUpdate(
                                tenantRegistration.AzureSubscriptionId,
                                request.Topology,
                                out errorMessage,
                                ongoingTopologyInstances.Where(d => d.ShouldUseAzureResourceManager() && string.Equals(d.CloudServiceLocation, request.Topology.CloudServiceLocation, StringComparison.OrdinalIgnoreCase)).ToList(),
                                manager,
                                this.GetCoreCountForUpdate(request.Topology));
                        }
                    }
                    else
                    {
                        IServiceManagement azureProxy;
                        AzureSubcription subscription;
                        Func<IServiceManagement, AzureSubcription> getSubscription = (proxy) => proxy.GetAzureSubscription(tenantRegistration.AzureSubscriptionId);

                        return this.ValidateTenantRegistrationCertificate(tenantRegistration, out errorMessage, out azureProxy, out subscription, getSubscription)
                            && this.ValidateTopologyRDFECoresAvailabilityForUpdate(azureSubscriptionId, request.Topology, out errorMessage, subscription, ongoingTopologyInstances.Where(d => !d.ShouldUseAzureResourceManager()).ToList());
                    }
                });

                if (!coresAvailable.Value ||
                    !this.ValidateTopologyConsistency(topologyInstance, azureSubscriptionId, tenantRegistration, action, out errorMessage) ||
                    !this.AllocateCloudServiceNames(request, out errorMessage) ||
                    !this.TryProcessCustomizations(topologyInstance, action, out errorMessage) ||
                    !this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentServiceMasterWorkflow.TaskNameConstant, out errorMessage))
                {
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, topologyInstance);

                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to update topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                if (tenantRegistration != null && topologyInstance != null)
                {
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, topologyInstance);
                }

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to update topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to move a VM from live pool to Maintenance pool.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage MoveToMaintenance(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            return this.MoveToPool(tenantId, azureSubscriptionId, topologyInstanceId, parameters, DeploymentRequest.DeploymentAction.MoveVMToMaintenancePool);
        }

        /// <summary>
        /// Action used to move a VM from Maintenance pool to live pool.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage MoveToLive(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            return this.MoveToPool(tenantId, azureSubscriptionId, topologyInstanceId, parameters, DeploymentRequest.DeploymentAction.MoveVMToLivePool);
        }

        /// <summary>
        /// Action used to restart a deployment instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The topology instance.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage Restart(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.Restart;
            TopologyInstance topologyInstance = null;
            DeploymentInstance deploymentInstance = null;

            try
            {
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;

                TopologyInstanceTableItem topologyInstanceRow;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow) ||
                    !this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                // Clear previous parameters if any
                deploymentInstance.DeploymentActionParameters.Clear();

                // Validate parameters
                if (parameters != null &&
                    (parameters.ContainsKey(DeploymentConstants.RestartDeploymentItemParameter) ||
                    parameters.ContainsKey(DeploymentConstants.RestartInstanceNameParameter) ||
                    parameters.ContainsKey(DeploymentConstants.RestartScriptIdentifierParameter)))
                {
                    string deploymentItemName;
                    object deploymentItemNameParameter;
                    if (!parameters.TryGetValue(DeploymentConstants.RestartDeploymentItemParameter, out deploymentItemNameParameter))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Restart call is missing parameter [{0}]", DeploymentConstants.RestartDeploymentItemParameter);
                        return this.CreateErrorResponse(ServiceErrorCode.RestartInvalidParameters, DeploymentConstants.RestartDeploymentItemParameter);
                    }
                    else
                    {
                        deploymentItemName = (string)deploymentItemNameParameter;
                    }

                    string instanceName;
                    object instanceNameParameter;
                    if (!parameters.TryGetValue(DeploymentConstants.RestartInstanceNameParameter, out instanceNameParameter))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Restart call is missing parameter [{0}]", DeploymentConstants.RestartInstanceNameParameter);
                        return this.CreateErrorResponse(ServiceErrorCode.RestartInvalidParameters, DeploymentConstants.RestartInstanceNameParameter);
                    }
                    else
                    {
                        instanceName = (string)instanceNameParameter;
                    }

                    string scriptIdentifier;
                    object scriptIdentifierParameter;
                    if (!parameters.TryGetValue(DeploymentConstants.RestartScriptIdentifierParameter, out scriptIdentifierParameter))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Restart call is missing parameter [{0}]", DeploymentConstants.RestartScriptIdentifierParameter);
                        return this.CreateErrorResponse(ServiceErrorCode.RestartInvalidParameters, DeploymentConstants.RestartScriptIdentifierParameter);
                    }
                    else
                    {
                        scriptIdentifier = (string)scriptIdentifierParameter;
                    }

                    DeploymentItem targetDeploymentItem = topologyInstance.DeploymentItems.FirstOrDefault(di => String.Equals(di.ItemName, deploymentItemName, StringComparison.OrdinalIgnoreCase));
                    if (targetDeploymentItem == null)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Restart call parameter [{0}] with value [{1}] does not match any entries in the topology", DeploymentConstants.RestartDeploymentItemParameter, deploymentItemName);
                        return this.CreateErrorResponse(ServiceErrorCode.RestartInvalidParameters, DeploymentConstants.RestartDeploymentItemParameter, deploymentItemName);
                    }

                    Instance targetInstance = targetDeploymentItem.Instances.FirstOrDefault(i => String.Equals(i.MachineName, instanceName, StringComparison.OrdinalIgnoreCase));
                    if (targetInstance == null)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Restart call parameter [{0}] with value [{1}] does not match any entries in the topology", DeploymentConstants.RestartInstanceNameParameter, instanceName);
                        return this.CreateErrorResponse(ServiceErrorCode.RestartInvalidParameters, DeploymentConstants.RestartInstanceNameParameter, instanceName);
                    }

                    Instance.Script script;
                    if (!targetInstance.TryGetScriptInstance(scriptIdentifier, out script))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Restart call parameter [{0}] with value [{1}] does not match any entries in the topology", DeploymentConstants.RestartScriptIdentifierParameter, scriptIdentifier);
                        return this.CreateErrorResponse(ServiceErrorCode.RestartInvalidParameters, DeploymentConstants.RestartScriptIdentifierParameter, scriptIdentifier);
                    }

                    // Commit parameters
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Committing restart parameters: [{0}] [{1}] [{2}]", deploymentItemName, instanceName, scriptIdentifier);

                    deploymentInstance.DeploymentActionParameters.Add(DeploymentConstants.RestartDeploymentItemParameter, deploymentItemName);
                    deploymentInstance.DeploymentActionParameters.Add(DeploymentConstants.RestartInstanceNameParameter, instanceName);
                    deploymentInstance.DeploymentActionParameters.Add(DeploymentConstants.RestartScriptIdentifierParameter, scriptIdentifier);
                }

                // Do not allow restart if the instance is disabled or the last action was not restartable.
                bool restartableState = false;
                bool debugMode = false;
                if (deploymentInstance.DeploymentState != DeploymentState.Finished ||
                    !topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.IsInRestartableState, out restartableState) ||
                    !restartableState ||
                    !topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.DebugMode, out debugMode) ||
                    !debugMode)
                {
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                    return this.CreateErrorResponse(ServiceErrorCode.RestartOperationNotAllowed);
                }

                IServiceManagement azureProxy;
                AzureSubcription subscription;
                Func<IServiceManagement, AzureSubcription> getSubscription = (proxy) => proxy.GetAzureSubscription(tenantRegistration.AzureSubscriptionId);

                // Backwards compatibility
                if (String.IsNullOrWhiteSpace(deploymentInstance.RestartAction))
                {
                    deploymentInstance.RestartAction = topologyInstanceRow.LastDeploymentAction;
                }

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                if ((!topologyInstance.ShouldUseAzureResourceManager() && !this.ValidateTenantRegistrationCertificate(tenantRegistration, out errorMessage, out azureProxy, out subscription, getSubscription)) ||
                    !this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentServiceMasterWorkflow.TaskNameConstant, out errorMessage))
                {
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to configure topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to configure topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to configure the topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology will be deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>
        /// An HTTPResponseMessage.
        /// </returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage Configure(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.Configure;

            try
            {
                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Running Configure(tenantId=[{0}], azureSubscriptionId=[{1}], topologyInstanceId=[{2}])",
                    tenantId,
                    azureSubscriptionId,
                    topologyInstanceId);

                //// Parse configuration array from parameter

                string[] configurationIds = null;

                if (parameters.ContainsKey(DeploymentConstants.ConfigurationsIdsParameter) && parameters[DeploymentConstants.ConfigurationsIdsParameter] is string)
                {
                    string configurationIdsStr = (string)parameters[DeploymentConstants.ConfigurationsIdsParameter];
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Parsing configurations. Input = {0}", configurationIdsStr);
                    configurationIds = configurationIdsStr.Split(DeploymentConstants.ConfigurationSeparator);
                }

                if (configurationIds == null && configurationIds.Length == 0)
                {
                    return this.CreateErrorResponse(HttpStatusCode.BadRequest, string.Format(CultureInfo.InvariantCulture, "Invalid parameter {0}", DeploymentConstants.ConfigurationsIdsParameter));
                }

                //// Parse customizations from parameter

                var customizationDictionary = new Dictionary<string, string>();

                if (parameters.ContainsKey(DeploymentConstants.CustomizationsParameter))
                {
                    var customizationValuesStr = parameters[DeploymentConstants.CustomizationsParameter] as string;

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Parsing customization entries. Input = {0}", BlobHelperV2.RemoveSasTokenFromBlobUrl(customizationValuesStr));

                    if (string.IsNullOrWhiteSpace(customizationValuesStr))
                    {
                        return this.CreateErrorResponse(HttpStatusCode.BadRequest, string.Format(CultureInfo.InvariantCulture, "Invalid parameter '{0}'. ", DeploymentConstants.CustomizationsParameter));
                    }

                    foreach (var pair in customizationValuesStr.Split(DeploymentConstants.CustomizationPairSeparator))
                    {
                        // Parsing name and value
                        var tokens = pair.Split(DeploymentConstants.CustomizationKeyValueSeparator);
                        if (tokens == null || tokens.Length != 2)
                        {
                            return this.CreateErrorResponse(HttpStatusCode.BadRequest, string.Format(CultureInfo.InvariantCulture, "Invalid parameter '{0}'. Value '{1}' does not conform with expected format. ", DeploymentConstants.CustomizationsParameter, pair));
                        }

                        var key = tokens[0];
                        var value = tokens[1];
                        customizationDictionary[key] = value;
                    }
                }

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Retrieved topology instance [{0}]", topologyInstanceId);

                // Applying the customization changes
                foreach (var entry in customizationDictionary)
                {
                    topologyInstance.SetCustomizationValue(entry.Key, entry.Value);
                }

                // Validating configurations and their scripts
                foreach (var configurationId in configurationIds)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Validating configuration '{0}' in topology instance '{1}'", configurationId, topologyInstance);
                    var configuration = topologyInstance.Configurations.FirstOrDefault(cfg => cfg.Identifier == configurationId);

                    if (configuration == null)
                    {
                        return this.CreateErrorResponse(HttpStatusCode.BadRequest, string.Format(CultureInfo.InvariantCulture, "Configuration '{0}' does not exist in topology instance '{1}'", configurationId, topologyInstance));
                    }

                    foreach (var downloadfile in configuration.DownloadFiles)
                    {
                        if (string.IsNullOrWhiteSpace(downloadfile.TargetItemName))
                        {
                            return this.CreateErrorResponse(HttpStatusCode.BadRequest, string.Format(CultureInfo.InvariantCulture, "Configuration '{0}' with download file name '{1}' has no target deployment item property in topology instance [{2}].", configuration.Identifier, downloadfile.DestinationFileName, topologyInstance));
                        }

                        var isTargetItemExist = topologyInstance.DeploymentItems.Any(d => String.Equals(d.ItemName, downloadfile.TargetItemName));
                        if (!isTargetItemExist)
                        {
                            return this.CreateErrorResponse(HttpStatusCode.BadRequest, string.Format(CultureInfo.InvariantCulture, "Configuration '{0}' with download file name '{1}' does not have target deployment item '{3}' in topology instance [{2}].", configuration.Identifier, downloadfile.DestinationFileName, topologyInstance, downloadfile.TargetItemName));
                        }
                    }

                    foreach (var scriptRef in configuration.ScriptsReferences)
                    {
                        var script = topologyInstance.SetupScripts.FirstOrDefault(s => s.Identifier == scriptRef.Identifier);
                        if (script == null)
                        {
                            return this.CreateErrorResponse(HttpStatusCode.BadRequest, string.Format(CultureInfo.InvariantCulture, "Configuration '{0}' references script '{1}', but that script was not found in topology instance [{2}].", configuration.Identifier, scriptRef.Identifier, topologyInstance));
                        }
                    }
                }

                //// Create a new deployment instance to track the configuration operation

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Retrieved deployment instance [{0}]", deploymentInstance.DeploymentId);

                if (deploymentInstance.DeploymentState != DeploymentState.Finished)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, action);
                }

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

                IServiceManagement azureProxy;
                AzureSubcription subscription;
                Func<IServiceManagement, AzureSubcription> getSubscription = (proxy) => proxy.GetAzureSubscription(tenantRegistration.AzureSubscriptionId);

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance);
                deploymentInstance.RestartAction = action.ToString();

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);
                request.ConfigurationIdentifiers = configurationIds;

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                if ((!topologyInstance.ShouldUseAzureResourceManager() && !this.ValidateTenantRegistrationCertificate(tenantRegistration, out errorMessage, out azureProxy, out subscription, getSubscription)) ||
                    !this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentServiceMasterWorkflow.TaskNameConstant, out errorMessage))
                {
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to configure topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to configure topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to retrieve the URI for the XML representation of the topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the azure subscription in where the topology is (to be) deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An XML URI.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetXmlUri(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                var tableRow = GetTopologyTableItem(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup);

                if (tableRow == null)
                {
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresExistingEnvironmentGroup, environmentGroup);
                }

                string topologyInstanceUri = tableRow.TopologyInstance;
                if (String.IsNullOrWhiteSpace(topologyInstanceUri))
                {
                    return this.CreateErrorResponse(HttpStatusCode.NotFound, "Item is missing blob data.");
                }

                var storageAccount = BlobHelper.GetStorageAccount(WellKnownStorageAccounts.DeploymentServiceStorage);

                var topologyInstanceSasUri = BlobHelper.GetBlobSasUri(new Uri(topologyInstanceUri), storageAccount, SASAccessInterval);

                return Request.CreateResponse(HttpStatusCode.OK, topologyInstanceSasUri);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to retrieve the ARM Template archive string of an instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetARMTemplateArchive(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                TopologyInstance entity;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out entity, out error, out topologyInstanceRow))
                {
                    return error;
                }
                else if (entity.ARM == null || entity.ARM.Template == null)
                {
                    HttpResponseMessage errorMessage = new HttpResponseMessage(HttpStatusCode.NotFound);
                    errorMessage.ReasonPhrase = "The ARM template is null.";
                    throw new HttpResponseException(errorMessage);
                }

                byte[] templateArchive = entity.ARM.Template.GetARMTemplateArchive();

                return Request.CreateResponse(HttpStatusCode.OK, templateArchive);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to retrieve the credentials of an instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.RetailApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ElasticPoolMigrationService,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetCredentials(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                string deploymentItemName = parameters.ContainsKey(DeploymentItemNameParameter) ? (string)parameters[DeploymentItemNameParameter] : null;
                string username = parameters.ContainsKey(UsernameParameter) ? (string)parameters[UsernameParameter] : null;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                TopologyInstance entity;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out entity, out error, out topologyInstanceRow))
                {
                    return error;
                }

                string accountName = this.Request.Headers.Contains(ODataConstants.HttpHeaders.AccountName)
                    ? this.Request.Headers.GetValues(ODataConstants.HttpHeaders.AccountName).FirstOrDefault()
                    : null;

                if (!string.IsNullOrWhiteSpace(accountName))
                {
                    OperationsInstance operationsInstance;
                    if (!this.CreateOrGetOperationsInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out operationsInstance, out error))
                    {
                        return error;
                    }

                    this.ResolveJITCredential(entity, accountName, operationsInstance);
                }

                var credentials = from item in entity.DeploymentItems
                                  where String.IsNullOrWhiteSpace(deploymentItemName) || String.Compare(item.ItemName, deploymentItemName, StringComparison.OrdinalIgnoreCase) == 0
                                  from cred in item.Credentials
                                  where String.IsNullOrWhiteSpace(username) || String.Compare(cred.UserName, username, StringComparison.OrdinalIgnoreCase) == 0
                                  select cred;

                if (!credentials.Any())
                {
                    return this.CreateErrorResponse(HttpStatusCode.NotFound, "No credentials found that match supplied parameters.");
                }

                foreach (var credential in credentials)
                {
                    KeyVaultClient.Instance.GetSecret(credential.KeyVaultablePassword);
                    credential.KeyVaultablePassword.SerializeRawValue = true;
                }

                return Request.CreateResponse(HttpStatusCode.OK, credentials);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to retrieve the active SQL connection string of primary or disaster recovery database (in case of fail over).
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate
            | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application
            | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ERPMicroservicesApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        [SuppressMessage("Microsoft.StyleCop.CSharp.NamingRules", "SA1305:FieldNamesMustNotUseHungarianNotation", Justification = "Not a hungarian notation.")]
        public HttpResponseMessage GetSQLConnectionString(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                string dbItemName = this.GetParameterOrDefault(parameters, DbItemName, String.Empty);
                string username = parameters.ContainsKey(UsernameParameter) ? (string)parameters[UsernameParameter] : null;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                TopologyInstance entity;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out entity, out error, out topologyInstanceRow))
                {
                    error = this.CreateErrorResponse(HttpStatusCode.NotFound, ServiceErrorCode.OperationNotAllowed_RequiresExistingEnvironmentGroup.ToString());
                    return error;
                }

                // Get primary database deployment item matching the request (credentials won't be empty for primary database)
                var sqlDatabaseItem = entity.DeploymentItems.FirstOrDefault(di => (di.IsItemType(DeploymentItemType.SQLServerDatabase)
                                                                    || di.IsItemType(DeploymentItemType.AzureSQLDatabase))
                                                                    && di.ItemName.StartsWith(dbItemName, StringComparison.OrdinalIgnoreCase)
                                                                    && di.Credentials.Any());

                if (sqlDatabaseItem == null)
                {
                    return this.CreateErrorResponse(HttpStatusCode.NotFound, "No database found that matches supplied name.");
                }

                // Get SQL server and database details
                AzureSQLDatabaseInfo databaseInfo = null;
                string sqlServerName = null;
                string databaseName = sqlDatabaseItem.ItemName;
                IEnumerable<Credential> credentials = null;

                if (sqlDatabaseItem.IsItemType(DeploymentItemType.AzureSQLDatabase))
                {
                    // Prod/sandbox topologies has azure sql server, get the azure SQL server deployment item to extract database info
                    DeploymentItem sqlServerItem = entity.DeploymentItems.FirstOrDefault(sqlServer => String.Equals(sqlServer.ItemName, sqlDatabaseItem.ParentItemName, StringComparison.OrdinalIgnoreCase)
                         && sqlServer.IsItemType(DeploymentItemType.AzureSQLServer));

                    if (!sqlDatabaseItem.TryGetAzureSqlDatabaseConnectionInfo(sqlServerItem, out databaseInfo))
                    {
                        return this.CreateErrorResponse(HttpStatusCode.NotFound, "No credentials found that match supplied parameters.");
                    }
                    else
                    {
                        sqlServerName = databaseInfo.FullyQualifiedDomainName;
                        databaseName = databaseInfo.DatabaseName;
                        credentials = databaseInfo.Credentials;
                    }

                    // Check for DR scenarios to see if SQL failover has happened then return DR connection string.
                    if (entity.IsDisasterRecoveryEnabled()
                        && entity.DeploymentState == DeploymentState.SafeMode)
                    {
                        string drDatabaseName = Utilities.GenerateDisasterRecoveryName(sqlDatabaseItem.ItemName, suffixUppercase: true);

                        // Get DR SQL database deployment item
                        var sqlDatabaseItemDR = entity.DeploymentItems.FirstOrDefault(di => di.IsItemType(DeploymentItemType.AzureSQLDatabase)
                                                                       && di.ItemName.Contains(drDatabaseName, StringComparison.OrdinalIgnoreCase));

                        if (sqlDatabaseItemDR == null)
                        {
                            return this.CreateErrorResponse(HttpStatusCode.NotFound, "No DR SQL database details found.");
                        }

                        // Get DR SQL Server deployment item
                        DeploymentItem sqlServerItemDR = entity.DeploymentItems.FirstOrDefault(sqlServer => String.Equals(sqlServer.ItemName, sqlDatabaseItemDR.ParentItemName, StringComparison.OrdinalIgnoreCase)
                                && sqlServer.IsItemType(DeploymentItemType.AzureSQLServer));

                        AzureSQLDatabaseInfo databaseInfoDR = null;

                        if (!sqlDatabaseItemDR.TryGetAzureSqlDatabaseConnectionInfo(sqlServerItemDR, out databaseInfoDR))
                        {
                            return this.CreateErrorResponse(HttpStatusCode.NotFound, "No credentials found that match supplied parameters.");
                        }

                        sqlServerName = databaseInfoDR.FullyQualifiedDomainName;
                        databaseName = databaseInfoDR.DatabaseName;
                    }
                }
                else if (sqlDatabaseItem.IsItemType(DeploymentItemType.SQLServerDatabase))
                {
                    // Onebox environment, hence return environment address
                    sqlServerName = entity.ReservedIPs.FirstOrDefault(rip => !string.IsNullOrWhiteSpace(rip.Address)).Address;
                    databaseName = sqlDatabaseItem.GetCustomizationValue(CommonCustomizationNames.SQLServerDatabaseName);
                    var oneboxDeploymentItem = entity.DeploymentItems.First(di => di.IsItemType(DeploymentItemType.VirtualMachine)
                                                            && di.Credentials.Any(cred => String.Equals(cred.SymbolicName, CommonCustomizationNames.SqlServerLoginSymbolicName, StringComparison.OrdinalIgnoreCase)));
                    if (oneboxDeploymentItem != null)
                    {
                        credentials = oneboxDeploymentItem.Credentials.Where(cred => String.Equals(cred.SymbolicName, CommonCustomizationNames.SqlServerLoginSymbolicName, StringComparison.OrdinalIgnoreCase));
                    }
                }

                if (string.IsNullOrEmpty(sqlServerName))
                {
                    return this.CreateErrorResponse(HttpStatusCode.NotFound, "No SQL server details found.");
                }

                // Gets credential for requested database and username
                var credential = credentials.FirstOrDefault(cred => cred.UserName.Equals(username, StringComparison.OrdinalIgnoreCase));

                if (credential == null)
                {
                    return this.CreateErrorResponse(HttpStatusCode.NotFound, "No credentials found that match supplied role.");
                }

                KeyVaultClient.Instance.GetSecret(credential.KeyVaultablePassword);
                credential.KeyVaultablePassword.SerializeRawValue = true;

                var primaryConnectionStringBuilder = new SqlConnectionStringBuilder();
                primaryConnectionStringBuilder.DataSource = sqlServerName;
                primaryConnectionStringBuilder.InitialCatalog = databaseName;
                primaryConnectionStringBuilder.UserID = credential.UserName;
                primaryConnectionStringBuilder.Password = credential.KeyVaultablePassword.Value;

                return Request.CreateResponse(HttpStatusCode.OK, primaryConnectionStringBuilder.ConnectionString);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to retrieve the certificates of an instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application
            | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ERPMicroservicesApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetCertificatesPublicKeys(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                string certificateIdentifier = parameters.ContainsKey(CertificateIdentifierParameter) ? (string)parameters[CertificateIdentifierParameter] : null;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                TopologyInstance topologyInstance;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out error, out topologyInstanceRow))
                {
                    return this.CreateErrorResponse(HttpStatusCode.NotFound, ServiceErrorCode.OperationNotAllowed_RequiresExistingEnvironmentGroup.ToString());
                }

                var certificates = from certificateDefinition in topologyInstance.Certificates
                                   where String.IsNullOrWhiteSpace(certificateIdentifier) || String.Compare(certificateDefinition.Identifier, certificateIdentifier, StringComparison.OrdinalIgnoreCase) == 0
                                   select certificateDefinition;

                foreach (var certificateDefinition in certificates)
                {
                    KeyVaultClient.Instance.GetCertificatePublicKey(certificateDefinition.KeyVaultableRawData, certificateDefinition.KeyVaultablePassword);
                    certificateDefinition.KeyVaultableRawData.SerializeRawValue = true;
                    certificateDefinition.KeyVaultableRawData.SecretUri = null;
                    certificateDefinition.KeyVaultablePassword = null;
                    certificateDefinition.Password = null;
                }

                if (!certificates.Any())
                {
                    return this.CreateErrorResponse(HttpStatusCode.NotFound, "No certificates found that match supplied parameters.");
                }

                return Request.CreateResponse(HttpStatusCode.OK, certificates);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to retrieve the certificates of an instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.RetailApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetCertificates(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                string certificateIdentifier = parameters.ContainsKey(CertificateIdentifierParameter) ? (string)parameters[CertificateIdentifierParameter] : null;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                TopologyInstance topologyInstance;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out error, out topologyInstanceRow))
                {
                    return error;
                }

                var certificates = from certificateDefinition in topologyInstance.Certificates
                                   where String.IsNullOrWhiteSpace(certificateIdentifier) || String.Compare(certificateDefinition.Identifier, certificateIdentifier, StringComparison.OrdinalIgnoreCase) == 0
                                   select certificateDefinition;

                foreach (var certificateDefinition in certificates)
                {
                    KeyVaultClient.Instance.GetSecret(certificateDefinition.KeyVaultableRawData);
                    certificateDefinition.KeyVaultableRawData.SerializeRawValue = true;

                    KeyVaultClient.Instance.GetSecret(certificateDefinition.KeyVaultablePassword);
                    certificateDefinition.KeyVaultablePassword.SerializeRawValue = true;
                }

                // SSL Certificates are stored in a different way, so get matching entries from a set of "known" certificates
                // GetSslCertificateDefinitions will handle the case for requesting a specific certificate via its identifier
                IEnumerable<CertificateDefinition> knownCertificateDefinitions = GetSslCertificateDefinitions(topologyInstance, certificateIdentifier);

                certificates = certificates.Concat(knownCertificateDefinitions);

                if (!certificates.Any())
                {
                    return this.CreateErrorResponse(HttpStatusCode.NotFound, "No certificates found that match supplied parameters.");
                }

                return Request.CreateResponse(HttpStatusCode.OK, certificates);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to trigger powershell script if allowed.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        public HttpResponseMessage ExecutePowershellScript(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            Contract.Requires(tenantId != Guid.Empty);
            Contract.Requires(azureSubscriptionId != Guid.Empty);
            Contract.Requires(!string.IsNullOrWhiteSpace(topologyInstanceId));
            string powershellScriptActionName = parameters.ContainsKey(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.PowershellScriptActionParameterName) ? (string)parameters[Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.PowershellScriptActionParameterName] : String.Empty;

            if (string.IsNullOrWhiteSpace(powershellScriptActionName))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "ExecutePowershellScript invoked for topology instance [{1}] without script name", topologyInstanceId);
                return this.CreateErrorResponse(ServiceErrorCode.ExecutePowershellScript_MissingInputParameter, Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.PowershellScriptActionParameterName);
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "ExecutePowershellScript:{0} invoked for topology instance [{1}]", powershellScriptActionName, topologyInstanceId);
            ServiceConstants.ValidPowershellScriptsAction powershellScriptAction;

            // Validate if the script action is allowed
            if (!Enum.TryParse<ServiceConstants.ValidPowershellScriptsAction>(powershellScriptActionName, out powershellScriptAction))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "ExecutePowershellScript invoked for topology instance [{1}]", powershellScriptActionName, topologyInstanceId);
                return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, ServiceConstants.ExecutePowershellScriptActionName, powershellScriptActionName, Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.PowershellScriptActionParameterName);
            }

            HttpResponseMessage errorResponseMessage;
            TopologyInstanceTableItem topologyInstanceRow;
            TopologyInstance topologyInstance;
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ExecutePowershellScript;

            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorResponseMessage, out topologyInstanceRow))
                {
                    return errorResponseMessage;
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Retrieved topology instance [{0}]", topologyInstanceId);
                DeploymentInstance deploymentInstance = new DeploymentInstance(topologyInstance);
                deploymentInstance.DeploymentActionParameters.Add(Library.Constants.PowershellScriptActionParameterName, powershellScriptActionName);
                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out errorResponseMessage, topologyInstance.DeploymentState))
                {
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorResponseMessage);
                    return errorResponseMessage;
                }

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Execute Powershell script: {0} for topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}' successfully.",
                    powershellScriptAction,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (ServiceException serviceException)
            {
                ServiceErrorCode errorCode = (ServiceErrorCode)Enum.Parse(typeof(ServiceErrorCode), serviceException.ErrorCode);

                if (errorCode.Equals(ServiceErrorCode.TaskSchedulerGeneralFailure))
                {
                    Tracer.WriteErrorEvent(
                        TraceComponent.DeploymentServiceApi,
                        serviceException,
                        "Failed to create a new task to execute powershell script: {0} for topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}' since it is already enqueued. ErrorMessage-'{4}'.",
                        powershellScriptActionName,
                        topologyInstanceId,
                        azureSubscriptionId,
                        tenantId,
                        serviceException.ErrorCode,
                        serviceException.Message);
                    errorResponseMessage = this.CreateErrorResponse(ServiceErrorCode.ExecutePowershellScript_TaskAlreadyQueued, powershellScriptActionName);
                }
                else
                {
                    Tracer.WriteErrorEvent(
                        TraceComponent.DeploymentServiceApi,
                        serviceException,
                        "Failed to execute powershell script: {0} for topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'. ErrorMessage-'{4}'.",
                        powershellScriptActionName,
                        topologyInstanceId,
                        azureSubscriptionId,
                        tenantId,
                        serviceException.ErrorCode,
                        serviceException.Message);

                    errorResponseMessage = this.CreateErrorResponse(serviceException);
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorResponseMessage);
                    Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                }

                return errorResponseMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to execute powershell script: {0} for topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'. ErrorMessage-'{4}'.",
                    powershellScriptActionName,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    error.Message);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to retrieve the version of the customer deployment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
         authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ElasticPoolMigrationService | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.HealthServiceUnitService | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.CSPReleaseValidation,
         tenantIdParam: "tenantId",
         azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetVersionInfo(
         [FromODataUri] Guid tenantId,
         [FromODataUri] Guid azureSubscriptionId,
         [FromODataUri] string topologyInstanceId,
         ODataActionParameters parameters)
        {
            return this.GetVersionInfo(tenantId, azureSubscriptionId, topologyInstanceId, parameters, false);
        }

        /// <summary>
        /// Action used to retrieve the detailed version instance of the customer deployment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
         authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.CSPReleaseValidation,
         tenantIdParam: "tenantId",
         azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetDetailedVersionInfo(
         [FromODataUri] Guid tenantId,
         [FromODataUri] Guid azureSubscriptionId,
         [FromODataUri] string topologyInstanceId,
         ODataActionParameters parameters)
        {
            return this.GetVersionInfo(tenantId, azureSubscriptionId, topologyInstanceId, parameters, true);
        }

        /// <summary>
        /// Action used to rotate secrets for an environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage RotateSecrets(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Rotating secrets for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                string secretTypesToRotateString = parameters.ContainsKey(CommonDeploymentActionParameters.SecretTypesToRotate) ? (string)parameters[CommonDeploymentActionParameters.SecretTypesToRotate] : null;
                SecretRotationMetadata.Types secretTypesToRotate;

                if (!Enum.TryParse(secretTypesToRotateString, out secretTypesToRotate) || secretTypesToRotate == SecretRotationMetadata.Types.None)
                {
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, secretTypesToRotateString, CommonDeploymentActionParameters.SecretTypesToRotate);
                }

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.RotateSecrets;

                // disable for now the AADCertificateRotation until we have closure from dependent teams
                if (secretTypesToRotate != SecretRotationMetadata.Types.None &&
                    secretTypesToRotate.HasFlagAny(SecretRotationMetadata.Types.AADCertificate))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removing credential rotation flags (not yet supported) [{0}] for topology [{1}].", secretTypesToRotate.ToString(), topologyInstanceId);

                    secretTypesToRotate = secretTypesToRotate.ClearFlags(SecretRotationMetadata.Types.AADCertificate);
                    if (secretTypesToRotate == SecretRotationMetadata.Types.None)
                    {
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, secretTypesToRotate.ToString(), CommonDeploymentActionParameters.SecretTypesToRotate);
                    }

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "New credential rotation flags [{0}] for topology [{1}].", secretTypesToRotate.ToString(), topologyInstanceId);
                }

                DeploymentState deploymentState = DeploymentState.RotatingSecrets;

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;

                // rotating secrets not supported for Staging
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                // RSAT cert rotation is allowed for Sandbox topologies only. This can be removed later when RSAT cert gets a unique subject name.
                if (secretTypesToRotate.HasFlagAny(SecretRotationMetadata.Types.RSATCertificate) && !topologyInstance.IsSandboxTopology())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Secret Rotation [{0}] not supported for topology [{1}] SkuType [{2}].", secretTypesToRotate.ToString(), topologyInstanceId, topologyInstance.OfferSKUType);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_UnsupportedEnvironmentType);
                }

                if (secretTypesToRotate.HasFlagAny(SecretRotationMetadata.Types.SQLPasswords) && !topologyInstance.IsSandboxOrProdTopology())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Secret Rotation [{0}] not supported for topology [{1}] SkuType [{2}].", secretTypesToRotate.ToString(), topologyInstanceId, topologyInstance.OfferSKUType);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_UnsupportedEnvironmentType);
                }

                // TopologySync Actions is blocked when last servicing/data movement operation is in failed state.
                if (IsResumeSupportedOperationInFailedState(topologyInstance, deploymentInstance, action, out errorMessage))
                {
                    return errorMessage;
                }

                // secret rotation is blocked for environments that have been migrated to SF.
                if (deploymentInstance.DeploymentState == DeploymentState.MigratedToSF)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but the environment has been Migrated to SF.", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_EnvironmentMigratedToSF, action);
                }

                if (!this.CanRotateSecrets(deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }

                if (!string.Equals(topologyInstance.ProductName, DeploymentConstants.AX7ProductName, StringComparison.OrdinalIgnoreCase) &&
                    !string.Equals(topologyInstance.ProductName, DeploymentConstants.RetailProductName, StringComparison.OrdinalIgnoreCase))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceEngine, "Secrets rotation is not supported for product name [{0}].", topologyInstance.ProductName);
                    return this.CreateErrorResponse(ServiceErrorCode.ProductNotSupportedForCurrentOperation, DeploymentRequest.DeploymentAction.RotateSecrets, topologyInstance.ProductName, topologyInstanceId);
                }

                // if there's a staging environment, prevent secret rotation until it's disposed.
                TopologyInstance stagingTopologyInstance;
                TopologyInstanceTableItem stagingTopologyInstanceRow;
                if (this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Staging, out stagingTopologyInstance, out errorMessage, out stagingTopologyInstanceRow))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but a staging deployment exists in state [{2}].", action, topologyInstance, stagingTopologyInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_StagingDeploymentExists, topologyInstanceId);
                }

                if (!this.ProcessRotateSecretsParameters(topologyInstance, secretTypesToRotate, out errorMessage))
                {
                    return errorMessage;
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance, includeVMInstances: true);
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SecretTypesToRotate, secretTypesToRotate.ToString());

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out errorMessage, deploymentState))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to rotate secrets for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to rotate secrets for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Method is used to verify if the process of rotating secrets is allowed for the specified environment.
        /// </summary>
        /// <param name="deploymentState">Environment deployment state.</param>
        /// <param name="deploymentStatus">Environment deployment status.</param>
        /// <returns>Flag which represents whether the rotate secrets process is allowed for the specified environment.</returns>
        private bool CanRotateSecrets(DeploymentState deploymentState, Model.DeploymentStatus deploymentStatus)
        {
            // Rotate secrets operation is allowed for environments with "Finished" state.
            if (deploymentState == DeploymentState.Finished)
            {
                return true;
            }

            // If deployment state is not "Finished" as expected, it is also allowed to run for environments with latest operation failed.
            // These ones have "Incomplete" deployment status.
            if (deploymentStatus == Model.DeploymentStatus.StateTransitionIncomplete)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Method is used to verify if the process of deleteing BI Virtual Machine is allowed for the specified environment.
        /// </summary>
        /// <param name="deploymentState">Environment deployment state.</param>
        /// <param name="deploymentStatus">Environment deployment status.</param>
        /// <returns>Flag which represents whether the deleteing BI Virtual Machine process is allowed for the specified environment.</returns>
        private bool CanDeleteBIVM(DeploymentState deploymentState, Model.DeploymentStatus deploymentStatus)
        {
            // deleteing BI Virtual Machine operation is allowed for environments with "Finished" state.
            if (deploymentState == DeploymentState.Finished && deploymentStatus == Model.DeploymentStatus.Succeeded)
            {
                return true;
            }

            // If deployment state is not "Finished" as expected, it is also allowed to run for environments with latest operation failed.
            // These ones have "Incomplete" deployment status.
            if (deploymentState == DeploymentState.ExecutingGenevaAction && deploymentStatus == Model.DeploymentStatus.StateTransitionIncomplete)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Action used to upload a certificate to KeyVault which will be updated in future.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage UpdateCertificate(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Uploading secret for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.UpdateCertificate;

                // rotating secrets not supported for Staging
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (!this.CanRotateSecrets(deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState);
                }

                if (!string.Equals(topologyInstance.ProductName, DeploymentConstants.AX7ProductName, StringComparison.OrdinalIgnoreCase) &&
                    !string.Equals(topologyInstance.ProductName, DeploymentConstants.RetailProductName, StringComparison.OrdinalIgnoreCase))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceEngine, "Secrets rotation is not supported for product name [{0}].", topologyInstance.ProductName);
                    return this.CreateErrorResponse(ServiceErrorCode.ProductNotSupportedForCurrentOperation, DeploymentRequest.DeploymentAction.RotateSecrets, topologyInstance.ProductName, topologyInstanceId);
                }

                TopologyInstance stagingTopologyInstance;
                TopologyInstanceTableItem stagingTopologyInstanceRow;
                if (this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Staging, out stagingTopologyInstance, out errorMessage, out stagingTopologyInstanceRow))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to upload secret to topology [{1}] but a staging deployment exists in state [{2}].", topologyInstance, stagingTopologyInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_StagingDeploymentExists, topologyInstanceId);
                }

                string certificateValue = parameters.ContainsKey(CommonDeploymentActionParameters.CertificateValue) ? (string)parameters[CommonDeploymentActionParameters.CertificateValue] : null;
                string certificateType = parameters.ContainsKey(CommonDeploymentActionParameters.CertificateType) ? (string)parameters[CommonDeploymentActionParameters.CertificateType] : null;

                if (certificateValue == null || certificateType == null)
                {
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue);
                }

                certificateValue = JsonConvert.DeserializeObject(certificateValue).ToString();
                certificateType = JsonConvert.DeserializeObject(certificateType).ToString();

                CertificateDefinition certificateDefinition = topologyInstance.Certificates.Where((cert) => { return cert.Identifier.Equals(certificateType, StringComparison.CurrentCultureIgnoreCase); }).FirstOrDefault();
                string certificateSecretName = certificateDefinition.KeyVaultableRawData.SecretUri;
                string passwordSecretName = certificateDefinition.KeyVaultablePassword?.SecretUri;
                KeyVaultClient client = new KeyVaultClient(KeyVaultClient.AuthenticationMode.Application);

                client.SetSecret(certificateSecretName, certificateValue);
                if (!String.IsNullOrWhiteSpace(passwordSecretName))
                {
                    client.SetSecret(passwordSecretName, String.Empty);
                }

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to upload secret for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to upload secret for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to restart services for an environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage RestartService(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Restarting Service for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.RestartService;

                string servicesToRestartString = parameters.ContainsKey(CommonDeploymentActionParameters.ServiceToRestart) ? (string)parameters[CommonDeploymentActionParameters.ServiceToRestart] : null;
                RestartServiceMetadata.AXService serviceToRestart;

                if (!Enum.TryParse(servicesToRestartString, out serviceToRestart) || serviceToRestart == RestartServiceMetadata.AXService.None)
                {
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, servicesToRestartString, CommonDeploymentActionParameters.ServiceToRestart);
                }

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Restarting the '{0}' service for topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'.",
                    serviceToRestart,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                string virtualMachineToRestartString = parameters.ContainsKey(CommonDeploymentActionParameters.VMToRestart) ? (string)parameters[CommonDeploymentActionParameters.VMToRestart] : null;

                DeploymentState deploymentState = DeploymentState.RestartingServices;

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                // Restart service is blocked when the environment is in a swapped or transitioning state.
                if (deploymentInstance.DeploymentState == DeploymentState.Swapped || topologyInstance.HasCustomizationValue(CommonCustomizationNames.IsSwapped, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment is currently Swapped.", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNotSwapped, action);
                }
                else if (topologyInstance.HasCustomizationValue(CommonCustomizationNames.RollbackInProgress, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment did not complete Rollback. Please rollback or commit the swap to enable the action [{0}].", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNotRollback, action);
                }
                else if (deploymentInstance.DeploymentState != DeploymentState.Finished &&
                         deploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but the primary deployment is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }

                if (!this.ProcessRestartParameters(topologyInstance, serviceToRestart, out errorMessage))
                {
                    return errorMessage;
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance);
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.ServiceToRestart, serviceToRestart.ToString());
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.VMToRestart, virtualMachineToRestartString);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out errorMessage, deploymentState))
                {
                    return errorMessage;
                }
                else
                {
                    Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Restarting the '{0}' service for topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}' has been scheduled.",
                    serviceToRestart,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to restart service for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to restart service for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to get secret rotation metadata for an environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage GetSecretRotationMetadata(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                string activityId = parameters.ContainsKey(LastRotationActivityId) ? (string)parameters[LastRotationActivityId] : null;

                TopologyInstance entity;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out entity, out error, out topologyInstanceRow))
                {
                    return error;
                }

                IEnumerable<SecretRotationMetadata> secretMetadata = entity.SecretRotationsMetadata
                    .Where(m => string.IsNullOrWhiteSpace(activityId) || string.Equals(m.LastActivityId.ToString(), activityId, StringComparison.OrdinalIgnoreCase));

                return Request.CreateResponse(HttpStatusCode.OK, secretMetadata);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to fetch secret metadata for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to fetch secret metadata for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to get restart service metadata for an environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage GetRestartServiceMetadata(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                string activityId = parameters.ContainsKey(LastRestartServiceActivityId) ? (string)parameters[LastRestartServiceActivityId] : null;

                TopologyInstance entity;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out entity, out error, out topologyInstanceRow))
                {
                    return error;
                }

                IEnumerable<RestartServiceMetadata> restartServiceMetadata = entity.RestartServiceMetadata
                    .Where(m => string.IsNullOrWhiteSpace(activityId) || string.Equals(m.LastActivityId.ToString(), activityId, StringComparison.OrdinalIgnoreCase));

                return Request.CreateResponse(HttpStatusCode.OK, restartServiceMetadata);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to fetch restart service metadata for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to fetch restart service for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to get Geneva action status for an environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        public HttpResponseMessage GetGenevaActionMetadata(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                int revision = this.GetRevisionParameter(parameters);
                if (revision < 0)
                {
                    Tracer.WriteErrorEvent(
                        TraceComponent.DeploymentServiceApi,
                        null, // exception
                        "Failed to fetch Geneva action metadata for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. Invalid '{3}'.",
                        topologyInstanceId,
                        azureSubscriptionId,
                        tenantId,
                        ServiceConstants.RevisionParameter);

                    return this.CreateErrorResponse(
                        ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                        ServiceConstants.GetGenevaActionMetadataActionName,
                        revision,
                        ServiceConstants.RevisionParameter);
                }

                TopologyInstanceTableItem topologyInstanceRow = GetTopologyTableItem(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup);

                DeploymentInstance deploymentInstance;
                HttpResponseMessage error;
                if (!this.GetDeploymentInstance(topologyInstanceRow, out deploymentInstance, out error, true, revision))
                {
                    return error;
                }

                return this.Request.CreateResponse(HttpStatusCode.OK, deploymentInstance.ExecuteGenevaActionMetadata);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to fetch Geneva action metadata for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to fetch Geneva action metadata for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to list all the Active SQL Processes.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Needs to be robust.")]
        public HttpResponseMessage ListSQLProcess(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "List SQL Process for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentState deploymentState = DeploymentState.ExecutingSQLCommand;

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ExecuteSQLCommand;

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage message;
                TopologyInstanceTableItem topologyInstanceRow;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out message, out topologyInstanceRow))
                {
                    return message;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out message))
                {
                    return message;
                }

                if (deploymentInstance.DeploymentState != DeploymentState.Finished &&
                    deploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }

                if (!string.Equals(topologyInstance.DeploymentItems.GetFirst(CommonCustomizationNames.AXDbDeploymentItemName).ItemType, DeploymentItemType.AzureSQLDatabase.ToString(), StringComparison.OrdinalIgnoreCase))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] on topology [{1}] but the environment is running on a DevTest or Demo.", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.UnableToRunSQLOnDevTestOrDemoTopology, topologyInstanceId);
                }

                if (topologyInstance.DeploymentItems.GetFirst(CommonCustomizationNames.AXDbDeploymentItemName).IsElasticPoolEnabled())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] on topology [{1}] but the environment is running on an Elastic SQL Pool.", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNonElasticPoolServer, topologyInstanceId);
                }

                // We are only worried about the AX DB databases in Azure.
                DeploymentItem azureSQLDatabaseItem = topologyInstance.DeploymentItems.GetFirst(CommonCustomizationNames.AXDbDeploymentItemName);
                DeploymentItem azureSQLServerItem = topologyInstance.DeploymentItems.GetFirst(azureSQLDatabaseItem.ParentItemName);

                ARMOperationData operationData = new ARMOperationData(
                    tenantRegistration.ActiveDirectorySubscriptionTenantID,
                    tenantRegistration.AzureSubscriptionId.ToString(),
                    topologyInstance.GetResourceGroup(azureSQLServerItem),
                    topologyInstance.InstanceId);

                string serverLoginName;
                string serverPassword;
                azureSQLServerItem.GetAzureSQLServerItemCredentials(out serverLoginName, out serverPassword);

                AzureSQLDatabaseInfo databaseInfo;
                if (!azureSQLDatabaseItem.TryGetAzureSqlDatabaseConnectionInfo(azureSQLServerItem, out databaseInfo))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Failed to get database connection info for [{0}].", azureSQLDatabaseItem);
                    return this.CreateErrorResponse(ServiceErrorCode.UnableToRetrieveSQLConnectionInformation, topologyInstanceId);
                }

                DatabaseOperations databaseOps = new DatabaseOperations(databaseInfo.FullyQualifiedDomainName, databaseInfo.DatabaseName, serverLoginName, serverPassword);

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance);

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (!this.TryUploadDeploymentInstanceBlob(request, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out message, deploymentState))
                {
                    return message;
                }

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Attempting to List the Blocking SQL calls on topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                List<SQLProcess> sqlProcess;
                var deploymentAPIType = AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceType.API;

                try
                {
                    AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceARMFirewallOperation(operationData, azureSQLServerItem, deploymentAPIType, true);
                    IEnumerable<DatabaseOperations.SqlProcessExecution> sqlProcessExecutions = databaseOps.ListSQLSessions();
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Listing Blocking SQL call on topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}' was successful",
                        topologyInstanceId,
                        azureSubscriptionId,
                        tenantId);

                    sqlProcess = sqlProcessExecutions.Select(process => new SQLProcess()
                    {
                        SessionProcessID = process.SessionProcessID,
                        ParentSessionProcessId = process.ParentSessionProcessId,
                        ProgramName = process.ProgramName,
                        HostName = process.HostName,
                        Hierarchy = process.Hierarchy,
                        WaitTime = process.WaitTime,
                        WaitResource = process.WaitResource,
                        SQLText = process.SQLText,
                        DurationInMilliSeconds = process.DurationInMilliSeconds
                    }).ToList();
                }
                catch (Exception e)
                {
                    Tracer.WriteErrorEvent(
                        TraceComponent.DeploymentServiceApi,
                        e,
                        "Listing Blocking SQL call on topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}' failed.",
                        topologyInstanceId,
                        azureSubscriptionId,
                        tenantId);

                    request.Deployment.DeploymentErrors = new List<DeploymentError>() { new DeploymentError(ServiceErrorCode.UnableToRunSQLOperation) };
                    return this.CreateErrorResponse(ServiceErrorCode.UnableToRunSQLOperation, topologyInstanceId);
                }
                finally
                {
                    // Set the status to Succeeded regardless if failed as this does not affect topology state.
                    this.UpdateTopologyAndDeploymentInstance(
                        tenantId,
                        azureSubscriptionId,
                        topologyInstanceId,
                        environmentGroup,
                        (cloudDeploymentInstance) =>
                        {
                            cloudDeploymentInstance.DeploymentState = DeploymentState.Finished;
                            cloudDeploymentInstance.DeploymentStatus = Model.DeploymentStatus.Succeeded;

                            cloudDeploymentInstance.DeploymentErrors = request.Deployment.DeploymentErrors;
                            cloudDeploymentInstance.DeploymentWarnings = request.Deployment.DeploymentWarnings;
                        },
                        (cloudTopologyInstance) =>
                        {
                            cloudTopologyInstance.DeploymentState = DeploymentState.Finished;
                            cloudTopologyInstance.DeploymentStatus = Model.DeploymentStatus.Succeeded;
                        },
                        out message);

                    // Make sure to remove the firewall setting
                    AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceARMFirewallOperation(operationData, azureSQLServerItem, deploymentAPIType, false);
                }

                return Request.CreateResponse(HttpStatusCode.OK, sqlProcess);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to list the blocking SQL calls for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to terminate the Active SQL Processes.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Needs to be robust.")]
        public HttpResponseMessage TerminateSQLProcess(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Terminating SQL Process for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentState deploymentState = DeploymentState.ExecutingSQLCommand;

                int processID = parameters.ContainsKey(CommonDeploymentActionParameters.SQLProcessID) ? (int)parameters[CommonDeploymentActionParameters.SQLProcessID] : 0;
                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ExecuteSQLCommand;

                if (processID <= 0)
                {
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, processID, CommonDeploymentActionParameters.SQLProcessID);
                }

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage message;
                TopologyInstanceTableItem topologyInstanceRow;

                // Terminating SQL Processes is not supported for Staging
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out message, out topologyInstanceRow))
                {
                    return message;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out message))
                {
                    return message;
                }

                if (deploymentInstance.DeploymentState != DeploymentState.Finished &&
                    deploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }

                if (!string.Equals(topologyInstance.DeploymentItems.GetFirst(CommonCustomizationNames.AXDbDeploymentItemName).ItemType, DeploymentItemType.AzureSQLDatabase.ToString(), StringComparison.OrdinalIgnoreCase))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] on topology [{1}] but the environment is running on a DevTest or Demo.", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.UnableToRunSQLOnDevTestOrDemoTopology, topologyInstanceId);
                }

                if (topologyInstance.DeploymentItems.GetFirst(CommonCustomizationNames.AXDbDeploymentItemName).IsElasticPoolEnabled())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] on topology [{1}] but the environment is running on an Elastic SQL Pool.", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNonElasticPoolServer, topologyInstanceId);
                }

                // We are only worried about the AX DB databases in Azure.
                DeploymentItem azureSQLDatabaseItem = topologyInstance.DeploymentItems.GetFirst(CommonCustomizationNames.AXDbDeploymentItemName);
                DeploymentItem azureSQLServerItem = topologyInstance.DeploymentItems.GetFirst(azureSQLDatabaseItem.ParentItemName);

                ARMOperationData operationData = new ARMOperationData(
                    tenantRegistration.ActiveDirectorySubscriptionTenantID,
                    tenantRegistration.AzureSubscriptionId.ToString(),
                    topologyInstance.GetResourceGroup(azureSQLServerItem),
                    topologyInstance.InstanceId);

                string serverLoginName;
                string serverPassword;
                azureSQLServerItem.GetAzureSQLServerItemCredentials(out serverLoginName, out serverPassword);

                AzureSQLDatabaseInfo databaseInfo;
                if (!azureSQLDatabaseItem.TryGetAzureSqlDatabaseConnectionInfo(azureSQLServerItem, out databaseInfo))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Failed to get database connection info for [{0}].", azureSQLDatabaseItem);
                    return this.CreateErrorResponse(ServiceErrorCode.UnableToRetrieveSQLConnectionInformation, topologyInstanceId);
                }

                DatabaseOperations databaseOps = new DatabaseOperations(databaseInfo.FullyQualifiedDomainName, databaseInfo.DatabaseName, serverLoginName, serverPassword);

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance);

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (!this.TryUploadDeploymentInstanceBlob(request, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out message, deploymentState))
                {
                    return message;
                }

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Attempting to Terminate the Blocking SQL call with Process ID '{0}' on topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'.",
                    processID,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                var deploymentAPIType = AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceType.API;

                try
                {
                    AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceARMFirewallOperation(operationData, azureSQLServerItem, deploymentAPIType, true);
                    string result = databaseOps.TerminateSQLSession(processID);
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Terminating the Blocking SQL call with Process ID '{0}' on topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'. Return the following message [{4}]",
                        processID,
                        topologyInstanceId,
                        azureSubscriptionId,
                        tenantId,
                        result);
                }
                catch (Exception e)
                {
                    Tracer.WriteErrorEvent(
                        TraceComponent.DeploymentServiceApi,
                        e,
                        "Unable to Terminate the Blocking SQL call with Process ID '{0}' on topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'.",
                        processID,
                        topologyInstanceId,
                        azureSubscriptionId,
                        tenantId);

                    request.Deployment.DeploymentErrors = new List<DeploymentError>() { new DeploymentError(ServiceErrorCode.UnableToRunSQLOperation) };
                    return this.CreateErrorResponse(ServiceErrorCode.UnableToRunSQLOperation, topologyInstanceId);
                }
                finally
                {
                    // Set the status to Succeeded regardless if failed as this does not affect topology state.
                    this.UpdateTopologyAndDeploymentInstance(
                        tenantId,
                        azureSubscriptionId,
                        topologyInstanceId,
                        EnvironmentGroup.Primary,
                        (cloudDeploymentInstance) =>
                        {
                            cloudDeploymentInstance.DeploymentState = DeploymentState.Finished;
                            cloudDeploymentInstance.DeploymentStatus = Model.DeploymentStatus.Succeeded;

                            cloudDeploymentInstance.DeploymentErrors = request.Deployment.DeploymentErrors;
                            cloudDeploymentInstance.DeploymentWarnings = request.Deployment.DeploymentWarnings;
                        },
                        (cloudTopologyInstance) =>
                        {
                            cloudTopologyInstance.DeploymentState = DeploymentState.Finished;
                            cloudTopologyInstance.DeploymentStatus = Model.DeploymentStatus.Succeeded;
                        },
                        out message);

                    // Make sure to remove the firewall setting
                    AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceARMFirewallOperation(operationData, azureSQLServerItem, deploymentAPIType, false);
                }

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to initiate the Terminate SQL Process ID for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to initiate the Terminate SQL Process ID for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to execute SQL Queries against an environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage InvokeFastSQLAction(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            return this.InvokeFastSQLHelper(tenantId, azureSubscriptionId, topologyInstanceId, parameters, 1);
        }

        /// <summary>
        /// Action used to execute SQL Queries against an environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage InvokeFastSQLActionV2(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            return this.InvokeFastSQLHelper(tenantId, azureSubscriptionId, topologyInstanceId, parameters, 2);
        }

        /// <summary>
        /// Action, used to register the trusted AAD applications in environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.RetailApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage RegisterAadApplicationsInAxDb(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            IEnumerable<AadApplicationRegisterParameter> aadApplicationsList = null;
            aadApplicationsList = this.GetParameterOrDefault<IEnumerable<AadApplicationRegisterParameter>>(parameters, CommonDeploymentActionParameters.AadApplicationRegisterParameters, null);

            if (aadApplicationsList == null)
            {
                return this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    ServiceConstants.RegisterAadApplicationsInAxDbActionName,
                    aadApplicationsList,
                    CommonDeploymentActionParameters.AadApplicationRegisterParameters);
            }

            string aadApplicationsJsonList = JsonConvert.SerializeObject(aadApplicationsList);

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                "Performing the registering of the AAD application(s) {0} in AxDB for topology instance '{1}' in Azure subscription '{2}' of tenant '{3}' using the '{4}' API.",
                aadApplicationsJsonList,
                topologyInstanceId,
                azureSubscriptionId,
                tenantId,
                ServiceConstants.RegisterAadApplicationsInAxDbActionName);

            List<SQLActionParameter> sqlActionParameters = new List<SQLActionParameter>
            {
                new SQLActionParameter
                {
                    SQLParameterName = "@aadAppsJsonList",
                    DotNetType = typeof(System.String).FullName,
                    Name = "AadAppsJsonList",
                    Value = aadApplicationsJsonList
                }
            };

            ODataActionParameters fastSqlActionParameters = new ODataActionParameters();
            fastSqlActionParameters.Add("DatabaseDeploymentItemName", "AxDB");
            fastSqlActionParameters.Add("SQLQueryName", "Register-AadApplications");
            fastSqlActionParameters.Add("SQLQueryParameters", sqlActionParameters);

            HttpResponseMessage responseMessage = this.InvokeFastSQLHelper(tenantId, azureSubscriptionId, topologyInstanceId, fastSqlActionParameters, 2);

            string sucessMessage = responseMessage.IsSuccessStatusCode ? "completed sucessfully" : "failed";

            Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "The registering of the AAD application(s) {0} in AxDB is {1} for topology instance '{2}' in Azure subscription '{3}' of tenant '{4}' using the '{5}' API.",
                    aadApplicationsJsonList,
                    sucessMessage,
                    azureSubscriptionId,
                    topologyInstanceId,
                    tenantId,
                    ServiceConstants.RegisterAadApplicationsInAxDbActionName);

            return responseMessage;
        }

        /// <summary>
        /// Action, used to unregister the trusted AAD applications in environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.RetailApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage UnregisterAadApplicationsInAxDb(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            IEnumerable<AadApplicationUnregisterParameter> aadApplicationsList = null;
            aadApplicationsList = this.GetParameterOrDefault<IEnumerable<AadApplicationUnregisterParameter>>(parameters, CommonDeploymentActionParameters.AadApplicationUnregisterParameters, null);

            if (aadApplicationsList == null)
            {
                return this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    ServiceConstants.UnregisterAadApplicationsInAxDbActionName,
                    aadApplicationsList,
                    CommonDeploymentActionParameters.AadApplicationUnregisterParameters);
            }

            string aadApplicationsJsonList = JsonConvert.SerializeObject(aadApplicationsList);

            Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Performing the unregistering of the AAD application(s) {0} in AxDB for topology instance '{1}' in Azure subscription '{2}' of tenant '{3}' using the '{4}' API.",
                    aadApplicationsJsonList,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    ServiceConstants.RegisterAadApplicationsInAxDbActionName);

            List<SQLActionParameter> sqlActionParameters = new List<SQLActionParameter>
            {
                new SQLActionParameter
                {
                    SQLParameterName = "@aadAppsJsonList",
                    DotNetType = typeof(System.String).FullName,
                    Name = "AadAppsJsonList",
                    Value = aadApplicationsJsonList
                }
            };

            ODataActionParameters fastSqlActionParameters = new ODataActionParameters();
            fastSqlActionParameters.Add("DatabaseDeploymentItemName", "AxDB");
            fastSqlActionParameters.Add("SQLQueryName", "Unregister-AadApplications");
            fastSqlActionParameters.Add("SQLQueryParameters", sqlActionParameters);

            HttpResponseMessage responseMessage = this.InvokeFastSQLHelper(tenantId, azureSubscriptionId, topologyInstanceId, fastSqlActionParameters, 2);

            string sucessMessage = responseMessage.IsSuccessStatusCode ? "completed sucessfully" : "failed";

            Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "The unregistering of the AAD application(s) {0} in AxDB is {1} for topology instance '{2}' in Azure subscription '{3}' of tenant '{4}' using the '{5}' API.",
                    aadApplicationsJsonList,
                    sucessMessage,
                    azureSubscriptionId,
                    topologyInstanceId,
                    tenantId,
                    ServiceConstants.RegisterAadApplicationsInAxDbActionName);

            return responseMessage;
        }

        /// <summary>
        /// Action used to create JIT account on all VMs in the topology.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ElasticPoolMigrationService,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage CreateJITAccount(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Creating JIT account for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Model.OperationState operationState = Model.OperationState.CreatingJITAccount;
                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.CreateJITAccount;

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                string accountName = parameters.ContainsKey(CommonDeploymentActionParameters.AccountName) ? (string)parameters[CommonDeploymentActionParameters.AccountName] : null;

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;
                OperationsInstance operationsInstance;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.ProcessCreateJITAccountParameters(topologyInstance, accountName, out errorMessage))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (!this.CreateOrGetOperationsInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out operationsInstance, out errorMessage))
                {
                    return errorMessage;
                }

                if (!deploymentInstance.DeploymentState.IsAccessible() &&
                    deploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, action);
                }

                if (operationsInstance.OperationState != Model.OperationState.Undefined &&
                    operationsInstance.OperationState != Model.OperationState.Finished &&
                    operationsInstance.OperationStatus != Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, action);
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                operationsInstance.OperationActionParameters.Clear();
                operationsInstance.OperationActionParameters.Add(CommonDeploymentActionParameters.AccountName, accountName);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, operationsInstance, action);

                // If this is a Staging Environment, and is Swapped, then block JIT access.
                if (environmentGroup == EnvironmentGroup.Staging && deploymentInstance.DeploymentState == DeploymentState.Swapped)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] EnvironmentGroup [{2}] but it is currently in state [{3}].", action, topologyInstance, environmentGroup, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNotSwapped, action);
                }

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                if (!this.TryUploadBlobAndOperationsScheduleTask(request, topologyInstanceRow, DeploymentOperationMasterWorkflow.TaskNameConstant, out errorMessage, operationState))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to create JIT account for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to create JIT account for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to retrieve network security group (of only customer rules) of an instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetNetworkSecurityGroup(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

                TopologyInstance entity;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out entity, out error, out topologyInstanceRow))
                {
                    return error;
                }

                Library.Model.NetworkSecurityGroup nsgWithCustomerRules = null;
                if (entity.ShouldUseAzureResourceManager())
                {
                    using (var manager = tenantRegistration.CreateAzureResourceManager(entity.ARM.ResourceGroupName))
                    {
                        if (!this.TryGetCustomerNSGRulesFromAzureARM(manager, entity, out nsgWithCustomerRules, out error))
                        {
                            return error;
                        }
                    }
                }
                else
                {
                    IServiceManagement management = tenantRegistration.CreateAzureServiceManagement();
                    DeploymentRequest request = new DeploymentRequest(tenantRegistration, entity, deploymentInstance: null, action: DeploymentRequest.DeploymentAction.Undefined);

                    if (!this.TryGetCustomerNSGRulesFromAzureRDFE(management, request, out nsgWithCustomerRules, out error))
                    {
                        return error;
                    }
                }

                if (nsgWithCustomerRules != null)
                {
                    foreach (Library.Model.NetworkSecurityGroup.Rule rule in nsgWithCustomerRules.Rules)
                    {
                        if (rule.DestinationAddressPrefixes == null)
                        {
                            rule.DestinationAddressPrefixes = new List<string>();
                        }

                        if (rule.DestinationPortRanges == null)
                        {
                            rule.DestinationPortRanges = new List<string>();
                        }

                        if (rule.SourceAddressPrefixes == null)
                        {
                            rule.SourceAddressPrefixes = new List<string>();
                        }

                        if (rule.SourcePortRanges == null)
                        {
                            rule.SourcePortRanges = new List<string>();
                        }
                    }
                }

                return this.Request.CreateResponse(HttpStatusCode.OK, nsgWithCustomerRules);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to retrieve network security group in client model form (of only customer rules) of an instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetNetworkSecurityGroupClientModel(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                bool shouldGetSQLFirewallRules = this.GetParameterOrDefault(parameters, "IncludeSQLRules", false);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                TopologyInstance entity;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out entity, out error, out topologyInstanceRow))
                {
                    return error;
                }

                Library.Model.NetworkSecurityGroup nsgWithCustomerRules;

                if (entity.ShouldUseAzureResourceManager())
                {
                    using (var manager = tenantRegistration.CreateAzureResourceManager(entity.ARM.ResourceGroupName))
                    {
                        if (!this.TryGetCustomerNSGRulesFromAzureARM(manager, entity, out nsgWithCustomerRules, out error))
                        {
                            return error;
                        }
                    }
                }
                else
                {
                    IServiceManagement management = tenantRegistration.CreateAzureServiceManagement();
                    DeploymentRequest request = new DeploymentRequest(tenantRegistration, entity, deploymentInstance: null, action: DeploymentRequest.DeploymentAction.Undefined);

                    nsgWithCustomerRules = null;
                    if (!this.TryGetCustomerNSGRulesFromAzureRDFE(management, request, out nsgWithCustomerRules, out error))
                    {
                        return error;
                    }
                }

                // nsgWithCustomerRules has the "CUSTOMER_" prefix
                Library.Model.NetworkSecurityGroupClientModel clientNsgWithCustomerRules = new NetworkSecurityGroupClientModel();
                clientNsgWithCustomerRules.Name = nsgWithCustomerRules.Name;

                // Convert to client model
                foreach (Library.Model.NetworkSecurityGroup.Rule dsuRule in nsgWithCustomerRules.Rules)
                {
                    NetworkSecurityGroupClientModel.ClientRule clientRule = new NetworkSecurityGroupClientModel.ClientRule()
                    {
                        Name = dsuRule.Name.StartsWith(Library.Model.NetworkSecurityGroup.CustomerRulePrefix, StringComparison.OrdinalIgnoreCase)
                            ? dsuRule.Name.Substring(Library.Model.NetworkSecurityGroup.CustomerRulePrefix.Length)
                            : dsuRule.Name,
                        Service = CommonHelper.MapPortToService(dsuRule.DestinationPortRange),
                        IsCustomerRule = dsuRule.IsCustomerRule
                    };

                    if (dsuRule.SourceAddressPrefixes != null && dsuRule.SourceAddressPrefixes.Any())
                    {
                        clientRule.IpOrCidr = string.Join(",", dsuRule.SourceAddressPrefixes);
                    }
                    else
                    {
                        clientRule.IpOrCidr = dsuRule.SourceAddressPrefix;
                    }

                    if (NetworkSecurityGroupExtensions.HasSplitRuleSuffix(clientRule.Name))
                    {
                        string splitSuffixRemoved = NetworkSecurityGroupExtensions.RemoveSplitRuleSuffix(clientRule.Name);

                        bool foundCorrespondingRule = false;

                        foreach (Library.Model.NetworkSecurityGroupClientModel.ClientRule rule in clientNsgWithCustomerRules.Rules)
                        {
                            if (splitSuffixRemoved.Equals(rule.Name) && clientRule.Service.Equals(rule.Service) && clientRule.IpOrCidr.Equals(rule.IpOrCidr))
                            {
                                foundCorrespondingRule = true;
                                continue;
                            }
                        }

                        // remove the split rule suffix before adding it
                        if (!foundCorrespondingRule)
                        {
                            clientRule.Name = splitSuffixRemoved;
                        }
                        else
                        {
                            continue;
                        }
                    }

                    clientNsgWithCustomerRules.Rules.Add(clientRule);
                }

                if (shouldGetSQLFirewallRules)
                {
                    List<AzureSQLFireWall> sqlFirewallRules = null;

                    if (!this.TryGetSQLDbFirewallRules(entity, out sqlFirewallRules, out error, tenantId, azureSubscriptionId, dbItemName: string.Empty))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Failed to find customer SQL firewall rules.");
                    }

                    IEnumerable<AzureSQLFireWall> customerSqlFirewallRules = sqlFirewallRules.Where(r => r.Name.StartsWith(Library.Model.NetworkSecurityGroup.CustomerRulePrefix, StringComparison.OrdinalIgnoreCase));
                    foreach (AzureSQLFireWall firewallRule in customerSqlFirewallRules)
                    {
                        // Convert to client model and add to the NSG to be returned
                        NetworkSecurityGroupClientModel.ClientRule clientRule = new NetworkSecurityGroupClientModel.ClientRule()
                        {
                            Name = firewallRule.Name.StartsWith(Library.Model.NetworkSecurityGroup.CustomerRulePrefix, StringComparison.OrdinalIgnoreCase)
                                ? firewallRule.Name.Substring(Library.Model.NetworkSecurityGroup.CustomerRulePrefix.Length)
                                : firewallRule.Name,
                            IpOrCidr = string.Equals(firewallRule.StartIPAddress, firewallRule.EndIPAddress, StringComparison.OrdinalIgnoreCase)
                                ? firewallRule.StartIPAddress
                                : CommonHelper.IpRangeToCidr(firewallRule.StartIPAddress, firewallRule.EndIPAddress),
                            Service = EnvironmentNetworkSecurityRuleService.AzureSQL.ToString(),
                            IsCustomerRule = true
                        };

                        clientNsgWithCustomerRules.Rules.Add(clientRule);
                    }
                }

                return this.Request.CreateResponse(HttpStatusCode.OK, clientNsgWithCustomerRules);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to update the network security group of an instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage UpdateNetworkSecurityGroup(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                Library.Model.NetworkSecurityGroup nsgWithCustomerRules = parameters.ContainsKey(NetworkSecurityGroupParameter)
                    ? (Library.Model.NetworkSecurityGroup)parameters[NetworkSecurityGroupParameter]
                    : null;

                if (nsgWithCustomerRules == null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Failed to fetch parameter [{0}] from call parameters.", NetworkSecurityGroupParameter);
                    return this.CreateErrorResponse(ServiceErrorCode.NetworkSecurityGroup_MissingNSGParameter, NetworkSecurityGroupParameter);
                }

                TopologyInstance topologyInstance;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out error, out topologyInstanceRow))
                {
                    return error;
                }

                if (!this.TryValidateUpdateNSGParameter(nsgWithCustomerRules, out error))
                {
                    return error;
                }

                if (topologyInstance.ShouldUseAzureResourceManager())
                {
                    using (var manager = tenantRegistration.CreateAzureResourceManager(topologyInstance.ARM.ResourceGroupName))
                    {
                        if (!this.TryUpdateCustomerARMNSGSecurityRules(manager, topologyInstance, nsgWithCustomerRules, out error))
                        {
                            return error;
                        }
                    }
                }
                else
                {
                    topologyInstance.NetworkSecurityGroup = nsgWithCustomerRules;
                    MigrationLibrary.MigrateTopology(topologyInstance);

                    var deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                    deploymentInstance.Initialize(topologyInstance);

                    DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, DeploymentRequest.DeploymentAction.UpdateNetworkSecurityGroup);

                    if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out error))
                    {
                        return error;
                    }
                }

                return this.Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to update the network security group of an instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage UpdateNetworkSecurityGroupClientModel(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                bool shouldUpdateSQLRules = this.GetParameterOrDefault(parameters, "IncludeSQLRules", false);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

                // just the one created from client
                Library.Model.NetworkSecurityGroupClientModel nsgWithCustomerRulesToUpdate = parameters.ContainsKey(NetworkSecurityGroupClientModelParameter)
                    ? (Library.Model.NetworkSecurityGroupClientModel)parameters[NetworkSecurityGroupClientModelParameter]
                    : null;

                if (nsgWithCustomerRulesToUpdate == null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Failed to fetch parameter [{0}] from call parameters.", NetworkSecurityGroupClientModelParameter);
                    return this.CreateErrorResponse(ServiceErrorCode.NetworkSecurityGroup_MissingNSGParameter, NetworkSecurityGroupClientModelParameter);
                }

                TopologyInstance topologyInstance;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out error, out topologyInstanceRow))
                {
                    return error;
                }

                if (!this.TryValidateClientNSGCustomerRules(nsgWithCustomerRulesToUpdate, out error))
                {
                    return error;
                }

                if (!this.TryValidateUpdateClientNsgParameter(nsgWithCustomerRulesToUpdate, out error))
                {
                    return error;
                }

                Library.Model.NetworkSecurityGroup nsgWithCustomerRules = new Library.Model.NetworkSecurityGroup();
                nsgWithCustomerRules.Name = nsgWithCustomerRulesToUpdate.Name;

                List<AzureSQLFireWall> sqlFirewallRules = new List<AzureSQLFireWall>();

                foreach (NetworkSecurityGroupClientModel.ClientRule customerRule in nsgWithCustomerRulesToUpdate.Rules)
                {
                    if (!customerRule.Name.StartsWith(Library.Model.NetworkSecurityGroup.CustomerRulePrefix, StringComparison.OrdinalIgnoreCase))
                    {
                        customerRule.Name = string.Concat(Library.Model.NetworkSecurityGroup.CustomerRulePrefix, customerRule.Name);
                    }

                    if (customerRule.Service.Equals(EnvironmentNetworkSecurityRuleService.AzureSQL.ToString(), StringComparison.OrdinalIgnoreCase))
                    {
                        sqlFirewallRules.Add(CommonHelper.NsgClientFirewallRuleToAzureSQLFireWallRule(customerRule));
                    }
                    else
                    {
                        foreach (Library.Model.NetworkSecurityGroup.Rule dsuRule in CommonHelper.ClientNsgRuleToDsuNsgRules(customerRule, topologyInstance))
                        {
                            nsgWithCustomerRules.Rules.Add(dsuRule);
                        }
                    }
                }

                if (topologyInstance.ShouldUseAzureResourceManager())
                {
                    using (var manager = tenantRegistration.CreateAzureResourceManager(topologyInstance.ARM.ResourceGroupName))
                    {
                        if (!this.TryUpdateCustomerARMNSGSecurityRules(manager, topologyInstance, nsgWithCustomerRules, out error))
                        {
                            return error;
                        }
                    }
                }
                else
                {
                    topologyInstance.NetworkSecurityGroup = nsgWithCustomerRules;
                    MigrationLibrary.MigrateTopology(topologyInstance);

                    var deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                    deploymentInstance.Initialize(topologyInstance);

                    DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, DeploymentRequest.DeploymentAction.UpdateNetworkSecurityGroup);

                    if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out error))
                    {
                        return error;
                    }
                }

                if (shouldUpdateSQLRules && sqlFirewallRules.Any())
                {
                    if (!this.TryUpdateSQLDbFirewallRules(topologyInstance, sqlFirewallRules, out error, tenantId, azureSubscriptionId, dbItemName: string.Empty))
                    {
                        return error;
                    }
                }

                return this.Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to get the SQL DB firewall rules on an environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ElasticPoolMigrationService,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        [SuppressMessage("Microsoft.StyleCop.CSharp.NamingRules", "SA1305:FieldNamesMustNotUseHungarianNotation", Justification = "Not a hungarian notation.")]
        public HttpResponseMessage GetSqlDbFirewallRules(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                string dbItemName = this.GetParameterOrDefault(parameters, "DbItemName", String.Empty);

                TopologyInstance topologyInstance;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out error, out topologyInstanceRow))
                {
                    return error;
                }

                List<AzureSQLFireWall> sqlFirewallRules = new List<AzureSQLFireWall>();
                if (!this.TryGetSQLDbFirewallRules(topologyInstance, out sqlFirewallRules, out error, tenantId, azureSubscriptionId, dbItemName))
                {
                    return error;
                }

                NetworkSecurityGroupClientModel nsg = new NetworkSecurityGroupClientModel();
                foreach (AzureSQLFireWall firewallRule in sqlFirewallRules)
                {
                    // Convert to client model and add to the NSG to be returned
                    NetworkSecurityGroupClientModel.ClientRule clientRule = new NetworkSecurityGroupClientModel.ClientRule()
                    {
                        Name = firewallRule.Name,
                        IpOrCidr = string.Equals(firewallRule.StartIPAddress, firewallRule.EndIPAddress, StringComparison.OrdinalIgnoreCase) ?
                            firewallRule.StartIPAddress :
                            CommonHelper.IpRangeToCidr(firewallRule.StartIPAddress, firewallRule.EndIPAddress),
                        Service = EnvironmentNetworkSecurityRuleService.AzureSQL.ToString(),
                        IsCustomerRule = firewallRule.Name.StartsWith(Library.Model.NetworkSecurityGroup.CustomerRulePrefix, StringComparison.OrdinalIgnoreCase),
                    };

                    // Remove the internally-defined rule prefix from rule before returning it to client, and set the RuleType.
                    string rulePrefix = NetworkSecurityGroupClientModelExtensions.GetRulePrefix(clientRule);
                    clientRule.Name = clientRule.Name.Substring(rulePrefix.Length);
                    clientRule.RuleTypeValue = NetworkSecurityGroupClientModelExtensions.GetRuleType(clientRule);

                    nsg.Rules.Add(clientRule);
                }

                return this.Request.CreateResponse(HttpStatusCode.OK, nsg);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }



        /// <summary>
        /// Action used to update the network security group of an instance. Allows * IP addresses in rules.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage UpdateNetworkSecurityGroupAllowAllInternetIP(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                Library.Model.NetworkSecurityGroup nsgWithCustomerRules = parameters.ContainsKey(NetworkSecurityGroupParameter)
                    ? (Library.Model.NetworkSecurityGroup)parameters[NetworkSecurityGroupParameter]
                    : null;

                if (nsgWithCustomerRules == null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Failed to fetch parameter [{0}] from call parameters.", NetworkSecurityGroupParameter);
                    return this.CreateErrorResponse(ServiceErrorCode.NetworkSecurityGroup_MissingNSGParameter, NetworkSecurityGroupParameter);
                }

                TopologyInstance topologyInstance;
                HttpResponseMessage error;
                TopologyInstanceTableItem topologyInstanceRow;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out error, out topologyInstanceRow))
                {
                    return error;
                }

                if (!topologyInstance.ProductName.StartsWith(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.CRMProductNamePrefix, StringComparison.Ordinal))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "UpdateNetworkSecurityGroupAllowAllInternetIP is only supported by CRM product topologies. Target product name: [{0}]", topologyInstance.ProductName);
                    return this.CreateErrorResponse(ServiceErrorCode.NetworkSecurityGroup_FailedCRMTopologyValidation, topologyInstance.ProductName);
                }

                if (!this.TryValidateUpdateNSGParameter(nsgWithCustomerRules, out error, true))
                {
                    return error;
                }

                if (topologyInstance.ShouldUseAzureResourceManager())
                {
                    using (var manager = tenantRegistration.CreateAzureResourceManager(topologyInstance.ARM.ResourceGroupName))
                    {
                        if (!this.TryUpdateCustomerARMNSGSecurityRules(manager, topologyInstance, nsgWithCustomerRules, out error))
                        {
                            return error;
                        }
                    }
                }
                else
                {
                    topologyInstance.NetworkSecurityGroup = nsgWithCustomerRules;
                    MigrationLibrary.MigrateTopology(topologyInstance);

                    var deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                    deploymentInstance.Initialize(topologyInstance);

                    DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, DeploymentRequest.DeploymentAction.UpdateNetworkSecurityGroup);

                    if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out error))
                    {
                        return error;
                    }
                }

                return this.Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Refreshes NSG rules to the existing deployments.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        public HttpResponseMessage RefreshNetworkSecurityGroupRules(
        [FromODataUri] Guid tenantId,
        [FromODataUri] Guid azureSubscriptionId,
        [FromODataUri] string topologyInstanceId,
        ODataActionParameters parameters)
        {
            HttpResponseMessage errorMessage;
            TopologyInstanceTableItem topologyInstanceRow;
            TopologyInstance topologyInstance;

            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                bool isForceCopyEnabled = parameters.ContainsKey(ForceCopy) ? (bool)parameters[ForceCopy] : false;
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceEngine, "ForceCopy flag set to: {0}", isForceCopyEnabled);

                // Get topology instance from topologyInstanceId
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to find topology for instance '{0}'.", topologyInstanceId);
                    return errorMessage;
                }

                CommonHelper.RefreshNetworkSecurityGroupRules(topologyInstance, tenantId, azureSubscriptionId, isForceCopyEnabled);

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to refresh Network security Group rules for Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Syncs Topology Instance of the existing deployments with Add DBMS AppID and Database Firewall rules.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ElasticPoolMigrationService,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        public HttpResponseMessage SyncTopologyInstance(
        [FromODataUri] Guid tenantId,
        [FromODataUri] Guid azureSubscriptionId,
        [FromODataUri] string topologyInstanceId,
        ODataActionParameters parameters)
        {
            Contract.Requires(tenantId != null);
            Contract.Requires(azureSubscriptionId != null);
            Contract.Requires(topologyInstanceId != null);
            Contract.Requires(parameters != null);

            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Performing Sync Topology Instance operations for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.InfrastructureMaintenance;

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                string topologyInstanceActionTypesString = parameters.ContainsKey(CommonDeploymentActionParameters.TopologyInstanceActionTypes) ? (string)parameters[CommonDeploymentActionParameters.TopologyInstanceActionTypes] : null;

                bool forceCopyNSGRules = parameters.ContainsKey(CommonDeploymentActionParameters.ForceCopyNSGRules) ? (bool)parameters[CommonDeploymentActionParameters.ForceCopyNSGRules] : false;

                TopologyInstanceSyncRequest.TopologySyncActionTypes topologyInstanceActionTypes;

                if (!Enum.TryParse(topologyInstanceActionTypesString, out topologyInstanceActionTypes) || topologyInstanceActionTypes == TopologyInstanceSyncRequest.TopologySyncActionTypes.None)
                {
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, topologyInstanceActionTypesString, CommonDeploymentActionParameters.TopologyInstanceActionTypes);
                }

                DeploymentState deploymentState = DeploymentState.InfrastructureMaintenance;

                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;
                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;

                // Get topology instance from topologyInstance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to find topology for instance '{0}'.", topologyInstanceId);
                    return errorMessage;
                }

                // Get Deployment Instance
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (!TopologyInstanceSyncRequest.IsOperationSupportedOnTopology(topologyInstanceActionTypes, topologyInstance))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Topology Sync operation  [{0}] not supported for topology [{1}] SkuType [{2}].", topologyInstanceActionTypes.ToString(), topologyInstanceId, topologyInstance.OfferSKUType);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_UnsupportedEnvironmentType);
                }

                if (topologyInstanceActionTypes == TopologyInstanceSyncRequest.TopologySyncActionTypes.UpdateSecretAttributes)
                {
                    if (!topologyInstance.DeploymentState.IsTerminalState())
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                    }
                }
                else
                {
                    // TopologySync Actions is blocked when last servicing/data movement operation is in failed state.
                    if (IsResumeSupportedOperationInFailedState(topologyInstance, deploymentInstance, DeploymentRequest.DeploymentAction.InfrastructureMaintenance, out errorMessage))
                    {
                        return errorMessage;
                    }

                    // Sync Topology Instance is blocked for environments that have been migrated to SF.
                    if (deploymentInstance.DeploymentState == DeploymentState.MigratedToSF)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but the environment has been Migrated to SF.", action, topologyInstance);
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_EnvironmentMigratedToSF, action);
                    }

                    if (deploymentInstance.DeploymentState != DeploymentState.Finished && deploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                    }
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance);
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.TopologyInstanceActionTypes, topologyInstanceActionTypes.ToString());
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.ForceCopyNSGRules, forceCopyNSGRules.ToString());

                // Add previous DeploymentState and Status in the parameters if any particular action needs it later
                if (topologyInstanceActionTypes == TopologyInstanceSyncRequest.TopologySyncActionTypes.UpdateSecretAttributes)
                {
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.PreviousDeploymentState, topologyInstance.DeploymentState.ToString());
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.PreviousDeploymentStatus, topologyInstance.DeploymentStatus.ToString());
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Added parameters PreviousDeploymentState:[{0}], PreviousDeploymentStatus:[{1}]", topologyInstance.DeploymentState, topologyInstance.DeploymentStatus);
                }

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                if (topologyInstanceActionTypes == TopologyInstanceSyncRequest.TopologySyncActionTypes.UpdateNSG)
                {
                    bool isHttpsLockdown;
                    if (!this.TryValidateHttpsNSGRule(topologyInstance, tenantRegistration, out isHttpsLockdown, out errorMessage))
                    {
                        return errorMessage;
                    }

                    if (isHttpsLockdown)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "This operation is not supported on Https lockdown environment.");
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotSupportedOnEnvironment, topologyInstanceActionTypes.ToString(), "Https Lockdown");
                    }
                }

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, TopologyInstanceSyncTask.TaskNameConstant, out errorMessage, deploymentState))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK, deploymentInstance.Revision);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to sync Topology Instance for Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to sync Topology Instance for Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Import and replace a database in an environment's Azure SQL server instance.
        /// </summary>
        /// <param name="tenantId">LCS unique identifier of the onboarding tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the azure subscription.</param>
        /// <param name="topologyInstanceId">The identifier of the instance of the deployment topology to be affected.</param>
        /// <param name="parameters">Component and artifact id parameters.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage ImportDatabase(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Guid componentId = this.GetParameterOrDefault(parameters, "ComponentId", Guid.Empty);
                Guid artifactId = this.GetParameterOrDefault(parameters, "ArtifactId", Guid.Empty);
                if (componentId.Equals(Guid.Empty) || artifactId.Equals(Guid.Empty) || tenantId.Equals(Guid.Empty)
                    || azureSubscriptionId.Equals(Guid.Empty) || String.IsNullOrWhiteSpace(topologyInstanceId))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Import database call is missing input parameter");
                    return this.CreateErrorResponse(ServiceErrorCode.DataManagement_RestoreDatabase_MissingInputParameter);
                }

                HttpResponseMessage errorMessage;
                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ImportDatabase;

                // Fetch and validate environment information.
                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                TopologyInstanceTableItem topologyInstanceRow;

                // ImportDatabase not supported for staging
                if (!this.ValidateAndFetchDeploymentDetails(
                    tenantId,
                    azureSubscriptionId,
                    topologyInstanceId,
                    EnvironmentGroup.Primary,
                    out topologyInstance,
                    out errorMessage,
                    out topologyInstanceRow,
                    out deploymentInstance,
                    out deploymentInstanceBlobUri,
                    action))
                {
                    return errorMessage;
                }

                DeploymentInstance requestDeploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                requestDeploymentInstance.Initialize(topologyInstance);
                requestDeploymentInstance.DeploymentAction = DeploymentRequest.DeploymentAction.ImportDatabase.ToString();
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, requestDeploymentInstance, action);
                request.Deployment.DeploymentActionParameters.Add(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.ArtifactIdParameter, artifactId.ToString());
                request.Deployment.DeploymentActionParameters.Add(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.ComponentIdParameter, componentId.ToString());

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out errorMessage, DeploymentState.Servicing))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to import AX database into the environment. Paremeters:'{0}'. ErrorCode='{1}'",
                    parameters.ToString(),
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to execute Geneva action for an environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.CSPReleaseValidation,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage ExecuteGenevaAction(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Running Geneva action for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ExecuteGenevaAction;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                GenevaActionType genevaActionToExecute;
                IDictionary<string, object> parameterValues;
                HttpResponseMessage errorMessage;
                if (!this.ReadGenevaActionParameters(parameters, action, environmentGroup, out genevaActionToExecute, out parameterValues, out errorMessage))
                {
                    return errorMessage;
                }

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;

                TopologyInstanceTableItem topologyInstanceRow;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                DeploymentState deploymentState = DeploymentState.ExecutingGenevaAction;

                HashSet<string> allowedGASet = new HashSet<string>
                                                    { Enum.GetName(typeof(GenevaActionType), GenevaActionType.FetchPackageDeploymentLogs),
                                                      Enum.GetName(typeof(GenevaActionType), GenevaActionType.RecycleIISAppPool),
                                                      Enum.GetName(typeof(GenevaActionType), GenevaActionType.RestartVM),
                                                      Enum.GetName(typeof(GenevaActionType), GenevaActionType.StartApplicationGateway),
                                                      Enum.GetName(typeof(GenevaActionType), GenevaActionType.StopApplicationGateway),
                                                      Enum.GetName(typeof(GenevaActionType), GenevaActionType.CollectMemoryDumpAppPool)
                                                    };

                // Execute Geneva Actions is blocked when last servicing/data movement operation is in failed state.
                if (!allowedGASet.Contains(Enum.GetName(typeof(GenevaActionType), genevaActionToExecute)) && IsResumeSupportedOperationInFailedState(topologyInstance, deploymentInstance, DeploymentRequest.DeploymentAction.InfrastructureMaintenance, out errorMessage))
                {
                    return errorMessage;
                }

                // Execute Geneva Actions is blocked when the environment is in a swapped or transitioning state.
                if (deploymentInstance.DeploymentState == DeploymentState.Swapped || topologyInstance.HasCustomizationValue(CommonCustomizationNames.IsSwapped, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment is currently Swapped.", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNotSwapped, action);
                }
                // Execute Geneva Actions is blocked for environments that have been migrated to SF.
                else if (deploymentInstance.DeploymentState == DeploymentState.MigratedToSF)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment has been Migrated to SF.", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_EnvironmentMigratedToSF, action);
                }
                else if (topologyInstance.HasCustomizationValue(CommonCustomizationNames.RollbackInProgress, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment did not complete Rollback. Please rollback or commit the swap to enable the action [{0}].", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNotRollback, action);
                }
                else if (genevaActionToExecute == GenevaActionType.EnableEnvironment || genevaActionToExecute == GenevaActionType.DisableEnvironment || genevaActionToExecute == GenevaActionType.MigrateToSSRSService || genevaActionToExecute == GenevaActionType.MigrateToBIVM)
                {
                    if (deploymentInstance.DeploymentStatus == Model.DeploymentStatus.Failed)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but the primary deployment is currently Deployment Status [{2}].", action, topologyInstance, deploymentInstance.DeploymentStatus);
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                    }

                    // If environment is disabled and trying to enable then from geneva action allow to enable.
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Action {0}- Current DeploymentState: {1} and DeploymentStatus {2}.", genevaActionToExecute.ToString(), deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus);
                }
                else if (genevaActionToExecute == GenevaActionType.RepublishToLocator &&
                    (topologyInstance.DeploymentState == DeploymentState.Stopped || topologyInstance.DeploymentState == DeploymentState.Deallocated))
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Action {0}- TopologyInstance: {1} and DeploymentState {2}.",
                        genevaActionToExecute.ToString(),
                        topologyInstance,
                        deploymentInstance.DeploymentState);
                }
                else if (topologyInstance.DeploymentState != DeploymentState.Finished && deploymentInstance.DeploymentState != DeploymentState.Finished && deploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but the primary deployment is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                return this.TryScheduleGenevaOperationTask(tenantId, azureSubscriptionId, topologyInstance, topologyInstanceRow, deploymentState, action, genevaActionToExecute, parameterValues);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to execute the specified Geneva Action for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to execute the specified Geneva Action for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Update Topology Instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology will be deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>The success result.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        public HttpResponseMessage UpdateTopologyInstance(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Start update of Topology Instance Id [{0}] in Azure Subscription [{1}] of Tenant [{2}]",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.TopologyInstanceUpdateAction;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                TopologyInstanceUpdateType topologyInstanceUpdateType;
                IDictionary<string, object> parameterValues;
                HttpResponseMessage errorMessage;

                if (!this.ReadTopologyInstanceUpdateParameters(parameters, action, environmentGroup, out topologyInstanceUpdateType, out parameterValues, out errorMessage))
                {
                    return errorMessage;
                }

                if (topologyInstanceUpdateType == TopologyInstanceUpdateType.ReEncryptTopology || topologyInstanceUpdateType == TopologyInstanceUpdateType.RemoveOrUpdateSecretsInKeyVault)
                {
                    return UpdateTopologyInstanceIncludingDeleted(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, parameterValues, topologyInstanceUpdateType, out errorMessage);
                }

                TopologyInstance topologyInstance;
                TopologyInstanceTableItem topologyInstanceRow;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to get Topology Instance [{0}] because it was not found", topologyInstanceId);
                    return errorMessage;
                }

                if (!topologyInstance.DeploymentState.IsTerminalState())
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Attempted to [{0}] on Topology Instance [{1}] failed, require State [{2}] and Status [{3}], actual Deployment State [{4}] Deployment Status [{5}]",
                        topologyInstanceUpdateType, topologyInstance, DeploymentState.Finished, Model.DeploymentStatus.Succeeded, topologyInstance.DeploymentState, topologyInstance.DeploymentStatus);

                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, action);
                }

                switch (topologyInstanceUpdateType)
                {
                    case TopologyInstanceUpdateType.RemoveExternalMonitor:
                        // More monitor groups / components / monitor types might added in future, this can be further modified to suit specific need
                        // Currenty, there is only one monitor group and one monitor type in each component
                        if (topologyInstance.ExternalMonitorGroups.Any())
                        {
                            string externalMonitorComponenet = parameterValues.ContainsKey(CommonDeploymentActionParameters.ExternalMonitorComponentToRemove)
                                ? (string)parameterValues[CommonDeploymentActionParameters.ExternalMonitorComponentToRemove]
                                : string.Empty;

                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "External Monitor Componenet [{0}] requested for removal", externalMonitorComponenet);

                            foreach (var monitorGroup in topologyInstance.ExternalMonitorGroups)
                            {
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Start [{0}] removal in monitor group [{1}]", externalMonitorComponenet, monitorGroup.DeploymentItem);

                                var monitorComponentToRemove = monitorGroup.ExternalMonitorComponents.SingleOrDefault(x => string.Equals(x.Component, externalMonitorComponenet, StringComparison.OrdinalIgnoreCase));

                                if (monitorComponentToRemove == null)
                                {
                                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to find External Monitor Component [{0}] in Topology Instance", externalMonitorComponenet, topologyInstance);
                                    return this.CreateErrorResponse(
                                        HttpStatusCode.NotFound,
                                        string.Format("Unable to find requested External Monitor Componenet [{0}] in monitor group [{1}], it might already removed, Topology Instance update aborted",
                                        externalMonitorComponenet, monitorGroup.DeploymentItem));
                                }

                                monitorGroup.ExternalMonitorComponents.Remove(monitorComponentToRemove);

                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Completed [{0}] removal in monitor group [{1}]", externalMonitorComponenet, monitorGroup.DeploymentItem);
                            }

                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);

                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "External Monitor Componenet [{0}] removed", externalMonitorComponenet);
                        }
                        else
                        {
                            return this.CreateErrorResponse(HttpStatusCode.NotFound, string.Format("Unable to find any monitor group in Topology Instance [{0}]", topologyInstance));
                        }

                        break;

                    case TopologyInstanceUpdateType.ShowAdminUser:
                        {
                            var virtualMachines = topologyInstance.DeploymentItems.GetAll((DeploymentItemType.VirtualMachine));

                            if (virtualMachines == null)
                            {
                                return this.CreateErrorResponse(HttpStatusCode.NotFound, string.Format("Unable to find any primary virtual machines in Topology Instance [{0}]", topologyInstance));
                            }

                            foreach (var vm in virtualMachines)
                            {
                                HttpResponseMessage error;
                                var adminAccountCredentials = GetAdminAccountCredentials(vm, out error);
                                if (adminAccountCredentials == null)
                                {
                                    return error;
                                }

                                ChangeAccountVisibility(vm, adminAccountCredentials, true, "admin", tenantId, azureSubscriptionId, topologyInstance);
                            }
                        }

                        break;

                    case TopologyInstanceUpdateType.HideAdminUser:
                        {
                            var virtualMachines = topologyInstance.DeploymentItems.GetAllPrimary((DeploymentItemType.VirtualMachine));

                            if (virtualMachines == null)
                            {
                                return this.CreateErrorResponse(HttpStatusCode.NotFound, string.Format("Unable to find any primary virtual machines in Topology Instance [{0}]", topologyInstance));
                            }

                            foreach (var vm in virtualMachines)
                            {
                                HttpResponseMessage adminAccountMissingerror;
                                var adminAccountCredentials = GetAdminAccountCredentials(vm, out adminAccountMissingerror);
                                if (adminAccountCredentials == null)
                                {
                                    return adminAccountMissingerror;
                                }

                                //Hide admin account only if local acount exists and is visible
                                HttpResponseMessage localAccountMissingerror;
                                var localAccountCredentials = GetLocalAccountCredentials(vm, out localAccountMissingerror);
                                if (localAccountCredentials == null)
                                {
                                    return localAccountMissingerror;
                                }

                                if (localAccountCredentials.IsVisible == false)
                                {
                                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "This operation is not supported for a virtual machine with no visible local user account.");
                                    return this.CreateErrorResponse(
                                        HttpStatusCode.NotFound,
                                        "This operation is not supported for a virtual machine with no visible local user account. Topology Instance update will be aborted.");

                                }

                                ChangeAccountVisibility(vm, adminAccountCredentials, false, "admin", tenantId, azureSubscriptionId, topologyInstance);
                            }
                        }
                        break;

                    case TopologyInstanceUpdateType.ShowLocalUser:
                        {
                            var virtualMachines = topologyInstance.DeploymentItems.GetAllPrimary((DeploymentItemType.VirtualMachine));

                            if (virtualMachines == null)
                            {
                                return this.CreateErrorResponse(HttpStatusCode.NotFound, string.Format("Unable to find any primary virtual machines in Topology Instance [{0}]", topologyInstance));
                            }

                            foreach (var vm in virtualMachines)
                            {
                                HttpResponseMessage localAccountMissingerror;
                                var localAccountCredentials = GetLocalAccountCredentials(vm, out localAccountMissingerror);
                                if (localAccountCredentials == null)
                                {
                                    return localAccountMissingerror;
                                }

                                ChangeAccountVisibility(vm, localAccountCredentials, true, "local user", tenantId, azureSubscriptionId, topologyInstance);
                            }
                        }
                        break;

                    case TopologyInstanceUpdateType.HideAllUsers:
                        {
                            var virtualMachines = topologyInstance.DeploymentItems.GetAll((DeploymentItemType.VirtualMachine));

                            if (virtualMachines == null)
                            {
                                return this.CreateErrorResponse(HttpStatusCode.NotFound, string.Format("Unable to find any primary virtual machines in Topology Instance [{0}]", topologyInstance));
                            }

                            foreach (var vm in virtualMachines)
                            {
                                var adminAccountCredentials = vm.Credentials.Where(c => string.Equals(c.SymbolicName, CommonCustomizationNames.LocalAdminCredential, StringComparison.OrdinalIgnoreCase)).FirstOrDefault();

                                //Hide admin account
                                if (adminAccountCredentials != null)
                                {
                                    if (adminAccountCredentials.IsVisible == false)
                                    {
                                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The admin account visibility for vm [{0}] is already set to [{1}].", vm.ItemName, adminAccountCredentials.IsVisible);
                                    }
                                    else
                                    {
                                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Changing admin account visibility for vm [{0}] from [{1}] to [{2}].", vm.ItemName, adminAccountCredentials.IsVisible, !(adminAccountCredentials.IsVisible));
                                        adminAccountCredentials.IsVisible = false;
                                    }

                                }

                                var localAccountCredentials = vm.Credentials.Where(c => string.Equals(c.SymbolicName, CommonCustomizationNames.LocalUserCredential, StringComparison.OrdinalIgnoreCase)).FirstOrDefault();

                                //Hide local user account
                                if (localAccountCredentials != null)
                                {
                                    if (localAccountCredentials.IsVisible == false)
                                    {
                                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The local user visibility for vm [{0}] is already set to [{1}].", vm.ItemName, localAccountCredentials.IsVisible);
                                    }
                                    else
                                    {
                                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Changing local user account visibility for vm [{0}] from [{1}] to [{2}].", vm.ItemName, localAccountCredentials.IsVisible, !(localAccountCredentials.IsVisible));
                                        localAccountCredentials.IsVisible = false;
                                    }
                                }

                                this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            }
                        }
                        break;

                    case TopologyInstanceUpdateType.RemoveAOSTLS:
                        {
                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.RemoveAOSTLS.ToString());
                            var result = topologyInstance.RemoveAOSTLS();
                            if (result)
                            {
                                this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed AOSTLS references from the topology instance");
                            }
                        }
                        break;

                    case TopologyInstanceUpdateType.EnableCRR:
                        {
                            topologyInstance.SetCustomizationValue(CommonCustomizationNames.CrossRestoreRegionEnabled, CommonCustomizationNames.EnabledYes);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Cross Region Restore flag is Enabled for the topology instance [{0}]", topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.DisableCRR:
                        {
                            topologyInstance.SetCustomizationValue(CommonCustomizationNames.CrossRestoreRegionEnabled, CommonCustomizationNames.EnabledNo);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Cross Region Restore flag is Disabled for the topology instance [{0}]", topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.EnableReplyURLMissingWarning:
                        {
                            topologyInstance.SetCustomizationValue(CommonCustomizationNames.ReplyURLMissingWarning, CommonCustomizationNames.EnabledYes);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "ReplyURLMissingWarning flag is Enabled for the topology instance [{0}]", topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.DisableReplyURLMissingWarning:
                        {
                            topologyInstance.SetCustomizationValue(CommonCustomizationNames.ReplyURLMissingWarning, CommonCustomizationNames.EnabledNo);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "ReplyURLMissingWarning flag is Disabled for the topology instance [{0}]", topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.AddCustomCACertificateGuard:
                        {
                            string customCACertificateList = parameterValues.ContainsKey(CommonDeploymentActionParameters.CustomCACertificateList)
                                ? (string)parameterValues[CommonDeploymentActionParameters.CustomCACertificateList]
                                : string.Empty;

                            topologyInstance.SetCustomizationValue(CommonCustomizationNames.CustomCACertificatesGuard, CommonCustomizationNames.EnabledYes);
                            if (!string.IsNullOrEmpty(customCACertificateList))
                            {
                                topologyInstance.SetCustomizationValue(CommonCustomizationNames.CustomCACertificatesList, customCACertificateList);
                            }

                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.AddCustomCACertificateGuard.ToString());
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Custom CA certificate guard is Enabled for the topology instance [{0}]", topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.RemoveCustomCACertificateGuard:
                        {
                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.RemoveCustomCACertificateGuard.ToString());
                            topologyInstance.SetCustomizationValue(CommonCustomizationNames.CustomCACertificatesGuard, CommonCustomizationNames.EnabledNo);
                            topologyInstance.TryRemoveCustomization(CommonCustomizationNames.CustomCACertificatesList);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Custom CA certificate guard is Disabled for the topology instance [{0}]", topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.AddEnvironmentRestartGuard:
                        {
                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.AddEnvironmentRestartGuard.ToString());
                            topologyInstance.SetCustomizationValue(CommonCustomizationNames.IsEnvironmentRestartDisabled, true);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Environment restart guard is Enabled for the topology instance [{0}]", topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.RemoveEnvironmentRestartGuard:
                        {
                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.RemoveEnvironmentRestartGuard.ToString());
                            topologyInstance.TryRemoveCustomization(CommonCustomizationNames.IsEnvironmentRestartDisabled);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Environment restart guard is Disabled for the topology instance [{0}]", topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.AddRetailCustomPaymentConnectorGuard:
                        {
                            string customRetailPaymentConnectorPatchId = parameterValues.ContainsKey(CommonDeploymentActionParameters.RetailCustomPaymentConnectorPatchId)
                                ? (string)parameterValues[CommonDeploymentActionParameters.RetailCustomPaymentConnectorPatchId]
                                : string.Empty;

                            topologyInstance.SetCustomizationValue(CommonCustomizationNames.RetailCustomPaymentConnectorGuard, CommonCustomizationNames.EnabledYes);
                            if (!string.IsNullOrEmpty(customRetailPaymentConnectorPatchId))
                            {
                                topologyInstance.SetCustomizationValue(CommonCustomizationNames.RetailCustomPaymentConnectorPatchId, customRetailPaymentConnectorPatchId);
                            }

                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.AddRetailCustomPaymentConnectorGuard.ToString());
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "RetailCustomPaymentConnector guard is Enabled for the topology instance [{0}]", topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.RemoveRetailCustomPaymentConnectorGuard:
                        {
                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.RemoveRetailCustomPaymentConnectorGuard.ToString());
                            topologyInstance.SetCustomizationValue(CommonCustomizationNames.RetailCustomPaymentConnectorGuard, CommonCustomizationNames.EnabledNo);
                            topologyInstance.TryRemoveCustomization(CommonCustomizationNames.RetailCustomPaymentConnectorPatchId);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "RetailCustomPaymentConnector guard is Disabled for the topology instance [{0}]", topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.AddRetailCSUMigrationCustomization:
                        {
                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.AddRetailCSUMigrationCustomization.ToString());
                            topologyInstance.SetCustomizationValue(CommonCustomizationNames.RetailCSUMigration, true);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Retail CSU Migration is enabled for the topology instance [{0}]", topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.RemoveRetailCSUMigrationCustomization:
                        {
                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.RemoveRetailCSUMigrationCustomization.ToString());
                            topologyInstance.TryRemoveCustomization(CommonCustomizationNames.RetailCSUMigration);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Retail CSU Migration is disabled for the topology instance [{0}]", topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.AddMutlipleVersionsOfCertificatePresentCustomization:
                        {
                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.AddMutlipleVersionsOfCertificatePresentCustomization.ToString());
                            topologyInstance.SetCustomizationValue(CommonCustomizationNames.InstallMultipleCertificateVersionsInSF, true);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Added [{0}] customization for the topology instance [{1}]", CommonCustomizationNames.InstallMultipleCertificateVersionsInSF, topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.RemoveMutlipleVersionsOfCertificatePresentCustomization:
                        {
                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.RemoveMutlipleVersionsOfCertificatePresentCustomization.ToString());
                            topologyInstance.TryRemoveCustomization(CommonCustomizationNames.InstallMultipleCertificateVersionsInSF);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed [{0}] customization for the topology instance [{1}]", CommonCustomizationNames.InstallMultipleCertificateVersionsInSF, topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.AddMutlipleVersionsOfCertificateInstalledInSFCustomization:
                        {
                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.AddMutlipleVersionsOfCertificateInstalledInSFCustomization.ToString());
                            topologyInstance.SetCustomizationValue(CommonCustomizationNames.MultipleCertificateVersionsInstalledInSF, true);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Added [{0}] customization for the topology instance [{1}]", CommonCustomizationNames.MultipleCertificateVersionsInstalledInSF, topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.RemoveMutlipleVersionsOfCertificateInstalledInSFCustomization:
                        {
                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.RemoveMutlipleVersionsOfCertificateInstalledInSFCustomization.ToString());
                            topologyInstance.TryRemoveCustomization(CommonCustomizationNames.MultipleCertificateVersionsInstalledInSF);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed [{0}] customization for the topology instance [{1}]", CommonCustomizationNames.MultipleCertificateVersionsInstalledInSF, topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.RemoveDataEncryptionCertificateRotationEnabledCustomization:
                        {
                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.RemoveDataEncryptionCertificateRotationEnabledCustomization.ToString());
                            topologyInstance.TryRemoveCustomization(CommonCustomizationNames.DataEncryptionCertificateRotationSupported);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed [{0}] customization for the topology instance [{1}]", CommonCustomizationNames.DataEncryptionCertificateRotationSupported, topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.RemoveReEncryptThumbprintCustomization:
                        {
                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.RemoveReEncryptThumbprintCustomization.ToString());
                            topologyInstance.TryRemoveCustomization(CommonCustomizationNames.ReEncryptThumbprint);
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed ReEncryptThumbprint from the topology instance [{0}]", topologyInstance);
                        }
                        break;

                    case TopologyInstanceUpdateType.CheckEnvironmentAdministrator:
                    case TopologyInstanceUpdateType.UpdateEnvironmentAdministrator:
                        {
                            string environmentAdministratorFromRequest = parameterValues.ContainsKey(CommonDeploymentActionParameters.EnvironmentAdministrator)
                                ? (string)parameterValues[CommonDeploymentActionParameters.EnvironmentAdministrator]
                                : string.Empty;

                            if (!string.IsNullOrEmpty(environmentAdministratorFromRequest))
                            {
                                string environmentAdministratorInTopology;
                                if (topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.EnvironmentAdministratorUserAlias, out environmentAdministratorInTopology))
                                {
                                    if (environmentAdministratorInTopology != environmentAdministratorFromRequest)
                                    {
                                        if (topologyInstanceUpdateType == TopologyInstanceUpdateType.CheckEnvironmentAdministrator)
                                        {
                                            string errMessage = string.Format("EnvironmentAdministrator in topology {0} doesn't match with {1}", environmentAdministratorInTopology, environmentAdministratorFromRequest);
                                            Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, errMessage);
                                            return this.CreateErrorResponse(HttpStatusCode.BadRequest, errMessage);
                                        }
                                        else if (topologyInstanceUpdateType == TopologyInstanceUpdateType.UpdateEnvironmentAdministrator)
                                        {
                                            this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.UpdateEnvironmentAdministrator.ToString());

                                            topologyInstance.SetCustomizationValue(CommonCustomizationNames.EnvironmentAdministratorUserAlias, environmentAdministratorFromRequest);
                                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Updated environment administrator in the topology instance [{0}]", topologyInstance);
                                        }
                                    }
                                    else
                                    {
                                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "EnvironmentAdministrator in topology {0} matches with {1}", environmentAdministratorInTopology, environmentAdministratorFromRequest);
                                    }
                                }
                                else
                                {
                                    string errMessage = string.Format("Failed to get EnvironmentAdministrator from the topology {0}", topologyInstance);
                                    Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, errMessage);
                                    return this.CreateErrorResponse(HttpStatusCode.InternalServerError, errMessage);
                                }
                            }
                        }
                        break;

                    case TopologyInstanceUpdateType.UpdateSQLServerName:
                        {
                            string sqlServerItemName = string.Empty;
                            string sqlDatabaseItemName = string.Empty;
                            string newSqlServerName = string.Empty;
                            string currentSqlServerName = string.Empty;

                            if (parameterValues.TryGetValue(CommonDeploymentActionParameters.SqlServerType, out object objServerType))
                            {
                                sqlServerItemName = (string)objServerType;
                            }

                            if (parameterValues.TryGetValue(CommonDeploymentActionParameters.DatabaseType, out object objDatabaseType))
                            {
                                sqlDatabaseItemName = (string)objDatabaseType;
                            }

                            if (parameterValues.TryGetValue(CommonDeploymentActionParameters.NewSQLServerName, out object objServerName))
                            {
                                newSqlServerName = (string)objServerName;
                            }

                            DeploymentItem sqlServerDeploymentItem = topologyInstance.DeploymentItems.GetAll(DeploymentItemType.AzureSQLServer)
                                .Where(item => sqlServerItemName == item.ItemName)
                                .FirstOrDefault();
                            sqlServerDeploymentItem.TryGetCustomizationValue(CommonCustomizationNames.AzureSQLServerName, out currentSqlServerName);
                            if (!sqlServerDeploymentItem.TrySetCustomizationValue(CommonCustomizationNames.AzureSQLServerName, newSqlServerName))
                            {
                                Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Skipped updating {CommonCustomizationNames.AzureSQLServerName}");
                            }
                            if (!sqlServerDeploymentItem.TrySetCustomizationValue(CommonCustomizationNames.AzureSQLServerFullyQualifiedDomainName,
                                $"{newSqlServerName}.{AzureEnvironmentConfig.SqlDatabaseDnsSuffix}"))
                            {
                                Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Skipped updating {CommonCustomizationNames.AzureSQLServerFullyQualifiedDomainName}");
                            }

                            DeploymentItem sqlDatabaseDeploymentItem = topologyInstance.DeploymentItems.GetAll(DeploymentItemType.AzureSQLDatabase)
                                .Where(item => sqlDatabaseItemName == item.ItemName)
                                .FirstOrDefault();
                            if (sqlDatabaseDeploymentItem == null ||
                                !sqlDatabaseDeploymentItem.TrySetCustomizationValue(
                                    CommonCustomizationNames.AzureSQLServerFullyQualifiedDomainName,
                                    $"{newSqlServerName}.{AzureEnvironmentConfig.SqlDatabaseDnsSuffix}"))
                            {
                                Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Skipped updating {CommonCustomizationNames.AzureSQLServerFullyQualifiedDomainName}");
                            }
                            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                            Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"The name of SQLServer({sqlServerItemName}) was updated from '{currentSqlServerName}' to '{newSqlServerName}'.");
                        }
                        break;

                    case TopologyInstanceUpdateType.UpdateEDWDatabaseAlias:
                        {
                            string sqlDBAlias = parameterValues.ContainsKey(CommonDeploymentActionParameters.SQLDBAlias)
                                ? (string)parameterValues[CommonDeploymentActionParameters.SQLDBAlias]
                                : string.Empty;

                            string errMessage = string.Empty;
                            if (!string.IsNullOrEmpty(sqlDBAlias) && topologyInstance.UpdateEDWDBAlias(sqlDBAlias, out errMessage))
                            {
                                this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.UpdateEDWDatabaseAlias.ToString());
                                this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Updated EDW SQL DB Database alias for topology instance [{0}]", topologyInstance);
                            }
                            else
                            {
                                return this.CreateErrorResponse(HttpStatusCode.NotFound, errMessage);
                            }

                        }
                        break;

                    default:
                        throw new NotSupportedException(topologyInstanceUpdateType.ToString());
                }

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Completed update of Topology Instance [{0}] in Azure Subscription [{1}] of Tenant [{2}]",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to update Topology Instance [{0}] in Azure Subscription [{1}] of Tenant [{2}]. ErrorCode=[{3}]",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: [{0}]", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to update Topology Instance [{0}] in Azure Subscription [{1}] of Tenant [{2}]",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: [{0}]", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Changes the visibility of the account.
        /// </summary>
        /// <param name="vm">The virtual machine</param>
        /// <param name="credentials">The credentials.</param>
        /// <param name="isVisible">The flag which indicates the visibility. to be set.</param>
        /// <param name="accountType">The account type.</param>
        /// <param name="tenantId">The tenant Id.</param>
        /// <param name="azureSubscriptionId">The azure subscription Id.</param>
        /// <param name="topologyInstance">The topology Instance.</param>
        private void ChangeAccountVisibility(DeploymentItem vm, Library.Model.Credential credentials, bool isVisible, string accountType, Guid tenantId, Guid azureSubscriptionId, TopologyInstance topologyInstance)
        {
            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Changing {0} account visibility for vm [{1}] from [{2}] to [{3}].", accountType, vm.ItemName, credentials.IsVisible, !(credentials.IsVisible));
            credentials.IsVisible = isVisible;
            this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
        }

        /// <summary>
        /// Gets admin account  credentials.
        /// </summary>
        /// <param name="vm">The virtual machine.</param>
        /// <param name="error">The error response.</param>
        /// <returns>The admin credentials.</returns>
        private Credential GetAdminAccountCredentials(DeploymentItem vm, out HttpResponseMessage error)
        {
            var adminAccountCredentials = vm.Credentials.Where(c => string.Equals(c.SymbolicName, CommonCustomizationNames.LocalAdminCredential, StringComparison.OrdinalIgnoreCase)).FirstOrDefault();

            if (adminAccountCredentials == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to find admin account in virtual machine [{0}]", vm.ItemName);
                error = this.CreateErrorResponse(
                                       HttpStatusCode.NotFound,
                                       string.Format("Unable to find admin account in virtual machine [{0}]. Topology Instance update will be aborted.",
                                        vm.ItemName));
                return null;
            }

            error = null;
            return adminAccountCredentials;
        }

        /// <summary>
        /// Gets local account credentials.
        /// </summary>
        /// <param name="vm">The virtal machine.</param>
        /// <param name="error">The error response.</param>
        /// <returns>The local account credentials.</returns>
        private Credential GetLocalAccountCredentials(DeploymentItem vm, out HttpResponseMessage error)
        {
            var localAccountCredentials = vm.Credentials.Where(c => string.Equals(c.SymbolicName, CommonCustomizationNames.LocalUserCredential, StringComparison.OrdinalIgnoreCase)).FirstOrDefault();

            if (localAccountCredentials == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to find local user account in virtual machine [{0}]", vm.ItemName);
                error = this.CreateErrorResponse(
                    HttpStatusCode.NotFound,
                    string.Format("Unable to find local user account in virtual machine [{0}]. Topology Instance update will be aborted.",
                    vm.ItemName));

                return null;
            }

            error = null;
            return localAccountCredentials;
        }

        /// <summary>
        /// Updates deployment state and status to topology instance blob/table, deployment instance blob.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology will be deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>The success result.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        public HttpResponseMessage UpdateEnvironmentState(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Executing update environment state for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                DeploymentState deploymentState;
                Model.DeploymentStatus deploymentStatus;
                HttpResponseMessage errorMessage;

                if (!this.ReadUpdateEnvironmentStateParameters(parameters, out deploymentState, out deploymentStatus, out errorMessage))
                {
                    return errorMessage;
                }

                bool updateTopologyInstance = this.GetParameterOrDefault(parameters, CommonDeploymentActionParameters.UpdateTopologyInstance, true);
                bool updateTopologyInstanceTable = this.GetParameterOrDefault(parameters, CommonDeploymentActionParameters.UpdateTopologyInstanceTable, true);
                bool updateDeploymentInstance = this.GetParameterOrDefault(parameters, CommonDeploymentActionParameters.UpdateDeploymentInstance, true);
                TopologyInstanceTableItem topologyInstanceRow = null;
                TopologyInstance topologyInstance = null;

                Tracer.WriteExecutionEvent(
                   TraceComponent.DeploymentServiceApi,
                   "From Client: deploymentState: '{0}', deploymentStatus: '{1}', updateTopologyInstance: '{2}', updateTopologyInstanceTable: '{3}' and updateDeploymentInstance: '{4}'.",
                   deploymentState.ToString(),
                   deploymentStatus.ToString(),
                   updateTopologyInstance.ToString(),
                   updateTopologyInstanceTable.ToString(),
                   updateDeploymentInstance.ToString());

                // Update topology instance blob if requested
                if (updateTopologyInstance)
                {
                    if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to get topology instance '{0}' because it was not found.", topologyInstanceId);
                        return errorMessage;
                    }

                    Tracer.WriteExecutionEvent(
                       TraceComponent.DeploymentServiceApi,
                       "Updating topology instance blob, Deployment State old value: '{0}', new value: '{1}' and Deployment Status old value: '{2}', new value: '{3}'",
                       topologyInstance.DeploymentState.ToString(),
                       deploymentState.ToString(),
                       topologyInstance.DeploymentStatus.ToString(),
                       deploymentStatus.ToString());

                    // Update Topology instance state and status.
                    topologyInstance.DeploymentState = deploymentState;
                    topologyInstance.DeploymentStatus = deploymentStatus;

                    // update the topology instance blob
                    this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                }

                // Update topology instance table if requested
                if (updateTopologyInstanceTable)
                {
                    AzureTable<TopologyInstanceTableItem> table = TopologyInstanceDAC.GetTopologyInstanceTable();
                    if (topologyInstanceRow == null)
                    {
                        // If updateTopologyInstance is false then need to read table row separately here.
                        topologyInstanceRow = this.GetTopologyTableItem(table, tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup);
                    }

                    if (topologyInstanceRow == null)
                    {
                        Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Could not find item in table. TenantId: [{0}] AzureSubscriptionId: [{1}] TopologyInstanceId: [{2}]",
                        tenantId,
                        azureSubscriptionId,
                        topologyInstanceId);

                        return this.CreateErrorResponse(HttpStatusCode.NotFound, "Could not find item in table.");
                    }

                    Tracer.WriteExecutionEvent(
                       TraceComponent.DeploymentServiceApi,
                       "Updating topology instance table, Deployment State old value: '{0}', new value: '{1}' and Deployment Status old value: '{2}', new value: '{3}'",
                       topologyInstanceRow.LastDeploymentState,
                       deploymentState.ToString(),
                       topologyInstanceRow.LastDeploymentStatus,
                       deploymentStatus.ToString());

                    // Update deployment state in topology instance table
                    topologyInstanceRow.LastDeploymentState = deploymentState.ToString();
                    topologyInstanceRow.LastDeploymentStatus = deploymentStatus.ToString();

                    // Through Geneva action while updating state as Deleted update DeleteDatetime also.
                    // Force sync Geneva action on LCS side checks for DeleteDatetime is not empty.
                    if (deploymentState == DeploymentState.Deleted && deploymentStatus == Model.DeploymentStatus.Succeeded)
                    {
                        topologyInstanceRow.DeleteDatetime = DateTime.UtcNow;
                    }

                    table.Upsert(topologyInstanceRow);
                }

                // Update deployment instance blob if required
                if (updateDeploymentInstance)
                {
                    DeploymentInstance deploymentInstance;
                    Uri deploymentInstanceBlobUri;
                    AzureTable<TopologyInstanceTableItem> table = TopologyInstanceDAC.GetTopologyInstanceTable();
                    if (topologyInstanceRow == null)
                    {
                        // If updateTopologyInstance and updateTopologyInstanceTable is false then need to read table row separately here.
                        topologyInstanceRow = this.GetTopologyTableItem(table, tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup);
                    }

                    if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                    {
                        return errorMessage;
                    }

                    Tracer.WriteExecutionEvent(
                       TraceComponent.DeploymentServiceApi,
                       "Updating deployment instance blob, DeploymentAction: {0}, Revision: {1}, Deployment State old value: '{2}', new value: '{3}' and Deployment Status old value: '{4}', new value: '{5}'",
                       deploymentInstance.DeploymentAction,
                       deploymentInstance.Revision,
                       deploymentInstance.DeploymentState.ToString(),
                       deploymentState.ToString(),
                       deploymentInstance.DeploymentStatus.ToString(),
                       deploymentStatus.ToString());

                    deploymentInstance.DeploymentState = deploymentState;
                    deploymentInstance.DeploymentStatus = deploymentStatus;

                    // Update the blob uri content
                    this.UploadDeploymentBlob(deploymentInstanceBlobUri, deploymentInstance);
                }

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to execute the update environment state for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to execute the update environment state for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to get the list of active SQL actions that can be executed against the environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the azure subscription in where the topology is (to be) deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>A collection of SQL Actions.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetSQLActions(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                string accessLevel = this.GetParameterOrDefault<string>(parameters, ServiceConstants.GetSQLActionAccessLevel, null);
                string databaseType = this.GetParameterOrDefault<string>(parameters, TopologyInstancesController.DeploymentItemNameParameter, null);
                string audience = this.GetParameterOrDefault<string>(parameters, ServiceConstants.GetSQLActionAudience, DeploymentConstants.AudienceCustomer);

                if (string.IsNullOrEmpty(accessLevel))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Get SQL Actions call is missing an input parameter");
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, "GetSQLActions", accessLevel, ServiceConstants.GetSQLActionAccessLevel);
                }

                if (string.IsNullOrEmpty(databaseType))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Get SQL Actions call is missing an input parameter");
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, "GetSQLActions", databaseType, TopologyInstancesController.DeploymentItemNameParameter);
                }

                IEnumerable<SQLActionTableItem> tableItems = SQLActionDAC.GetSQLActions(accessLevel, databaseType, audience);

                List<SQLAction> sqlActions = tableItems
                    .Select(item => new SQLAction(
                        item.Name,
                        item.DisplayName,
                        item.Description,
                        string.IsNullOrWhiteSpace(item.Parameters) ? new List<SQLActionParameter>() : CommonUtilities.DeserializeJson<IEnumerable<SQLActionParameter>>(item.Parameters),
                        item.FastQuery,
                        item.SupportsAllQueryPaths,
                        item.QueryTimeout,
                        item.ReturnsResults,
                        item.OutputFileExtension))
                    .ToList();

                // OData does not serialize empty arrays. Setting null arrays to size of zero.
                IEnumerable<SQLActionParameter> nullAvailableValues = sqlActions.SelectMany(sa => sa.Parameters).Where(param => param.AvailableValues == null);

                foreach (SQLActionParameter nullAvailableValue in nullAvailableValues)
                {
                    nullAvailableValue.AvailableValues = new List<string>();
                }

                return Request.CreateResponse(HttpStatusCode.OK, sqlActions);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Gets the SQL action link that the client can use to retrieve the results on the SQL operation.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the azure subscription in where the topology is (to be) deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>Returns a BlobURI with the SAS token so that client can render the results.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetSQLActionResultLink(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                HttpResponseMessage errorMessage;

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;

                TopologyInstanceTableItem topologyInstanceRow;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                int revision = this.GetRevisionParameter(parameters);

                if (revision < 0)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Get SQL Action Result call is missing an input parameter {0}", ServiceConstants.RevisionParameter);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, "GetSQLActionResultLink", revision, Library.Model.ServiceConstants.RevisionParameter);
                }

                Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempting to retrieve the SQL Query results for Topology Instance Id [{0}] with the Deployment Instance revision of [{1}]", topologyInstance, revision);

                // Check if the Revision that was passed is valid
                if (!this.GetDeploymentInstance(topologyInstanceRow, out deploymentInstance, out errorMessage, true, revision))
                {
                    return errorMessage;
                }

                // Check if the Revision that was passed has the following:
                // 1. Was successful
                // 2. Was a GenevaAction
                // 3. Was a Invoke SQL Query operation
                // 4. Was expected to return results
                DeploymentRequest.DeploymentAction deploymentAction;

                if (deploymentInstance.DeploymentState != DeploymentState.Finished ||
                    !Enum.TryParse(deploymentInstance.DeploymentAction, true, out deploymentAction) ||
                    deploymentAction != DeploymentRequest.DeploymentAction.ExecuteGenevaAction ||
                    !string.Equals(deploymentInstance.GetSQLActionOutput(), DeploymentConstants.InvokeSQLQueryResults, StringComparison.OrdinalIgnoreCase))
                {
                    Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, "The Deployment Instance with revision [{0}] Does not contain a valid SQL Query Results", revision);
                    return this.CreateErrorResponse(ServiceErrorCode.SQLQueryResultsNotAvailable);
                }

                string blobPath = deploymentInstance.CreateSQLQueryResultBlobPath(tenantId, azureSubscriptionId, topologyInstanceId, revision);

                CloudStorageAccount storageAccount = BlobHelper.GetStorageAccount(WellKnownStorageAccounts.DeploymentServiceStorage);

                TimeSpan sasExpiration = TimeSpan.FromHours(DeploymentServiceConfig.DownloadLinkExpirationInHours);

                string blobUriWithSas = BlobHelper.GetBlobSasUri(blobPath, storageAccount, DeploymentConstants.TopologyInstancesContainerName, sasExpiration);

                return Request.CreateResponse(HttpStatusCode.OK, blobUriWithSas);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Gets the SQL action link that the client can use to retrieve the results on the SQL operation.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the azure subscription in where the topology is (to be) deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>Returns a BlobURI with the SAS token so that client can render the results.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetSQLActionResult(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                HttpResponseMessage errorMessage;

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;

                TopologyInstanceTableItem topologyInstanceRow;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                int revision = this.GetRevisionParameter(parameters);

                if (revision < 0)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Get SQL Action Result call is missing an input parameter {0}", ServiceConstants.RevisionParameter);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, "GetSQLActionResultLink", revision, Library.Model.ServiceConstants.RevisionParameter);
                }

                Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempting to retrieve the SQL Query results for Topology Instance Id [{0}] with the Deployment Instance revision of [{1}]", topologyInstance, revision);

                // Check if the Revision that was passed is valid
                if (!this.GetDeploymentInstance(topologyInstanceRow, out deploymentInstance, out errorMessage, true, revision))
                {
                    return errorMessage;
                }

                DeploymentRequest.DeploymentAction deploymentAction;

                if (deploymentInstance.DeploymentState != DeploymentState.Finished)
                {
                    Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, "The Deployment Instance with revision [{0}] has not completed running.", revision);
                    return this.CreateErrorResponse(ServiceErrorCode.SQLQueryResultsNotAvailable);
                }

                SqlActionResponse response = new SqlActionResponse()
                {
                    IsFastActionResponse = false
                };

                CloudStorageAccount storageAccount = BlobHelper.GetStorageAccount(WellKnownStorageAccounts.DeploymentServiceStorage);
                TimeSpan sasExpiration = TimeSpan.FromHours(DeploymentServiceConfig.DownloadLinkExpirationInHours);

                if (Enum.TryParse(deploymentInstance.DeploymentAction, true, out deploymentAction) &&
                        deploymentAction == DeploymentRequest.DeploymentAction.ExecuteGenevaAction)
                {
                    response.IsSuccessful = deploymentInstance.DeploymentStatus == DeploymentApi.Model.DeploymentStatus.Succeeded;

                    if (string.Equals(deploymentInstance.GetSQLActionOutput(), DeploymentConstants.InvokeSQLCommand, StringComparison.OrdinalIgnoreCase) ||
                        string.Equals(deploymentInstance.GetSQLActionOutput(), DeploymentConstants.InvokeSQLQueryResults, StringComparison.OrdinalIgnoreCase))
                    {
                        string blobPath = deploymentInstance.CreateSQLQueryResultBlobPath(tenantId, azureSubscriptionId, topologyInstanceId, revision);
                        string blobUriWithSas = BlobHelper.GetBlobSasUri(blobPath, storageAccount, DeploymentConstants.TopologyInstancesContainerName, sasExpiration);
                        response.OutputObjectOrBlobLink = blobUriWithSas;

                        string errorMessageBlobPath = deploymentInstance.CreateSQLErrorMessageBlobPath(tenantId, azureSubscriptionId, topologyInstanceId, revision);
                        string errorMessageBlobUriWithSas = BlobHelper.GetBlobSasUri(errorMessageBlobPath, storageAccount, DeploymentConstants.TopologyInstancesContainerName, sasExpiration);
                        response.MessageOrBlobLink = errorMessageBlobUriWithSas;
                    }
                    else
                    {
                        // Action was neither a command or query
                        Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, "The Deployment Instance with revision [{0}] is not a SQL command or query", revision);
                        return this.CreateErrorResponse(ServiceErrorCode.SQLQueryResultsNotAvailable);
                    }
                }
                else
                {
                    // Revision doesn't reference any Geneva Actions
                    Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, "The Deployment Instance with revision [{0}] is not a valid Geneva action", revision);
                    return this.CreateErrorResponse(ServiceErrorCode.SQLQueryResultsNotAvailable);
                }

                return Request.CreateResponse(HttpStatusCode.OK, response);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Returns a list of metadata on operations performed on a topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the azure subscription in where the topology is deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>Returns an enumerable of table items.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.CSPReleaseValidation,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetTopologyInstanceHistory(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup? environmentGroup;

                string environmentGroupString = this.GetParameterOrDefault(parameters, Library.Model.ServiceConstants.EnvironmentGroupParameter, String.Empty);
                if (string.IsNullOrEmpty(environmentGroupString))
                {
                    // In this API method, unspecified environment group is indicated by a null parameter.
                    // Primary environment group is specified only by EnvironmentGroup.Primary.
                    environmentGroup = null;
                }
                else
                {
                    environmentGroup = EnvironmentGroupExtensions.GetEnvironmentGroupOrDefault(environmentGroupString);
                }

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Fetching all topology instance history table items for tenant [{0}] in azure subscription [{1}] and instance ID [{2}]",
                    tenantId,
                    azureSubscriptionId,
                    topologyInstanceId);

                IEnumerable<TopologyInstanceHistoryTableItem> tableRows = TopologyInstanceHistoryDAC.GetTopologyInstanceHistory(tenantId, topologyInstanceId, azureSubscriptionId, environmentGroup);

                if (tableRows == null)
                {
                    string message = string.Format(
                        CultureInfo.InvariantCulture,
                        "There are no topology instances matching tenant [{0}] subscription [{1}] instance ID [{2}] and environment group [{3}]",
                        tenantId,
                        azureSubscriptionId,
                        topologyInstanceId,
                        environmentGroup);

                    return this.CreateErrorResponse(HttpStatusCode.BadRequest, message);
                }

                // 1. Convert TopologyInstanceHistoryTableItem enumerable to user-friendly TopologyInstanceHistory enumerable
                // 2. Order by decreasing Operation ID (most recent first)
                // 3. Convert to List
                List<TopologyInstanceHistoryItem> history = tableRows.Select(item => item.ToHistoryItem()).OrderByDescending(item => item.Timestamp).ToList();

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Fetched [{0}] topology instance history table items for tenant [{1}] in azure subscription [{2}] instance ID [{3}] and environment group [{4}]",
                    history.Count(),
                    tenantId,
                    azureSubscriptionId,
                    topologyInstanceId,
                    environmentGroup);

                return Request.CreateResponse(HttpStatusCode.OK, history);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    exception,
                    "REQUEST: '{0}'",
                    this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Returns DR back up details for a tenant id.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the azure subscription in where the topology is deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>Returns an enumerable of table items.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetBackupDetails(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Fetching all back up details table items for tenant [{0}]in azure subscription [{1}] and instance ID [{2}]",
                    tenantId,
                    azureSubscriptionId,
                    topologyInstanceId);

                TopologyInstanceDRBackupTableItem topologyInstanceDRBackupTable = TopologyInstanceDRBackupDAC.GetTableItems(tenantId, azureSubscriptionId, topologyInstanceId);

                if (topologyInstanceDRBackupTable == null)
                {
                    string message = string.Format(
                        CultureInfo.InvariantCulture,
                        "There are no back up history matching tenant [{0}]in azure subscription [{1}] and instance ID [{2}]",
                    tenantId,
                    azureSubscriptionId,
                    topologyInstanceId);

                    return this.CreateErrorResponse(HttpStatusCode.NotFound, message);
                }


                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Fetched back up history table items for tenant [{0}]in azure subscription [{1}] and instance ID [{2}]",
                    tenantId,
                    azureSubscriptionId,
                    topologyInstanceId);

                //Converting table item to object.
                TopologyInstanceDRBackupItem topologyInstanceDRBackupItem = topologyInstanceDRBackupTable.ToObjectItem();

                return Request.CreateResponse(HttpStatusCode.OK, topologyInstanceDRBackupItem);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    exception,
                    "REQUEST: '{0}'",
                    this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Verifies that all the reply URLs for a given environment are configured correctly.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the azure subscription in where the topology is deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>Returns a bool value.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage VerifyReplyURL(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                HttpResponseMessage errorMessage;
                bool response = false;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                bool includeSegments = false;
                if (!parameters.ContainsKey(ServiceConstants.IncludeSegmentsParameter))
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.ServiceController, $"No value passed for includeSegmentsParam, using default false");
                }
                else
                {
                    bool? includeSegmentsParam = (bool?)parameters[ServiceConstants.IncludeSegmentsParameter];
                    includeSegments = includeSegmentsParam.HasValue && includeSegmentsParam.Value;
                }

                // Get topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out TopologyInstance topologyInstance, out errorMessage, out TopologyInstanceTableItem topologyInstanceRow))
                {
                    return errorMessage;
                }

                response = ServiceControllerHelper.VerifyEnvironmentUrl(topologyInstance, includeSegments);
                return Request.CreateResponse(HttpStatusCode.OK, response);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    exception,
                    "REQUEST: '{0}'",
                    this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Adds a reservation entry in DNS Lookup table for provided dns name (environment name).
        /// </summary>
        /// <param name="dnsZoneName">DNSZone underwhich the dnsname should be registered.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns> A HttpResponse based on the action carried out.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication)]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage AddDNSEntry([FromODataUri] string dnsZoneName, ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} request received. DNSZone : [{1}]", ServiceConstants.AddDNSEntry, dnsZoneName);
                if (string.IsNullOrEmpty(dnsZoneName))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} call is missing an input parameter", ServiceConstants.AddDNSEntry);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, ServiceConstants.AddDNSEntry, ServiceConstants.ParameterDNSZone, dnsZoneName);
                }

                DnsEntry dnsEntry = this.GetParameterOrDefault<DnsEntry>(parameters, DnsEntryParameter, null);

                if (dnsEntry == null || string.IsNullOrEmpty(dnsEntry.Name) || string.IsNullOrEmpty(dnsEntry.ProvisioningService) || string.IsNullOrEmpty(dnsEntry.Address))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} reservation call is missing an input parameter", ServiceConstants.AddDNSEntry);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidDNSEntryObject, ServiceConstants.AddDNSEntry, DnsEntryParameter);
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} Object Properties DNSName:{1} Address:{2} ProvisioningService:{3}", DnsEntryParameter, dnsEntry.Name, dnsEntry.Address, dnsEntry.ProvisioningService);

                ServiceErrorCode errorCode;
                DnsZone dnsZoneObj;
                DnsZoneManager zoneManager = new DnsZoneManager();
                if (!zoneManager.TryGetDnsZoneByName(dnsZoneName, out dnsZoneObj, out errorCode))
                {
                    return this.CreateErrorResponse(errorCode);
                }

                LookupManager lookupManager = new LookupManager(dnsZoneObj.ZoneName);

                if (lookupManager.CheckIfEntityExists(dnsEntry.Name, dnsEntry.ProvisioningService))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNS Name entry already exists in the lookup table DNSName:{0} DNSZone:{1} ProvisioningService:{2}.", dnsEntry.Name, dnsZoneObj, dnsEntry.ProvisioningService);

                    // if dns record set already exists in the DNS Server
                    if (this.IsExistingDNSRecord(dnsZoneObj, dnsEntry.Name))
                    {
                        if (!this.UpdateDNSRecord(dnsZoneObj, dnsEntry.Name, dnsEntry.Address))
                        {
                            return this.CreateErrorResponse(ServiceErrorCode.DnsRecordSetUpdateFailed, dnsEntry.Name);
                        }
                    }
                    else
                    {
                        if (!this.AddDNSRecord(dnsZoneObj, dnsEntry.Name, dnsEntry.Address))
                        {
                            return this.CreateErrorResponse(ServiceErrorCode.DnsRecordSetAddFailed, dnsEntry.Name);
                        }
                    }
                }
                else
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Lookup table entry doesn't exists for DNSName:{0} DNSZone:{1} ProvisioningService:{2}.", dnsEntry.Name, dnsZoneObj, dnsEntry.ProvisioningService);

                    // if lookup doesn't exists, DNSRecordset shouldn't exist as well
                    // if it DNSRecordset exists, it is most likely created by other provisioning service
                    if (this.IsExistingDNSRecord(dnsZoneObj, dnsEntry.Name))
                    {
                        return this.CreateErrorResponse(ServiceErrorCode.DnsNameAlreadyExists);
                    }

                    // Add lookup table entry
                    if (lookupManager.TryInsertEntity(dnsEntry.Name, dnsEntry.ProvisioningService))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNS Name entry added to the lookup table with DNSName:{0} under DNSZone:{1}.", dnsEntry.Name, dnsZoneObj);
                    }
                    else
                    {
                        return this.CreateErrorResponse(ServiceErrorCode.DnsNameAlreadyExistsInLookup, dnsEntry.Name);
                    }

                    if (!this.AddDNSRecord(dnsZoneObj, dnsEntry.Name, dnsEntry.Address))
                    {
                        return this.CreateErrorResponse(ServiceErrorCode.DnsRecordSetAddFailed, dnsEntry.Name);
                    }
                }

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Removes the reservation entry in DNS Lookup table for provided dns name (environment name).
        /// </summary>
        /// <param name="dnsZoneName">DNSZone underwhich the dnsname should be registered.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns> A HttpResponse based on the action carried out.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication)]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage RemoveDNSEntry([FromODataUri] string dnsZoneName, ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} request received. DNSZone : [{1}]", ServiceConstants.RemoveDNSEntry, dnsZoneName);
                if (string.IsNullOrEmpty(dnsZoneName))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} call is missing an input parameter", ServiceConstants.RemoveDNSEntry);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, ServiceConstants.RemoveDNSEntry, ServiceConstants.ParameterDNSZone, dnsZoneName);
                }

                DnsEntry dnsEntry = this.GetParameterOrDefault<DnsEntry>(parameters, DnsEntryParameter, null);

                if (dnsEntry == null || string.IsNullOrEmpty(dnsEntry.Name) || string.IsNullOrEmpty(dnsEntry.ProvisioningService))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} call is missing an input parameter", ServiceConstants.RemoveDNSEntry);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidDNSEntryObject, ServiceConstants.RemoveDNSEntry, DnsEntryParameter);
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} Object Properties DNSName:{1} Address:{2} ProvisioningService:{3}", DnsEntryParameter, dnsEntry.Name, dnsEntry.Address, dnsEntry.ProvisioningService);

                ServiceErrorCode errorCode;
                DnsZone dnsZoneObj;
                DnsZoneManager zoneManager = new DnsZoneManager();
                if (!zoneManager.TryGetDnsZoneByName(dnsZoneName, out dnsZoneObj, out errorCode))
                {
                    return this.CreateErrorResponse(errorCode);
                }

                LookupManager lookupManager = new LookupManager(dnsZoneObj.ZoneName);

                // if lookup entry already exists it can be established that entry was created by the same provisioning service
                if (lookupManager.CheckIfEntityExists(dnsEntry.Name, dnsEntry.ProvisioningService))
                {
                    this.RemoveDNSRecord(dnsZoneObj, dnsEntry.Name);

                    lookupManager.DeleteEntityIfExists(dnsEntry.Name, dnsEntry.ProvisioningService);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNS Name entry removed from the lookup table with DNSName:{0} under DNSZone {1}.", dnsEntry.Name, dnsZoneObj);
                }
                else
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Could not find Lookup entry with DNSName:{0} under DNSZone:{1} with ProvisioningService:{2}.", dnsEntry.Name, dnsZoneObj, dnsEntry.ProvisioningService);
                }

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Validates if a reservation entry in DNS Lookup table doesn't exist for a provided dns name.
        /// </summary>
        /// <param name="dnsZoneName">DNSZone underwhich the dnsname should be registered.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns> A HttpResponse based on the action carried out.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication)]
        public HttpResponseMessage ValidateDNSNameAvailable([FromODataUri] string dnsZoneName, ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, $"{ServiceConstants.ValidateDNSNameAvailable} request received. DNSZone : [{dnsZoneName}]");

                string dnsName = this.GetParameterOrDefault<string>(parameters, ServiceConstants.ParameterDNSName, null);

                if (string.IsNullOrEmpty(dnsZoneName))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, $"{ServiceConstants.ValidateDNSNameAvailable} call is missing an dnsZoneName parameter");
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, ServiceConstants.ValidateDNSNameAvailable, ServiceConstants.ParameterDNSZone, dnsZoneName);
                }

                if (string.IsNullOrEmpty(dnsName))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, $"{ServiceConstants.ValidateDNSNameAvailable} get call is missing an dnsName parameter");
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, ServiceConstants.ValidateDNSNameAvailable, ServiceConstants.ParameterDNSName, dnsName);
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, $"DNS Name:{dnsName} DNS Zone:{dnsZoneName}");

                ServiceErrorCode errorCode;
                DnsZone dnsZoneObj;
                DnsZoneManager zoneManager = new DnsZoneManager();
                if (!zoneManager.TryGetDnsZoneByName(dnsZoneName, out dnsZoneObj, out errorCode))
                {
                    // If DNS zone doesn't exist, this zone is not managed by the service instance.
                    return this.CreateErrorResponse(errorCode);
                }

                LookupManager lookupManager = new LookupManager(dnsZoneObj.ZoneName);

                if (!lookupManager.CheckIfEntityExists(dnsName))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, $"Lookup table entry doesn't exists for DNSName:{dnsName} DNSZone:{dnsZoneObj}.");

                    return Request.CreateResponse(HttpStatusCode.OK);
                }
                else
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, $"DNS Name entry exists in the lookup table DNSName:{dnsName} DNSZone:{dnsZoneObj}.");

                    return this.CreateErrorResponse(ServiceErrorCode.DnsNameAlreadyExistsInLookup, dnsName);
                }
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Check whether provided DNS zone exists or not.
        /// </summary>
        /// <param name="dnsZoneName">DNSZone Name.</param>
        /// <returns> A HttpResponse based on the action carried out.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication)]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage ValidateDnsZone([FromODataUri] string dnsZoneName)
        {
            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, $"[{ServiceConstants.ValidateDnsZone}] request received. DNSZone : [{dnsZoneName}]");
                if (string.IsNullOrEmpty(dnsZoneName))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, $"[{ServiceConstants.ValidateDnsZone}] call is missing an input parameter");
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, ServiceConstants.ValidateDnsZone, ServiceConstants.ParameterDNSZone, dnsZoneName);
                }

                ServiceErrorCode errorCode;
                DnsZone dnsZoneObj;
                DnsZoneManager zoneManager = new DnsZoneManager();
                if (!zoneManager.TryGetDnsZoneByName(dnsZoneName, out dnsZoneObj, out errorCode))
                {
                    return this.CreateErrorResponse(HttpStatusCode.NotFound, errorCode, ServiceConstants.ValidateDnsZone);
                }

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, $"REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Removes the dns record from Azure if it is found to be dangling.
        /// </summary>
        /// <param name="dnsZoneName">DNSZone underwhich the dnsname should be registered.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns> A HttpResponse based on the action carried out.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication)]
        public HttpResponseMessage RemoveDanglingDNSRecord([FromODataUri] string dnsZoneName, ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} request received. DNSZone : [{1}]", ServiceConstants.RemoveDanglingDNSRecord, dnsZoneName);
                if (string.IsNullOrEmpty(dnsZoneName))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} call is missing an input parameter", ServiceConstants.RemoveDanglingDNSRecord);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, ServiceConstants.RemoveDanglingDNSRecord, ServiceConstants.ParameterDNSZone, dnsZoneName);
                }

                DnsEntry dnsEntry = this.GetParameterOrDefault<DnsEntry>(parameters, DnsEntryParameter, null);
                bool skipLookupTableCheck = this.GetParameterOrDefault<bool>(parameters, SkipLookupTableCheck, false);

                if (dnsEntry == null || string.IsNullOrEmpty(dnsEntry.Name))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} call is missing an input parameter", ServiceConstants.RemoveDanglingDNSRecord);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidDNSEntryObject, ServiceConstants.RemoveDanglingDNSRecord, DnsEntryParameter);
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} Object Properties DNSName:{1} Address:{2} ProvisioningService:{3} SkipLookupTableCheck:{4}", DnsEntryParameter, dnsEntry.Name, dnsEntry.Address, dnsEntry.ProvisioningService, skipLookupTableCheck);

                ServiceErrorCode errorCode;
                DnsZone dnsZoneObj;
                DnsZoneManager zoneManager = new DnsZoneManager();
                if (!zoneManager.TryGetDnsZoneByName(dnsZoneName, out dnsZoneObj, out errorCode))
                {
                    return this.CreateErrorResponse(errorCode);
                }

                string hostName = string.Format("{0}.{1}", dnsEntry.Name, dnsZoneName);
                LookupManager lookupManager = new LookupManager(dnsZoneObj.ZoneName);
                HttpStatusCode httpStatusCode = HttpStatusCode.BadRequest;
                if (lookupManager.CheckIfEntityExists(dnsEntry.Name, dnsEntry.ProvisioningService) || skipLookupTableCheck)
                {
                    if (!this.IsHostNameResolved(hostName))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNS record {0} could not be resolved. Deleting from DNS source.", hostName);
                        this.RemoveDNSRecord(dnsZoneObj, dnsEntry.Name);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNS Resource removed from Azure with DNSName:{0} under DNSZone {1}.", dnsEntry.Name, dnsZoneObj);
                        httpStatusCode = HttpStatusCode.OK;
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Skipping as hostname {0} was resolved.", hostName);
                    }
                }
                else
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Could not find Lookup entry with DNSName:{0} under DNSZone:{1} with ProvisioningService:{2}.", dnsEntry.Name, dnsZoneObj, dnsEntry.ProvisioningService);
                }

                return Request.CreateResponse(httpStatusCode);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Removes the stub dns record from Azure, DB and topology.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns> A HttpResponse based on the action carried out.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication)]
        public HttpResponseMessage RemoveStubDNSRecord(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                HttpResponseMessage errorMessage;
                TopologyInstance topologyInstance = null;
                TopologyInstanceTableItem topologyInstanceRow = null;

                // Check if the environment group is primary
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                // Get the topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                var stubDnsRecord = topologyInstance.DnsRecordSets.FirstOrDefault(c => String.Equals(c.Identifier, CommonCustomizationNames.DNSRecordSetStub, StringComparison.OrdinalIgnoreCase));
                if (stubDnsRecord != null)
                {
                    ServiceErrorCode errorCode;
                    DnsZone dnsZoneObj;
                    DnsZoneManager zoneManager = new DnsZoneManager();
                    if (!zoneManager.TryGetDnsZoneByName(stubDnsRecord.ZoneName, out dnsZoneObj, out errorCode))
                    {
                        return this.CreateErrorResponse(errorCode);
                    }

                    LookupManager lookupManager = new LookupManager(dnsZoneObj.ZoneName);
                    // if lookup entry already exists it can be established that entry was created by the same provisioning service
                    if (lookupManager.TryGetLookupEntity(stubDnsRecord.Name, out LookupTableItem lookupEntity))
                    {
                        this.RemoveDNSRecord(dnsZoneObj, stubDnsRecord.Name);

                        lookupManager.DeleteEntityIfExists(stubDnsRecord.Name, lookupEntity.ProvisioningService);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNS Name entry removed from the lookup table with DNSName:{0} under DNSZone {1}.", stubDnsRecord.Name, dnsZoneObj);
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Could not find Lookup entry with DNSName:{0} under DNSZone:{1}.", stubDnsRecord.Name, dnsZoneObj);
                    }
                }

                //Delete from topology
                topologyInstance.RemoveStubDnsRecordSet();
                this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to prepare for migration of IaaS Environment to Service Fabric.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage PrepareMigrateToSF(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.PrepareMigrationToIaas;
            HttpResponseMessage errorMessage;
            DeploymentInstance deploymentInstance = null;
            TopologyInstance topologyInstance = null;
            TopologyInstanceTableItem topologyInstanceRow = null;
            Uri deploymentInstanceBlobUri;

            const string roleContributor = "Contributor";

            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'", ServiceConstants.PrepareMigrateToSF, topologyInstanceId, azureSubscriptionId, tenantId);

                // Get the topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                // Get the deployment instance
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (!topologyInstance.ShouldUseAzureResourceManager())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Migrate to SF is only supported on topologies deployed via ARM.");
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequireTopologyWithARMSupport);
                }

                // Tenant registeration data
                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

                // Give Service Fabric Deployment Service access to the resource group
                using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager(topologyInstance.GetResourceGroup()))
                {
                    string scope = String.Format(CultureInfo.InvariantCulture, "/subscriptions/{0}", azureSubscriptionId);

                    var resourceGroup = manager.Resource.Value.GetResourceGroup();
                    var roleDefinitions = manager.Authorize.Value.Proxy.RoleDefinitions.ListWithHttpMessagesAsync(scope).Result.Body;
                    var role = roleDefinitions?.Where(x => x.Properties.RoleName == roleContributor).FirstOrDefault();

                    if (role == null)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, $"Failed to retrieve role definitions for scope [{scope}].", ServiceConstants.PrepareMigrateToSF, topologyInstance, deploymentInstance.DeploymentStatus);
                        return this.CreateErrorResponse(ServiceErrorCode.OperationFailed_NoValidRoleAvailable, action);
                    }

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Applying 'Contributor' access for Service Fabric Deployment Service, Application Id: {0}, to the Resource Group: {1}, in Subscription: {2}...", DeploymentServiceConfig.ServiceFabricDeploymentServiceApplicationId, resourceGroup.Name, azureSubscriptionId);

                    var props = new Azure.Management.Authorization.Models.RoleAssignmentProperties()
                    {
                        PrincipalId = DeploymentServiceConfig.ServiceFabricDeploymentServiceApplicationId,
                        RoleDefinitionId = role.Id,
                    };

                    manager.Authorize.Value.Proxy.RoleAssignments.Create($"/subscriptions/{azureSubscriptionId}/resourceGroups/{resourceGroup.Name}", Guid.NewGuid().ToString(), props);
                }

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to execute {0} on topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'. ErrorCode='{4}'",
                    ServiceConstants.PrepareMigrateToSF,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorResponseMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorResponseMessage);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorResponseMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to execute {0} on topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'.",
                    ServiceConstants.PrepareMigrateToSF,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to Enable migration of IaaS Environment to Service Fabric.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage MigrateToSF(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.MigrationToIaas;
            HttpResponseMessage errorMessage;
            DeploymentInstance deploymentInstance = null;
            TopologyInstance topologyInstance = null;
            TopologyInstanceTableItem topologyInstanceRow = null;
            Uri deploymentInstanceBlobUri;

            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'", ServiceConstants.MigrateToSF, topologyInstanceId, azureSubscriptionId, tenantId);

                // Get the topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                // Get the deployment instance
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (!topologyInstance.ShouldUseAzureResourceManager())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Migrate to SF is only supported on topologies deployed via ARM.");
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequireTopologyWithARMSupport);
                }

                // We need to check deployment is in succeeded status
                if (deploymentInstance.DeploymentStatus != Model.DeploymentStatus.Succeeded)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in status [{2}].", ServiceConstants.MigrateToSF, topologyInstance, deploymentInstance.DeploymentStatus);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresSucceededStatus, action);
                }

                LookupManager lookupManager;
                HttpResponseMessage stopResult;
                var dnsRecord = topologyInstance.DnsRecordSets.FirstOrDefault(c => String.Equals(c.Identifier, ServiceConstants.AOSPrimaryRecordSetId, StringComparison.OrdinalIgnoreCase));
                var soapRecord = topologyInstance.DnsRecordSets.FirstOrDefault(c => String.Equals(c.Identifier, ServiceConstants.AOSSoapRecordSetId, StringComparison.OrdinalIgnoreCase));

                if (dnsRecord == null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNSRecord with [{0}] not found for topology instance [{1}].", ServiceConstants.AOSPrimaryRecordSetId, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.DNSRecordNotFound, ServiceConstants.AOSPrimaryRecordSetId, topologyInstance.InstanceId);
                }

                if (soapRecord == null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNSRecord with [{0}] not found for topology instance [{1}].", ServiceConstants.AOSSoapRecordSetId, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.DNSRecordNotFound, ServiceConstants.AOSSoapRecordSetId, topologyInstance.InstanceId);
                }

                lookupManager = new LookupManager(dnsRecord.ZoneName);
                if (!lookupManager.CheckIfEntityExists(dnsRecord.Name))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNS name [{0}] not found in the lookup table.", dnsRecord.Name);
                    return this.CreateErrorResponse(ServiceErrorCode.DNSNameNotFoundInLookupTable, topologyInstance.InstanceId);
                }

                if (!lookupManager.CheckIfEntityExists(soapRecord.Name))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNS name [{0}] not found in the lookup table.", soapRecord.Name);
                    return this.CreateErrorResponse(ServiceErrorCode.DNSNameNotFoundInLookupTable, topologyInstance.InstanceId);
                }

                // Check if we have multiple version of data encryption and signing cert. Return error if true.
                bool installMultipleCertificateVersionsInSF;
                if (topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.InstallMultipleCertificateVersionsInSF, out installMultipleCertificateVersionsInSF) && installMultipleCertificateVersionsInSF)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "InstallMultipleCertificateVersionsInSF customization is enabled for topology: {0}.", topologyInstance.InstanceId);
                }
                else
                {
                    CertificateDefinition dataEncryptionCert = topologyInstance.Certificates.FirstOrDefault(cert => string.Equals(cert.Identifier, CommonCertificateIdentifiers.DataEncryptionCertificate, StringComparison.OrdinalIgnoreCase));
                    if (dataEncryptionCert != null)
                    {
                        var secrets = KeyVaultClient.Instance.GetAllSecretVersions(dataEncryptionCert.KeyVaultableRawData.SecretUri);
                        if (secrets.Count() > 1)
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Multiple versions of data encryption cert found. Total: {0}", secrets.Count());
                            return this.CreateErrorResponse(ServiceErrorCode.MultipleVersionsOfCertificateFound, CommonCertificateIdentifiers.DataEncryptionCertificate, topologyInstance.InstanceId, secrets.Count());
                        }
                    }

                    CertificateDefinition dataSigningCert = topologyInstance.Certificates.FirstOrDefault(cert => string.Equals(cert.Identifier, CommonCertificateIdentifiers.DataSigningCertificate, StringComparison.OrdinalIgnoreCase));
                    if (dataSigningCert != null)
                    {
                        var secrets = KeyVaultClient.Instance.GetAllSecretVersions(dataSigningCert.KeyVaultableRawData.SecretUri);
                        if (secrets.Count() > 1)
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Multiple versions of data signing cert found. Total: {0}", secrets.Count());
                            return this.CreateErrorResponse(ServiceErrorCode.MultipleVersionsOfCertificateFound, CommonCertificateIdentifiers.DataSigningCertificate, topologyInstance.InstanceId, secrets.Count());
                        }
                    }
                }

                stopResult = this.StopTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, parameters, DeploymentState.MigratingToSF);
                if (stopResult.IsSuccessStatusCode)
                {
                    lookupManager.UpdateProvisioningService(dnsRecord.Name, ServiceConstants.ProvisioningServiceSF);
                    lookupManager.UpdateProvisioningService(soapRecord.Name, ServiceConstants.ProvisioningServiceSF);
                }

                return stopResult;
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to execute {0} on topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'. ErrorCode='{4}'",
                    ServiceConstants.MigrateToSF,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorResponseMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorResponseMessage);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorResponseMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to execute {0} on topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'.",
                    ServiceConstants.MigrateToSF,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to rollback migration of IaaS Environment to Service Fabric.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage RollbackSfMigrationToIaas(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            ServiceErrorCode errorCode;
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.RollbackSfMigrationToIaas;
            HttpResponseMessage errorMessage;
            DeploymentInstance deploymentInstance = null;
            TopologyInstance topologyInstance = null;
            TopologyInstanceTableItem topologyInstanceRow = null;
            Uri deploymentInstanceBlobUri;

            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'", ServiceConstants.RollbackSfMigrationToIaas, topologyInstanceId, azureSubscriptionId, tenantId);

                // Get the topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                // Get the deployment instance
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                // We need to validate deployment is in MigratedToSF state
                if (deploymentInstance.DeploymentState != Model.DeploymentState.MigratedToSF)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", ServiceConstants.RollbackSfMigrationToIaas, topologyInstance, deploymentInstance.DeploymentStatus);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresMigratedToSFStatus, action);
                }

                // We need to check deployment is in succeeded status
                if (deploymentInstance.DeploymentStatus != Model.DeploymentStatus.Succeeded)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in status [{2}].", ServiceConstants.MigrateToSF, topologyInstance, deploymentInstance.DeploymentStatus);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresSucceededStatus, action);
                }

                // Initialize DNS objects
                LookupManager lookupManager;
                DnsZone dnsZoneObj;
                DnsZoneManager zoneManager = new DnsZoneManager();
                DnsRecordSet dnsRecord = topologyInstance.DnsRecordSets.FirstOrDefault(c => String.Equals(c.Identifier, ServiceConstants.AOSPrimaryRecordSetId, StringComparison.OrdinalIgnoreCase));
                DnsRecordSet soapRecord = topologyInstance.DnsRecordSets.FirstOrDefault(c => String.Equals(c.Identifier, ServiceConstants.AOSSoapRecordSetId, StringComparison.OrdinalIgnoreCase));

                // Validate DNS records exist on this topology instance
                if (dnsRecord == null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNSRecord with [{0}] not found for topology instance [{1}].", ServiceConstants.AOSPrimaryRecordSetId, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.DNSRecordNotFound, ServiceConstants.AOSPrimaryRecordSetId, topologyInstance.InstanceId);
                }

                if (soapRecord == null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNSRecord with [{0}] not found for topology instance [{1}].", ServiceConstants.AOSSoapRecordSetId, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.DNSRecordNotFound, ServiceConstants.AOSSoapRecordSetId, topologyInstance.InstanceId);
                }

                // Validate DNS zone can be retrieved
                if (!zoneManager.TryGetDnsZoneByName(dnsRecord.ZoneName, out dnsZoneObj, out errorCode))
                {
                    return this.CreateErrorResponse(errorCode);
                }

                // Validate DNS entities are registered
                lookupManager = new LookupManager(dnsRecord.ZoneName);

                if (!lookupManager.CheckIfEntityExists(dnsRecord.Name))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNS name [{0}] not found in the lookup table.", dnsRecord.Name);
                    return this.CreateErrorResponse(ServiceErrorCode.DNSNameNotFoundInLookupTable, topologyInstance.InstanceId);
                }

                if (!lookupManager.CheckIfEntityExists(soapRecord.Name))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNS name [{0}] not found in the lookup table.", soapRecord.Name);
                    return this.CreateErrorResponse(ServiceErrorCode.DNSNameNotFoundInLookupTable, topologyInstance.InstanceId);
                }

                // Create Deployment request
                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                // Get task name
                string taskDefinitionName;
                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                    taskDefinitionName = DeploymentManagementPipedMasterWorkflow.TaskNameConstant;
                }
                else
                {
                    taskDefinitionName = DeploymentManagementMasterWorkflow.TaskNameConstant;
                }

                // Mark DNS as belonging to IaaS
                var updated = lookupManager.UpdateProvisioningService(dnsRecord.Name, null);
                if (!updated)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Failed to update ownership for DNS entry named: [{0}].", dnsRecord.Name);
                    return this.CreateErrorResponse(ServiceErrorCode.DnsRecordSetUpdateFailed, dnsRecord.Name);
                }

                updated = lookupManager.UpdateProvisioningService(soapRecord.Name, null);
                if (!updated)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Failed to update ownership for DNS entry named: [{0}].", soapRecord.Name);
                    return this.CreateErrorResponse(ServiceErrorCode.DnsRecordSetUpdateFailed, soapRecord.Name);
                }

                // Re-Start
                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, taskDefinitionName, out errorMessage, DeploymentState.Starting))
                {
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                    return errorMessage;
                }

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to execute {0} on topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'. ErrorCode='{4}'",
                    ServiceConstants.MigrateToSF,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorResponseMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorResponseMessage);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorResponseMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to execute {0} on topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'.",
                    ServiceConstants.MigrateToSF,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to trigger workflow for disaster recovery backup.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action which contains Environment Group.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage DisasterRecoveryBackup(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.DisasterRecoveryBackup;
            HttpResponseMessage errorMessage;
            DeploymentInstance deploymentInstance = null;
            TopologyInstance topologyInstance = null;
            TopologyInstanceTableItem topologyInstanceRow = null;
            Uri deploymentInstanceBlobUri;

            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Request started for Disaster Recovery Backup Workflow");

                // Check if the environment group is primary
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                bool isForceStartBackup = parameters.ContainsKey(ForceStartBackup) ? (bool)parameters[ForceStartBackup] : false;
                if (environmentGroup != EnvironmentGroup.Primary)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Topology [{0}] does not belong to Primary Environment Group.", topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresExistingEnvironmentGroup, EnvironmentGroup.Primary.ToString());
                }

                // Get the topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                // Check if the topology is enabled for DR
                if (!topologyInstance.IsDisasterRecoveryEnabled())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Topology [{0}] is not enabled for disaster recovery.", topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresDisasterRecoveryEnabled);
                }

                if (!topologyInstance.ShouldUseAzureResourceManager())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to perform a back up operation on RDFE that is not supported");
                    return this.CreateErrorResponse(ServiceErrorCode.DisasterRecoveryBackupOperationNotSupported);
                }

                // Get the deployment instance
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                // We need to further check if this should apply to staging environment, depending on the current state
                if (deploymentInstance.DeploymentState != DeploymentState.Finished)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, action);
                }

                // We need to check deployment is in succeeded status
                if (deploymentInstance.DeploymentStatus != Model.DeploymentStatus.Succeeded)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in status [{2}].", action, topologyInstance, deploymentInstance.DeploymentStatus);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresSucceededStatus, action);
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                if (isForceStartBackup)
                {
                    deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                    deploymentInstance.Initialize(topologyInstance);
                    deploymentInstance.RestartAction = action.ToString();

                    DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                    if (!this.TryScheduleTaskWithoutRollback(request, DeploymentServiceVMBackupWorkflow.TaskNameConstant, DeploymentServiceVMBackupWorkflow.GenerateTaskName(request), out errorMessage))
                    {
                        this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                        this.OnValidationFailed(topologyInstance, tenantRegistration, action, topologyInstance);

                        return errorMessage;
                    }
                }
                else
                {
                    DeploymentServiceVMBackupWorkflow.ScheduleVMBackup(tenantRegistration, topologyInstance, supressException: false);
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Request completed for Disaster Recovery Backup Workflow");
                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to execute backup on topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorResponseMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorResponseMessage);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorResponseMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to execute backup on topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to trigger workflow for CDS configuration provisioning a new CDS environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action which contains Environment Group.</param>
        /// <returns>An HTTP response message.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage ConfigureNewCDS(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                string cdsEnvironmentTemplate = this.GetParameterOrDefault(parameters, ServiceConstants.ParameterCdsEnvironmentTemplate, String.Empty);
                var cdsEnvironmentType = this.GetParameterOrDefault<CdsEnvironmentType>(parameters, ServiceConstants.ParameterCdsEnvironmentType, CdsEnvironmentType.None);
                string cdsCurrencyCode = this.GetParameterOrDefault(parameters, ServiceConstants.ParameterCdsEnvironmentCurrencyCode, string.Empty);
                string cdsLanguageCode = this.GetParameterOrDefault(parameters, ServiceConstants.ParameterCdsEnvironmentLanguageCode, string.Empty);
                bool runDualWriteSteps = this.GetParameterOrDefault<bool>(parameters, ServiceConstants.ParameterRunDualWriteSteps, false);

                // Get the topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out TopologyInstance topologyInstance, out HttpResponseMessage errorMessage, out TopologyInstanceTableItem topologyInstanceRow))
                {
                    return errorMessage;
                }

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    $"Requesting CDS configuration: tenant id: [{tenantId}], azure subscription id: [{azureSubscriptionId}], topology instance id: [{topologyInstanceId}], environment group: [{environmentGroup}].");

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    $"CDS environment parameters: template: [{cdsEnvironmentTemplate}], environment sku: [{cdsEnvironmentType}].");

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ConfigureCDS;

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                DeploymentItem cdsEnvironmentItem = topologyInstance.GetCdsEnvironmentItem();
                if (cdsEnvironmentItem == null)
                {
                    cdsEnvironmentItem = CdsConfigurationHelper.CreateCdsEnvironmentDeploymentItem(topologyInstance);
                }

                CdsConfigurationStep? cdsConfigurationStep = cdsEnvironmentItem.GetCdsConfigurationStep();
                CdsConfigurationStepStatus? cdsConfigurationStepStatus = cdsEnvironmentItem.GetCdsConfigurationStepStatus();

                bool isStatusCorrect =
                    (cdsConfigurationStep == null && cdsConfigurationStepStatus == null) ||
                    (cdsConfigurationStep == CdsConfigurationStep.CreateEnvironment && cdsConfigurationStepStatus == CdsConfigurationStepStatus.Completed);

                if (!isStatusCorrect)
                {
                    errorMessage = this.CreateErrorResponse($"Configure CDS operation is not allowed in this steps/status: [{cdsConfigurationStep}]/[{cdsConfigurationStepStatus}]. Topology instance: [{topologyInstance}].");
                    return errorMessage;
                }

                cdsEnvironmentItem.SetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentConfigure, true);
                cdsEnvironmentItem.SetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentCreateNew, true);
                cdsEnvironmentItem.SetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentRunDualWriteStepsInCdsConfiguration, runDualWriteSteps);

                // Set type and template as is, they may be overriden with default values.
                cdsEnvironmentItem.SetCustomizationValue(CommonCustomizationNames.CdsEnvironmentType, cdsEnvironmentType.ToString());
                cdsEnvironmentItem.SetCustomizationValue(CommonCustomizationNames.CdsEnvironmentCdsTemplate, cdsEnvironmentTemplate);

                cdsEnvironmentItem.SetCustomizationValue(CommonCustomizationNames.CdsEnvironmentCurrencyCode, cdsCurrencyCode.ToString());
                cdsEnvironmentItem.SetCustomizationValue(CommonCustomizationNames.CdsEnvironmentLanguageCode, cdsLanguageCode.ToString());

                CdsConfigurationHelper.SetCdsEnvironmentDefaultValues(topologyInstance);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

                if (!DeploymentServiceCDSConfigurationWorkflow.ScheduleCdsConfigurationSilent(tenantRegistration, topologyInstance, out string message))
                {
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.UnableToScheduleTaskDefinition, message);
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, topologyInstance);

                    return errorMessage;
                }
                else
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        $"Requested CDS configuration: tenant id: [{tenantId}], azure subscription id: [{azureSubscriptionId}], topology instance id: [{topologyInstanceId}], environment group: [{environmentGroup}]");

                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, $"REQUEST: '{this.Request.RequestUri}'");
                throw;
            }
        }

        /// <summary>
        /// Action used to trigger workflow for CDS configuration provisioning a new CDS environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action which contains Environment Group.</param>
        /// <returns>An HTTP response message.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage ResumeConfigureCDS(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                bool runDualWriteSteps = this.GetParameterOrDefault<bool>(parameters, ServiceConstants.ParameterRunDualWriteSteps, false);

                // Get the topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out TopologyInstance topologyInstance, out HttpResponseMessage errorMessage, out TopologyInstanceTableItem topologyInstanceRow))
                {
                    return errorMessage;
                }

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    $"Requesting CDS configuration: tenant id: [{tenantId}], azure subscription id: [{azureSubscriptionId}], topology instance id: [{topologyInstanceId}], environment group: [{environmentGroup}].");

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ConfigureCDS;

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                DeploymentItem cdsEnvironmentItem = topologyInstance.GetCdsEnvironmentItem();

                if (cdsEnvironmentItem == null)
                {
                    errorMessage = this.CreateErrorResponse($"Resume CDS environment operation is not allowed because it hasn't been started yet. CDS environment deployment item is empty. Topology instance: [{topologyInstance}].");
                    return errorMessage;
                }

                bool configureCds = cdsEnvironmentItem.GetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentConfigure);

                CdsConfigurationStep? cdsConfigurationStep = cdsEnvironmentItem.GetCdsConfigurationStep();
                CdsConfigurationStepStatus? cdsConfigurationStepStatus = cdsEnvironmentItem.GetCdsConfigurationStepStatus();

                if (configureCds == false || cdsConfigurationStepStatus != CdsConfigurationStepStatus.Failed)
                {
                    errorMessage = this.CreateErrorResponse($"Resume CDS environment operation is not allowed because some parameters are wrong in the topology. Cds configuration step/status: [{cdsConfigurationStep}]/[{cdsConfigurationStepStatus}]. DoConfigure: [{configureCds}]. Topology instance: [{topologyInstance}].");
                    return errorMessage;
                }

                // Set values to customization group.
                cdsEnvironmentItem.SetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentRunDualWriteStepsInCdsConfiguration, runDualWriteSteps);

                // checking the populated parameters from previous run
                string location = cdsEnvironmentItem.GetCustomizationValueNotNullOrWhitespace(CommonCustomizationNames.CdsEnvironmentLocation);
                string displayName = cdsEnvironmentItem.GetCustomizationValueNotNullOrWhitespace(CommonCustomizationNames.CdsEnvironmentDisplayName);
                string template = cdsEnvironmentItem.GetCustomizationValueNotNullOrWhitespace(CommonCustomizationNames.CdsEnvironmentCdsTemplate);
                string type = cdsEnvironmentItem.GetCustomizationValueNotNullOrWhitespace(CommonCustomizationNames.CdsEnvironmentType);

                // Removing previous error message
                CdsConfigurationHelper.SetCdsConfigurationError(cdsEnvironmentItem, String.Empty);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

                if (!DeploymentServiceCDSConfigurationWorkflow.ScheduleCdsConfigurationSilent(tenantRegistration, topologyInstance, out string message))
                {
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.UnableToScheduleTaskDefinition, message);
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, topologyInstance);

                    return errorMessage;
                }
                else
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        $"Requested CDS configuration: tenant id: [{tenantId}], azure subscription id: [{azureSubscriptionId}], topology instance id: [{topologyInstanceId}], environment group: [{environmentGroup}]");

                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, $"REQUEST: '{this.Request.RequestUri}'");
                throw;
            }
        }

        /// <summary>
        /// Action used to trigger workflow for CDS configuration when using existing CDS environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action which contains Environment Group.</param>
        /// <returns>An HTTP response message.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage ConfigureExistingCDS(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                string cdsEnvironmentId = this.GetParameterOrDefault(parameters, ServiceConstants.ParameterCdsEnvironmentId, String.Empty);

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    $"Requesting CDS configuration: tenant id: [{tenantId}], azure subscription id: [{azureSubscriptionId}], topology instance id: [{topologyInstanceId}], environment group: [{environmentGroup}].");

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    $"CDS environment parameters: CDS environment ID: [{cdsEnvironmentId}].");

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ConfigureCDS;

                // Get the topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out TopologyInstance topologyInstance, out HttpResponseMessage errorMessage, out TopologyInstanceTableItem topologyInstanceRow))
                {
                    return errorMessage;
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                CdsConfigurationHelper.CleanUpCdsMetadata(topologyInstance);
                DeploymentItem cdsEnvironmentItem = CdsConfigurationHelper.CreateCdsEnvironmentDeploymentItem(topologyInstance);

                cdsEnvironmentItem.SetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentConfigure, true);
                cdsEnvironmentItem.SetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentCreateNew, false);
                cdsEnvironmentItem.SetCustomizationValue(CommonCustomizationNames.CdsEnvironmentId, cdsEnvironmentId);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

                if (!DeploymentServiceCDSConfigurationWorkflow.ScheduleCdsConfigurationSilent(tenantRegistration, topologyInstance, out string message))
                {
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.UnableToScheduleTaskDefinition, message);
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, topologyInstance);

                    return errorMessage;
                }
                else
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        $"Requested CDS configuration: tenant id: [{tenantId}], azure subscription id: [{azureSubscriptionId}], topology instance id: [{topologyInstanceId}], environment group: [{environmentGroup}]");

                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, $"REQUEST: '{this.Request.RequestUri}'");
                throw;
            }
        }

        /// <summary>
        /// Creates a CDS environment for the topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action which contains Environment Group.</param>
        /// <returns>An HTTP response message.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication)]
        public HttpResponseMessage CreateCdsEnvironment(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                HttpResponseMessage errorMessage;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                // Get topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out TopologyInstance topologyInstance, out errorMessage, out TopologyInstanceTableItem topologyInstanceRow))
                {
                    return errorMessage;
                }

                // F&O environment status should be Finished / Succeeded.
                if (topologyInstance.DeploymentState != DeploymentState.Finished ||
                    topologyInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.Succeeded)
                {
                    errorMessage = this.CreateErrorResponse($"Create CDS environment operation is not allowed because state / status of deployment is [{topologyInstance.DeploymentState}]/[{topologyInstance.DeploymentStatus}]. Topology instance: [{topologyInstance}].");
                    return errorMessage;
                }

                DeploymentItem cdsEnvironmentItem = topologyInstance.GetCdsEnvironmentItem();
                CdsConfigurationStep? cdsConfigurationStep = cdsEnvironmentItem.GetCdsConfigurationStep();
                CdsConfigurationStepStatus? cdsConfigurationStepStatus = cdsEnvironmentItem.GetCdsConfigurationStepStatus();

                if (cdsConfigurationStep == null && cdsConfigurationStepStatus == null)
                {
                    Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"State is not started as expected.");
                }
                else
                {
                    errorMessage = this.CreateErrorResponse($"Create CDS environment operation is not allowed because step / status of CDS environment is [{cdsConfigurationStep}]/[{cdsConfigurationStepStatus}]. Use resume operation instead. Topology instance: [{topologyInstance}].");
                    return errorMessage;
                }

                Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Uploading topology backup.");
                this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, ServiceConstants.CreateCdsEnvironmentActionName);

                if (cdsEnvironmentItem == null)
                {
                    Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Cds deployment item is not found. Creating a new one.");

                    cdsEnvironmentItem = CdsConfigurationHelper.CreateCdsEnvironmentDeploymentItem(topologyInstance);
                }

                string aadTenantId = CdsConfigurationHelper.GetAadTenantId(tenantId, topologyInstance);
                string axEndpointHost = new Uri(topologyInstance.GetAosApplicationEndpoint()).Host;
                CdsEnvironment cdsEnvironmentFromDi = CdsFacade.GetDataIntegratorLinkedCdsEnvironment(aadTenantId, axEndpointHost);
                if (cdsEnvironmentFromDi != null)
                {
                    Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Found a linked CDS environment from DI: [{cdsEnvironmentFromDi.Name} / {cdsEnvironmentFromDi.Properties?.DisplayName}].");

                    // If we have a DI linked environment, than just populate it in the topology.
                    cdsEnvironmentItem.SetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentConfigure, true);
                    cdsEnvironmentItem.SetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentCreateNew, false);
                    cdsEnvironmentItem.SetCdsEnvironment(cdsEnvironmentFromDi);
                    cdsEnvironmentItem.SetCdsInstance(cdsEnvironmentFromDi.Properties.LinkedEnvironmentMetadata);
                    CdsConfigurationHelper.SetCdsConfigurationStatus(cdsEnvironmentItem, CdsConfigurationStep.Finished, CdsConfigurationStepStatus.Completed);

                    Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Finished updating the topology with DI linked enviroment.");
                }
                else
                {
                    Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Creating default CDS environment based on topology data.");

                    // We do not consider creating environment as part of CDS configuration flow.
                    cdsEnvironmentItem.SetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentConfigure, false);
                    cdsEnvironmentItem.SetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentCreateNew, true);

                    // setting the CDS type based on current FinOps type. There is an issue where topologies have incorrect value.
                    cdsEnvironmentItem.SetCustomizationValue(CommonCustomizationNames.CdsEnvironmentType, CdsConfigurationHelper.GetCdsEnvironmentType(topologyInstance).ToString());
                    cdsEnvironmentItem.SetCustomizationValue(CommonCustomizationNames.CdsEnvironmentCdsTemplate, CdsConstants.CdsBapApiInstanceTemplateUno);

                    CdsConfigurationHelper.SetCdsEnvironmentDefaultValues(topologyInstance);

                    CdsConfigurationHelper.CreateCdsEnvironment(tenantId, topologyInstance);

                    Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Finished creating CDS environment.");
                }

                Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Uploading updated topology.");
                this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);

                try
                {
                    CdsConfigurationHelper.AllowCdsIslandIpAddress(topologyInstance, cdsEnvironmentItem);
                }
                catch (Exception ex)
                {
                    Tracer.LogErrorEvent(TraceComponent.DeploymentServiceApi, ex, $"Unable to allow CDS island IP addresses. Exception: [{ex.Message}]. Scheduling task to add CDS island ip addresses.");

                    DeploymentInstance deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                    deploymentInstance.Initialize(topologyInstance);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.TopologyInstanceActionTypes, TopologyInstanceSyncRequest.TopologySyncActionTypes.AllowCdsIslandIpAddresses.ToString());

                    TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                    DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, DeploymentRequest.DeploymentAction.InfrastructureMaintenance);

                    if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, TopologyInstanceSyncTask.TaskNameConstant, out errorMessage, DeploymentState.InfrastructureMaintenance))
                    {
                        Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Unable to schedule the task to allow CDS island IP addresses. Error message: [{errorMessage}].");
                    }
                    else
                    {
                        Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Scheduled task {TopologyInstanceSyncTask.TaskNameConstant}, action {TopologyInstanceSyncRequest.TopologySyncActionTypes.AllowCdsIslandIpAddresses} to allow CDS island IP addresses.");
                    }
                }

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, $"REQUEST: '{this.Request.RequestUri}'");
                throw;
            }
        }

        /// <summary>
        /// Configures DualWrite for the CDS environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action which contains Environment Group.</param>
        /// <returns>An HTTP response message.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication)]
        public HttpResponseMessage ConfigureCdsDualWrite(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                HttpResponseMessage errorMessage;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                // Get topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out TopologyInstance topologyInstance, out errorMessage, out TopologyInstanceTableItem topologyInstanceRow))
                {
                    return errorMessage;
                }

                // F&O environment status should be Finished / Succeeded.
                if (topologyInstance.DeploymentState != DeploymentState.Finished ||
                    topologyInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.Succeeded)
                {
                    errorMessage = this.CreateErrorResponse($"Configure Cds DualWrite operation is not allowed because state / status of deployment is [{topologyInstance.DeploymentState}]/[{topologyInstance.DeploymentStatus}]. Topology instance: [{topologyInstance}].");
                    return errorMessage;
                }

                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ConfigureCdsDualWrite;

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                DeploymentItem cdsEnvironmentItem = topologyInstance.GetCdsEnvironmentItem();

                if (cdsEnvironmentItem == null)
                {
                    errorMessage = this.CreateErrorResponse($"Configure Cds DualWrite operation is not allowed because CDS environment doesn't exist for the Topology instance: [{topologyInstance}].");
                    return errorMessage;
                }

                bool configureCds = cdsEnvironmentItem.GetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentConfigure);

                if (!cdsEnvironmentItem.TryGetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentDualWriteConfigurationCompleted, out bool isDualWriteCompleted))
                {
                    isDualWriteCompleted = false;
                }

                CdsConfigurationStep? cdsConfigurationStep = cdsEnvironmentItem.GetCdsConfigurationStep();
                CdsConfigurationStepStatus? cdsConfigurationStepStatus = cdsEnvironmentItem.GetCdsConfigurationStepStatus();

                var cdsConfigurationState = new CdsConfigurationState(cdsConfigurationStep, cdsConfigurationStepStatus);

                if (!configureCds || !cdsConfigurationState.ShouldRunStep(CdsConfigurationStep.Finished) || isDualWriteCompleted)
                {
                    errorMessage = this.CreateErrorResponse($"Configure Cds DualWrite operation is not allowed because Cds may not be configured or DualWrite operation is completed. Topology instance: [{topologyInstance}].");
                    return errorMessage;
                }

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

                if (!DeploymentServiceCdsDualWriteConfigurationWorkflow.ScheduleCdsDualWriteConfigurationSilent(tenantRegistration, topologyInstance, out string message))
                {
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.UnableToScheduleTaskDefinition, message);
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, topologyInstance);

                    return errorMessage;
                }
                else
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        $"Requested Cds DualWrite configuration: tenant id: [{tenantId}], azure subscription id: [{azureSubscriptionId}], topology instance id: [{topologyInstanceId}], environment group: [{environmentGroup}]");

                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, $"REQUEST: '{this.Request.RequestUri}'");
                throw;
            }
        }

        /// <summary>
        /// Delete CdsDoaminNameReservation for the topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action which contains Environment Group.</param>
        /// <returns>An HTTP response message.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication)]
        public HttpResponseMessage DeleteCdsDomainNameReservation(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                HttpResponseMessage errorMessage;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                // Get topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out TopologyInstance topologyInstance, out errorMessage, out TopologyInstanceTableItem topologyInstanceRow))
                {
                    return errorMessage;
                }

                // F&O environment status should be Finished / Succeeded.
                if (topologyInstance.DeploymentState != DeploymentState.Finished ||
                    topologyInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.Succeeded)
                {
                    errorMessage = this.CreateErrorResponse($"DeleteCdsDomainNameReservation operation is not allowed because state / status of deployment is [{topologyInstance.DeploymentState}]/[{topologyInstance.DeploymentStatus}]. Topology instance: [{topologyInstance}].");
                    return errorMessage;
                }

                DeploymentItem cdsEnvironmentItem = topologyInstance.GetCdsEnvironmentItem();

                if (cdsEnvironmentItem == null)
                {
                    errorMessage = this.CreateErrorResponse($"Cds deployment item is not found for the Topology instance: [{topologyInstance}].");
                    return errorMessage;
                }

                string cdsEnvironmentInstanceId = cdsEnvironmentItem.GetCustomizationValueOrDefault(CommonCustomizationNames.CdsEnvironmentInstanceId, string.Empty);
                string cdsEnvironmentInstanceUri = cdsEnvironmentItem.GetCustomizationValueOrDefault(CommonCustomizationNames.CdsEnvironmentInstanceUri, string.Empty);

                if (string.IsNullOrEmpty(cdsEnvironmentInstanceId) && !string.IsNullOrEmpty(cdsEnvironmentInstanceUri))
                {
                    CdsConfigurationHelper.DeleteCdsDomainNameReservation(tenantId, topologyInstance);
                }
                else
                {
                    errorMessage = this.CreateErrorResponse($"CdsDomainNamereservation can't be triggered as cdsEnvironmentInstanceId found for the Topology instance: [{topologyInstance}].");
                    return errorMessage;
                }

                Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Finished Delete DeleteCdsDomainNameReservation for the associated CDS environment.");

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, $"REQUEST: '{this.Request.RequestUri}'");
                throw;
            }
        }

        /// <summary>
        /// Deletes CDS metadata from the topology instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action which contains Environment Group.</param>
        /// <returns>An HTTP response message.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication)]
        public HttpResponseMessage CleanupCdsMetadata(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                // Get topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out TopologyInstance topologyInstance, out HttpResponseMessage errorMessage, out TopologyInstanceTableItem topologyInstanceRow))
                {
                    return errorMessage;
                }

                // F&O environment status should be Finished / Succeeded.
                if (topologyInstance.DeploymentState != DeploymentState.Finished ||
                    topologyInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.Succeeded)
                {
                    errorMessage = this.CreateErrorResponse($"Clean up CDS metadata operation is not allowed because state / status of deployment is [{topologyInstance.DeploymentState}]/[{topologyInstance.DeploymentStatus}]. Topology instance: [{topologyInstance}].");
                    return errorMessage;
                }

                DeploymentItem cdsEnvironmentItem = topologyInstance.GetCdsEnvironmentItem();

                if (cdsEnvironmentItem != null)
                {
                    Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"CDS environment deployment item has been found. Validating status of CDS environment.");

                    // Check status of CDS environment, it should not be final (Finished / Completed).
                    var cdsEnvironmentStep = cdsEnvironmentItem.GetCustomizationValue<string>(CommonCustomizationNames.CdsEnvironmentConfigurationStep);
                    var cdsEnvironmentStepStatus = cdsEnvironmentItem.GetCustomizationValue<string>(CommonCustomizationNames.CdsEnvironmentConfigurationStepStatus);

                    if (cdsEnvironmentStep.Equals(CdsConfigurationStep.Finished.ToString(), StringComparison.OrdinalIgnoreCase) &&
                        cdsEnvironmentStepStatus.Equals(CdsConfigurationStepStatus.Completed.ToString(), StringComparison.OrdinalIgnoreCase))
                    {
                        errorMessage = this.CreateErrorResponse($"Clean up CDS metadata operation is not allowed because step / status of CDS environment is final [{cdsEnvironmentStep}]/[{cdsEnvironmentStepStatus}]. Topology instance: [{topologyInstance}].");
                        return errorMessage;
                    }
                }

                Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Uploading topology backup.");
                this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, ServiceConstants.CleanupCdsMetadataActionName);

                Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Cleaning up CDS metadata.");
                CdsConfigurationHelper.CleanUpCdsMetadata(topologyInstance);

                Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, $"Uploading updated topology.");
                this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, $"REQUEST: '{this.Request.RequestUri}'");
                throw;
            }
        }

        /// <summary>
        /// Action used to retrieve the existing CDS environments for the tenant.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action which contains Environment Group.</param>
        /// <returns>An HTTP response message.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage GetExistingCDSEnvironments(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                // Existing CDS environments flow is now longer valid. Returning an empty list to LCS to always enable new CDS environments flow.
                IEnumerable<CdsEnvironmentInstanceDetails> cdsEnvs = new List<CdsEnvironmentInstanceDetails>();

                return Request.CreateResponse(HttpStatusCode.OK, cdsEnvs);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(
                   TraceComponent.DeploymentServiceApi,
                   exception,
                   "Failed to fetch the existing CDS environments under the tenant.");

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to validate if the existing Cds environment is suitable for integration with F&O.
        /// This API is a workaround and should be depeciated once we move initial CDS inquries to LCS.
        /// </summary>
        /// <param name="aadTenantId">AAD tenant id.</param>
        /// <param name="cdsEnvironmentId">CDS environment id (name).</param>
        /// <returns>HttpResonseMessage with the result.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application)]
        public HttpResponseMessage ValidateExistingCdsEnvironment([FromODataUri] string aadTenantId, [FromODataUri] string cdsEnvironmentId)
        {
            try
            {
                CdsEnvironmentValidationResult result = CdsFacade.ValidateCdsEnvironment(aadTenantId, cdsEnvironmentId);
                return Request.CreateResponse(HttpStatusCode.OK, result);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to validate the restore point for the environment is valid.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action which contains Environment Group.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        public HttpResponseMessage ValidatePointInTimeRestorePoint(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                string databaseRestoreTime = this.GetParameterOrDefault<string>(parameters, ServiceConstants.DatabaseRestoreTimeParameter, string.Empty);

                HttpResponseMessage errorMessage;
                TopologyInstance topologyInstance;
                TopologyInstanceTableItem topologyInstanceRow;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (string.IsNullOrEmpty(databaseRestoreTime))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The database restore point that was supplied was null or empty.", databaseRestoreTime);
                }

                bool isValid = this.IsValidDatabaseRestoreTime(tenantRegistration, topologyInstance, databaseRestoreTime);

                return Request.CreateResponse(HttpStatusCode.OK, isValid);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Rename the database.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the azure subscription in where the topology is deployed.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>Returns a boolean indicating if the operation succeeded.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication)]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Must be robust.")]
        public HttpResponseMessage RenameDatabase(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Rename database for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.RunSQLManagementOperation;

                string databaseDeploymentItemName = this.GetParameterOrDefault(parameters, CommonDeploymentActionParameters.DatabaseDeploymentItemName, String.Empty);
                string newDatabaseName = this.GetParameterOrDefault(parameters, CommonDeploymentActionParameters.NewDatabaseName, String.Empty);
                string currentDatabaseName = this.GetParameterOrDefault(parameters, CommonDeploymentActionParameters.CurrentDatabaseName, String.Empty);

                if (string.IsNullOrEmpty(currentDatabaseName) || string.IsNullOrEmpty(newDatabaseName))
                {
                    return this.CreateErrorResponse(
                        ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                        action.ToString(),
                        currentDatabaseName,
                        CommonDeploymentActionParameters.CurrentDatabaseName);
                }

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage message;
                TopologyInstanceTableItem topologyInstanceRow;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out message, out topologyInstanceRow))
                {
                    return message;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out message))
                {
                    return message;
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                if (deploymentInstance.DeploymentState != DeploymentState.Finished &&
                   deploymentInstance.DeploymentStatus != DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState);
                }

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Rename database '{0}' for topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'.",
                    currentDatabaseName,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                DeploymentItem azureSQLDatabaseItem = topologyInstance.DeploymentItems.GetFirst(databaseDeploymentItemName);
                DeploymentItem azureSQLServerItem = topologyInstance.DeploymentItems.GetFirst(azureSQLDatabaseItem.ParentItemName);

                try
                {
                    bool result = false;
                    ARMOperationData operationData = new ARMOperationData(
                        tenantRegistration.ActiveDirectorySubscriptionTenantID,
                        tenantRegistration.AzureSubscriptionId.ToString(),
                        topologyInstance.GetResourceGroup(azureSQLServerItem),
                        topologyInstance.InstanceId);

                    result = AzureSQLDatabaseDeploymentWorkflow.RenameDatabase(operationData, azureSQLServerItem, azureSQLDatabaseItem, currentDatabaseName, newDatabaseName);

                    if (result)
                    {
                        return Request.CreateResponse(HttpStatusCode.OK);
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(
                            TraceComponent.DeploymentServiceApi,
                            "Rename database '{0}' for topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'.",
                            currentDatabaseName,
                            topologyInstanceId,
                            azureSubscriptionId,
                            tenantId);

                        return this.CreateErrorResponse(ServiceErrorCode.UnableToRunSQLOperation);
                    }
                }
                catch (Exception e)
                {
                    Tracer.WriteErrorEvent(
                           TraceComponent.DeploymentServiceApi,
                           e,
                           "Unable to rename the database on topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                           topologyInstanceId,
                           azureSubscriptionId,
                           tenantId);

                    return this.CreateErrorResponse(ServiceErrorCode.UnableToRunSQLOperation, topologyInstanceId);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Unable to rename the database on topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode = '{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to rename the database on topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to get topology instance resources info.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>A HttpResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: ServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        public HttpResponseMessage GetTopologyInstanceResourcesInfo(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Starting check resource group existence for topology Instance Id '{0}' in Environment Group '{1}' Azure Subscription '{2}' of tenant '{3}'.",
                    topologyInstanceId,
                    environmentGroup,
                    azureSubscriptionId,
                    tenantId);

                // Get the topology instance.
                TopologyInstance topologyInstance;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Retrieving the topology instance.");
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    throw new ServiceException("Failed to retrieve topology instance for environment");
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The topology instance with name '{0}' retrieved successfully.", topologyInstance.TopologyName);

                // Check if topology is ARM topology.
                if (!topologyInstance.ShouldUseAzureResourceManager())
                {
                    throw new ServiceException(
                        ServiceErrorCode.OperationNotAllowed_RequireTopologyWithARMSupport,
                        $"The topology with name '{topologyInstance.TopologyName}' is not enabled for ARM.");
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The topology with name '{0}' is enabled for ARM.", topologyInstance.TopologyName);
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Retrieving the deployment instance.");

                // Get the deployment instance.
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    throw new ServiceException(string.Format(CultureInfo.InvariantCulture, "Failed to retrieve deployment instance for topology with name: '{0}'.", topologyInstance.TopologyName));
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The deployment instance retrieved successfully.");

                // Check resource group existence.
                string resourceGroup = topologyInstance.ARM.ResourceGroupName;
                TenantRegistration tenantRegistration = TenantRegistrationDAC.GetTenantRegistration(tenantId, azureSubscriptionId);

                using (AzureResourceManager arm = tenantRegistration.CreateAzureResourceManager(resourceGroup))
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Checking resource group with name '{0}' in environment group '{1}', subscription '{2}'.",
                        resourceGroup,
                        environmentGroup,
                        azureSubscriptionId);

                    bool resourceGroupExists = arm.Resource.Value.CheckResourceGroupExistence();

                    // If resource group exists, also collect information about resources in this resource group.
                    List<GenericResource> resources = null;
                    if (resourceGroupExists)
                    {
                        resources = arm.Resource.Value.GetResources();
                    }

                    var result = new TopologyInstanceResourcesInfoResponse
                    {
                        TenantId = tenantId,
                        SubscriptionId = azureSubscriptionId,
                        TopologyInstanceId = topologyInstanceId,
                        EnvironmentId = topologyInstance.EnvironmentId,
                        ResourceGroupName = resourceGroup,
                        ResourceGroupExists = resourceGroupExists,
                        DeploymentStatus = deploymentInstance.DeploymentStatus,
                        DeploymentState = deploymentInstance.DeploymentState,

                        // OData serializer cannot serialize null collections. To bypass this, assign empty collection.
                        AzureResources = new List<TopologyInstanceAzureResource>(),
                    };

                    if (resources != null)
                    {
                        result.AzureResources = resources.Select(this.ConvertToAzureResourceResponse).ToList();
                        var vmResources = result.AzureResources.FindAll(r => r.Type.Equals(DeploymentConstants.VirtualMachineResourceType, StringComparison.OrdinalIgnoreCase));
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Found {0} virtual machines", vmResources.Count);
                        foreach (var vmResource in vmResources)
                        {
                            vmResource.State = arm.Compute.Value.GetVirtualMachinePowerState(vmResource.Name).ToString();
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Virtual Machine: {0} PowerState:{1}", vmResource.Name, vmResource.State);
                        }
                    }

                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Checked resource group existence for topology Instance Id '{0}' in environment group '{1}', Azure Subscription '{2}' of tenant '{3}'. Resource group exists: {4}.",
                        topologyInstanceId,
                        environmentGroup,
                        azureSubscriptionId,
                        tenantId,
                        resourceGroupExists);
                    return Request.CreateResponse(HttpStatusCode.OK, result);
                }
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    exception,
                    "REQUEST: '{0}'",
                    this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to Migrate a deployment instance item to Elastic Pool.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        [SuppressMessage("Microsoft.MSInternal", "CA908", Justification = "Not a precompiled assembly")]
        public HttpResponseMessage MigrateDatabaseToElasticPool(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            return this.MigrateDatabase(tenantId, azureSubscriptionId, topologyInstanceId, parameters, toElasticPool: true);
        }

        /// <summary>
        /// Action used to Migrate a deployment instance item to a Azure Sql server.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        [SuppressMessage("Microsoft.MSInternal", "CA908", Justification = "Not a precompiled assembly")]
        public HttpResponseMessage MigrateDatabaseToAzureServer(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            return this.MigrateDatabase(tenantId, azureSubscriptionId, topologyInstanceId, parameters, toElasticPool: false);
        }

        /// <summary>
        /// Action used to activate post migration steps.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        [SuppressMessage("Microsoft.MSInternal", "CA908", Justification = "Not a precompiled assembly")]
        public HttpResponseMessage PerformPostMigrationSteps(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            DeploymentInstance deploymentInstance = null;
            TopologyInstance topologyInstance = null;
            TopologyInstanceTableItem topologyInstanceRow = null;
            DeploymentState deploymentState = DeploymentState.Migrating;
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ExecutePostMigrationSteps;
            TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

            try
            {
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                // Migration request mode.
                string migrationRequestMode = this.GetParameterOrDefault<string>(parameters, CommonDeploymentActionParameters.RequestMode, DeploymentConstants.DBMigrationStandAloneRequest);

                // Migration direction.
                string migrationDirection = this.GetParameterOrDefault<string>(parameters, CommonDeploymentActionParameters.DatabaseMigrationDirection, null);
                string databaseMigrationDirection;
                if (string.Equals(migrationDirection, Library.Model.ServiceConstants.DBMigrationSingleToElastic, StringComparison.OrdinalIgnoreCase))
                {
                    databaseMigrationDirection = DeploymentConstants.DBMigrationSingleToElastic;
                }
                else if (string.Equals(migrationDirection, Library.Model.ServiceConstants.DBMigrationElasticToSingle, StringComparison.OrdinalIgnoreCase))
                {
                    databaseMigrationDirection = DeploymentConstants.DBMigrationElasticToSingle;
                }
                else
                {
                    throw new ArgumentException("Unsupported MigrationDirection  '{0}' .", migrationDirection);
                }

                // Check if previous deployment was successful.
                if (deploymentInstance.DeploymentState != DeploymentState.Finished || deploymentInstance.DeploymentStatus != Model.DeploymentStatus.Succeeded)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}], status: [{5}].", action, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.Finished, Model.DeploymentStatus.Succeeded);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, topologyInstanceId);
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance, true);

                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.RequestMode, migrationRequestMode);
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.DatabaseMigrationDirection, databaseMigrationDirection);

                HttpResponseMessage throwaway;
                IEnumerable<string> deploymentItemList;
                if (!this.TryProcessParameter(parameters, CommonDeploymentActionParameters.DatabaseType, out deploymentItemList, out throwaway))
                {
                    deploymentItemList = new List<string>();
                }

                string databaseTypeParametersString = CommonUtilities.SerializeJson(new List<string>(deploymentItemList));
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.DatabaseType, databaseTypeParametersString);

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentServiceDBMigrationWorkflow.TaskNameConstant, out errorMessage, deploymentState))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to perform post migration steps '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                if (tenantRegistration != null && topologyInstance != null)
                {
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, topologyInstance);
                }

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to perform post migration steps'{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to execute elastic pool database migration action.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication |
            DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ElasticPoolMigrationService,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        [SuppressMessage("Microsoft.MSInternal", "CA908", Justification = "Not a precompiled assembly")]
        public HttpResponseMessage ExecuteElasticPoolDatabaseMigrationAction(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            DeploymentInstance deploymentInstance = null;
            TopologyInstance topologyInstance = null;
            TopologyInstanceTableItem topologyInstanceRow = null;
            DeploymentState deploymentState = DeploymentState.PreparingForMigration;
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ExecuteElasticPoolDatabaseMigrationAction;
            TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

            try
            {
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;
                ElasticPoolMigrationActionType actionToExecute;
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                IDictionary<string, string> parameterValues;
                if (!this.ReadMigrationActionParameters(parameters, action, topologyInstance, deploymentInstance, ref deploymentState, out actionToExecute, out parameterValues, out errorMessage))
                {
                    return errorMessage;
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance, true);
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.ElasticPoolMigrationActionType, actionToExecute.ToString());
                // Overriding default Gomez maintenance window.
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.HealthDowntimeWindowInHours, ((int)TimeSpan.FromHours(DeploymentConstants.DBMigrationMaintenanceWindow).TotalHours).ToString("F0", CultureInfo.CurrentCulture));

                if (parameterValues != null && parameterValues.Count > 0)
                {
                    foreach (var parameterValue in parameterValues)
                    {
                        deploymentInstance.DeploymentActionParameters.Add(parameterValue.Key, parameterValue.Value);
                    }
                }

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentServiceDBMigrationWorkflow.TaskNameConstant, out errorMessage, deploymentState))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to perform prepare elastic pool database migration action '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                if (tenantRegistration != null && topologyInstance != null)
                {
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, topologyInstance);
                }

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to perform prepare elastic pool database migration action '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to backup topology instance XML.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HttpResponseMessage with backup blob name.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
                    authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ElasticPoolMigrationService,
                    tenantIdParam: "tenantId",
                    azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        [SuppressMessage("Microsoft.MSInternal", "CA908", Justification = "Not a precompiled assembly")]
        public HttpResponseMessage BackupTopologyInstanceXML(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Backup topology instance Xml for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                TopologyInstance topologyInstance = null;
                TopologyInstanceTableItem topologyInstanceRow = null;
                HttpResponseMessage errorMessage;

                DeploymentRequest.DeploymentAction deploymentAction = DeploymentRequest.DeploymentAction.Undefined;

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                string actionName = parameters.ContainsKey(CommonDeploymentActionParameters.ActionName) ? (string)parameters[CommonDeploymentActionParameters.ActionName] : string.Empty;

                if (string.IsNullOrWhiteSpace(actionName))
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "BackupTopologyInstanceXML invoked for topology instance [{0}] without action name. Defaulting to Undefined",
                        topologyInstanceId);
                }
                else
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "BackupTopologyInstanceXML:{0} invoked for topology instance [{1}]",
                        actionName,
                        topologyInstanceId);
                    if (!Enum.TryParse<DeploymentRequest.DeploymentAction>(actionName, out deploymentAction))
                    {
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, ServiceConstants.BackupTopologyInstanceXML, actionName, CommonDeploymentActionParameters.ActionName);
                    }
                }

                // Get topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                // Backup topology instance XML
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Backing up topology instance xml [{0}]", topologyInstanceId);
                string backupBlobName = TopologyInstanceHelper.BackupTopologyInstanceXML(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, deploymentAction.ToString());

                return Request.CreateResponse(HttpStatusCode.OK, backupBlobName);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to restore topology instance XML from backup created by BackupTopologyInstanceXML action.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HttpResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
                    authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ElasticPoolMigrationService,
                    tenantIdParam: "tenantId",
                    azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        [SuppressMessage("Microsoft.MSInternal", "CA908", Justification = "Not a precompiled assembly")]
        public HttpResponseMessage RestoreTopologyInstanceXMLFromBackup(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Restore topology instance Xml for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                TopologyInstance topologyInstance = null;
                TopologyInstanceTableItem topologyInstanceRow = null;
                HttpResponseMessage errorMessage;

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                string topologyInstanceBackupName = parameters.ContainsKey(CommonDeploymentActionParameters.TopologyInstanceBackupName) ? (string)parameters[CommonDeploymentActionParameters.TopologyInstanceBackupName] : string.Empty;

                // Get topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (string.IsNullOrWhiteSpace(topologyInstanceBackupName))
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "BackupTopologyInstanceXML invoked for topology instance [{0}] without TopologyInstanceBackupName.",
                        topologyInstanceId);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, ServiceConstants.RestoreTopologyInstanceXMLFromBackup, CommonDeploymentActionParameters.TopologyInstanceBackupName);
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                // Backup topology instance XML before restoring
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Backing up topology instance xml [{0}] before restoring", topologyInstanceId);
                TopologyInstanceHelper.BackupTopologyInstanceXML(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, ServiceConstants.RestoreTopologyInstanceXMLFromBackup);

                // Restore topology instance XML
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Restoring topology instance xml [{0}]", topologyInstanceId);
                TopologyInstanceHelper.RestoreTopologyInstanceXmlFromBackup(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, topologyInstanceBackupName);

                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        /// <summary>
        /// Action used to Migrate a deployment instance item to a Azure Sql server.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
            authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Application | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ElasticPoolMigrationService,
            tenantIdParam: "tenantId",
            azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        [SuppressMessage("Microsoft.MSInternal", "CA908", Justification = "Not a precompiled assembly")]
        public HttpResponseMessage AddRemoveSpartanFirewallRules(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            DeploymentInstance deploymentInstance = null;
            TopologyInstance topologyInstance = null;
            TopologyInstanceTableItem topologyInstanceRow = null;
            DeploymentState deploymentState = DeploymentState.ConfiguringFirewallRules;
            TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

            try
            {
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (!(deploymentInstance.DeploymentState == DeploymentState.Finished && deploymentInstance.DeploymentStatus == DeploymentApi.Model.DeploymentStatus.Succeeded))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to configure the Spartan Firewall rules on deployment instance corresponding to topology [{0}] but it is currently in state [{1}].", topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }

                // Check if environment have an active staging.
                TopologyInstance stagingTopologyInstance;
                TopologyInstanceTableItem stagingTopologyInstanceRow;
                if (this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Staging, out stagingTopologyInstance, out errorMessage, out stagingTopologyInstanceRow))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Found an active staging environment for topology instance '{0}' during delete of the primary environment.", topologyInstanceId);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_DeleteStagingBeforePrimary, topologyInstanceId);
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance, includeVMInstances: false);

                // To add or remove the spartan firewall rules.
                bool addSpartanFirewallRule = this.GetParameterOrDefault<bool>(parameters, CommonDeploymentActionParameters.AddSpartanFirewallRule, false);

                DeploymentRequest.DeploymentAction action = addSpartanFirewallRule ? DeploymentRequest.DeploymentAction.AddSpartanFirewallRules : DeploymentRequest.DeploymentAction.RemoveSpartanFirewallRules;

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentServiceDBMigrationWorkflow.TaskNameConstant, out errorMessage, deploymentState))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to schedule task to modify Spartan firewall rules on '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorMessage = this.CreateErrorResponse(serviceException);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to schedule task to modify Spartan firewall rules on '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Action used to update DNS of AX endspoint od environment with provided link.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <returns>An HttpResponseMessage.</returns>
        [HttpPost]
        [DeploymentServiceAuthorizationFilter(
                    authType: DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.Certificate | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.ElasticPoolMigrationService | DeploymentServiceAuthorizationFilterAttribute.ServiceAuthorizationType.GenevaApplication,
                    tenantIdParam: "tenantId",
                    azureSubscriptionParam: "azureSubscriptionId")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        [SuppressMessage("Microsoft.MSInternal", "CA908", Justification = "Not a precompiled assembly")]
        public HttpResponseMessage UpdateAXEndpointDNS(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Restore topology instance Xml for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                TopologyInstance topologyInstance = null;
                TopologyInstanceTableItem topologyInstanceRow = null;
                HttpResponseMessage errorMessage;

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                // Get topology instance
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                string documentLink = parameters.ContainsKey(CommonDeploymentActionParameters.DocumentLink) ? (string)parameters[CommonDeploymentActionParameters.DocumentLink] : string.Empty;

                if (string.IsNullOrWhiteSpace(documentLink))
                {
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, CommonDeploymentActionParameters.DocumentLink);
                }

                TopologyInstanceHelper.UpdateAXEndpointDNSWithDocumentLink(topologyInstance, documentLink);
                this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                return Request.CreateResponse(HttpStatusCode.OK);
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                throw;
            }
        }

        #endregion

        #region Helpers

        /// <summary>
        /// Validates the WinRM endpoint configuration can be only used for a VM single instance.
        /// This is tracked by work item #Task 2117: Deployment Service: Update DSU to define Win RM ports for multiple VMs.
        /// </summary>
        /// <param name="entity">The TopologyInstance.</param>
        /// <param name="errorMessage">The HttpResponseMessage.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        public bool ValidateWinRmAttributeForSingleInstanceOnly(TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            foreach (var deploymentItem in entity.DeploymentItems)
            {
                string containsWinRmCustomization = string.Empty;
                if (deploymentItem.TryGetCustomizationValue(CommonCustomizationNames.WinRmPortName, out containsWinRmCustomization) &&
                    !string.IsNullOrEmpty(containsWinRmCustomization) && deploymentItem.GetInstanceCount() > 1)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The '{0}' endpoint can only be set for a single VM instance in deployment '{1}'. ", CommonCustomizationNames.WinRmPortName, deploymentItem.DisplayName);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopologyInstance);
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Populate the list with the region's offhours info.
        /// </summary>
        /// <returns>
        /// List with offhour info.
        /// </returns>
        private static List<RegionOffHoursInfo> PopulateRegionOffHours()
        {
            List<RegionOffHoursInfo> regionOffHours = new List<RegionOffHoursInfo>();

            // See the following link for the off-hours (defined from midnight UTC by geography)
            // https://docs.microsoft.com/en-us/dynamics365/unified-operations/dev-itpro/lifecycle-services/planned-maintenance-window-faq
            regionOffHours.Add(new RegionOffHoursInfo()
            {
                Name = "APAC",
                From = TimeSpan.FromHours(12),
                To = TimeSpan.FromHours(21),
                Region = new RE.Regex("^(.+\\sIndia|.+\\sAsia|Australia\\s.+|China\\s.+|Korea\\s.+|Japan\\s.+)$")
            });

            regionOffHours.Add(new RegionOffHoursInfo()
            {
                Name = "CAN",
                From = TimeSpan.FromHours(2),
                To = TimeSpan.FromHours(10),
                Region = new RE.Regex("^(Canada\\s.+)$")
            });

            regionOffHours.Add(new RegionOffHoursInfo()
            {
                Name = "EMEA",
                From = TimeSpan.FromHours(22),
                To = TimeSpan.FromHours(30),
                Region = new RE.Regex("^(France\\s.+|Germany\\s.+|UK\\s.+|Switzerland\\s.+|.+\\sEurope|UAE\\s.+|South\\sAfrica\\s.+)$")
            });

            regionOffHours.Add(new RegionOffHoursInfo()
            {
                Name = "NAM",
                From = TimeSpan.FromHours(2),
                To = TimeSpan.FromHours(10),
                Region = new RE.Regex("^(.+\\sUS.*|US\\sGov\\s.+US\\sDoD\\s.+)$")
            });

            regionOffHours.Add(new RegionOffHoursInfo()
            {
                Name = "SAM",
                From = TimeSpan.FromHours(0),
                To = TimeSpan.FromHours(8),
                Region = new RE.Regex("^(Brazil\\s.+)$")
            });

            // Default for any region (Last to match).
            regionOffHours.Add(new RegionOffHoursInfo()
            {
                Name = "Default",
                From = TimeSpan.FromHours(20),
                To = TimeSpan.FromHours(28),
                Region = new RE.Regex(".*")
            });

            return regionOffHours;
        }

        /// <summary>
        /// Gets the off hours info based on the region.
        /// </summary>
        /// <param name="azureDataCenterRegion">Region for which off hours needs to be calculated.</param>
        /// <returns>
        /// Off hours info for the region.
        /// </returns>
        private static RegionOffHoursInfo GetRegionOffHours(string azureDataCenterRegion)
        {
            RegionOffHoursInfo info = null;

            foreach (RegionOffHoursInfo regionOffHoursInfo in regionOffHours.Value)
            {
                if (regionOffHoursInfo.Region.IsMatch(azureDataCenterRegion))
                {
                    info = regionOffHoursInfo;
                    break;
                }
            }

            return info;
        }

        /// <summary>
        /// Gets the default off hour from the list.
        /// </summary>
        /// <returns>
        /// Default off hours info.
        /// </returns>
        private static RegionOffHoursInfo GetDefaultRegionOffHours()
        {
            return regionOffHours.Value.Find(r => r.Name.Equals("Default", StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        /// Gets certificate information for SSL certificates in the environment.
        /// </summary>
        /// <param name="topologyInstance">TopologyInstance object.</param>
        /// <param name="certificateIdentifier">Optional certificate identifier (name).</param>
        /// <returns>Set of data for SSL certificates for the environment, if a <paramref name="certificateIdentifier"/> is specified then it will just the requested certificate (if found).</returns>
        private static IEnumerable<CertificateDefinition> GetSslCertificateDefinitions(TopologyInstance topologyInstance, string certificateIdentifier)
        {
            DeploymentEnvironment deploymentEnvironment = topologyInstance.GetDeploymentEnvironment();

            IEnumerable<string> targetSslCertificateNames;

            if (!String.IsNullOrWhiteSpace(certificateIdentifier))
            {
                targetSslCertificateNames = new[]
                {
                    certificateIdentifier
                };
            }
            else
            {
                // no specific certificate specified, process all known ones
                targetSslCertificateNames = knownSslCertificateNames;
            }

            List<CertificateDefinition> certificateDefinitions = new List<CertificateDefinition>();

            foreach (string certificateName in targetSslCertificateNames)
            {
                // find SSL certificate with matching name
                Microsoft.DynamicsOnline.RainierDeployment.EntityModel.SslCertificate sslCertificate =
                    deploymentEnvironment.Certificates.SslCertificate.FirstOrDefault(c =>
                        String.Equals(c.Name, certificateName, StringComparison.OrdinalIgnoreCase));

                if (sslCertificate == null)
                {
                    // cert not found, go on to next entry
                    continue;
                }

                string certBase64Data;
                string certPassword;
                CommonHelper.GetSSLCertificateData(sslCertificate, out certBase64Data, out certPassword);

                // Load the certificate in memory so we can extract metadata
                X509Certificate2 certificate = new X509Certificate2(Convert.FromBase64String(certBase64Data), certPassword);

                CertificateDefinition certificateDefinition = new CertificateDefinition()
                {
                    Identifier = sslCertificate.Name,
                    SubjectName = certificate.Subject,
                    Thumbprint = certificate.Thumbprint,
                    DynamicallyGenerated = false,
                    KeyVaultableRawData = new KeyVaultable<string>(certBase64Data),
                    KeyVaultablePassword = new KeyVaultable<string>(certPassword),
                };

                certificateDefinitions.Add(certificateDefinition);
            }

            return certificateDefinitions;
        }

        /// <summary>
        /// Get an instance of SqlDatabase.
        /// </summary>
        /// <param name="tenantRegistration">The tenant registration.</param>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="databaseDeploymentItemName">The database deployment item name (ex. CommonCustomizationNames.AXDbDeploymentItemName).</param>
        /// <param name="sqlUserName">The sql user name (ex. CommonCredentialNames.AXDatabaseAdminUserName).</param>
        /// <param name="removeFirewallRules">Out parameter that will return action to be used to remove firewall rules that were added.</param>
        /// <returns>SqlDatabase instance.</returns>
        /// <remarks>
        /// This method is intended for SQL azure DB's only;
        /// regular SQL server is being ignored because the connection strings
        /// do not enforce the setting to not trust self-signed certificates
        /// from SQL server.
        /// </remarks>
        private Sql.SqlDatabase GetSqlDatabase(TenantRegistration tenantRegistration, TopologyInstance topologyInstance, string databaseDeploymentItemName, string sqlUserName, out Action removeFirewallRules)
        {
            Contract.Requires(tenantRegistration != null);
            Contract.Requires(topologyInstance != null);
            Contract.Requires(databaseDeploymentItemName != null);
            Contract.Requires(sqlUserName != null);

            removeFirewallRules = null;

            DeploymentItem databaseDeploymentItem;
            if (!topologyInstance.DeploymentItems.TryGetFirst(databaseDeploymentItemName, out databaseDeploymentItem))
            {
                throw new ServiceException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Failed to retrieve database deployment item [{0}].",
                    databaseDeploymentItem));
            }

            string axAdminDatabasePassword = databaseDeploymentItem.GetCredentialByUserName(sqlUserName);
            if (axAdminDatabasePassword == null)
            {
                throw new ServiceException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Failed to retrieve password for sql user [{0}].",
                    sqlUserName));
            }

            DeploymentItem sqlServerDeploymentItem;
            if (!topologyInstance.DeploymentItems.TryGetFirst(databaseDeploymentItem.ParentItemName, out sqlServerDeploymentItem))
            {
                throw new ServiceException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Failed to retrieve database parent deployment item for database deployment item [{0}].",
                    databaseDeploymentItemName));
            }

            AzureSQLDatabaseInfo databaseInfo;
            if (!databaseDeploymentItem.TryGetAzureSqlDatabaseConnectionInfo(sqlServerDeploymentItem, out databaseInfo))
            {
                throw new ServiceException(string.Format(
                    CultureInfo.InvariantCulture,
                    "Failed to get database connection info for database deployment item [{0}].",
                    databaseDeploymentItem));
            }

            if (databaseDeploymentItem.IsElasticPoolEnabled())
            {
                AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceDBMSFirewallOperation(topologyInstance, sqlServerDeploymentItem, AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceType.API, true);

                removeFirewallRules = new Action(() =>
                {
                    AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceDBMSFirewallOperation(topologyInstance, sqlServerDeploymentItem, AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceType.API, false);
                });
            }
            else
            {
                ARMOperationData operationData = new ARMOperationData(
                    tenantRegistration.ActiveDirectorySubscriptionTenantID,
                    tenantRegistration.AzureSubscriptionId.ToString(),
                    topologyInstance.GetResourceGroup(sqlServerDeploymentItem),
                    topologyInstance.InstanceId);

                AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceARMFirewallOperation(operationData, sqlServerDeploymentItem, AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceType.API, true);

                removeFirewallRules = new Action(() =>
                {
                    AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceARMFirewallOperation(operationData, sqlServerDeploymentItem, AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceType.API, false);
                });
            }

            SqlAzureConnectionString sqlServerConnectionString = new SqlAzureConnectionString(databaseInfo.FullyQualifiedDomainName, databaseInfo.DatabaseName, CommonCredentialNames.AXDatabaseAdminUserName, axAdminDatabasePassword);
            return new Sql.SqlDatabase(sqlServerConnectionString, databaseInfo.DatabaseName);
        }

        /// <summary>
        /// Returns VersionInstance or DetailedVersionInstance depending on flag value.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <param name="detailedVersion">Flag indicating if method should return VersionInstance or DetailedVersionInstance object.</param>
        /// <returns>HttpResponseMessage with VersionInstance or DetailedVersion instance objects.</returns>
        private HttpResponseMessage GetVersionInfo(Guid tenantId, Guid azureSubscriptionId, string topologyInstanceId, ODataActionParameters parameters, bool detailedVersion)
        {
            try
            {
                TopologyInstance topologyInstance;
                TopologyInstanceTableItem topologyInstanceRow;
                HttpResponseMessage errorResponseMessage;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                DetailedVersionInstance detailedVersionInstance;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorResponseMessage, out topologyInstanceRow))
                {
                    return errorResponseMessage;
                }

                string versionTypeString = parameters.ContainsKey(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.VersionTypeParameter) ? (string)parameters[Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.VersionTypeParameter] : null;

                VersionType versionType;

                if (!Enum.TryParse(versionTypeString, out versionType))
                {
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.VersionTypeParameter, versionTypeString);
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Retrieving the version info of type [{0}] for topology instance [{1}]", versionType, topologyInstance);
                if (!this.GetVersionInstance(topologyInstanceRow, versionType, out detailedVersionInstance, out errorResponseMessage))
                {
                    return errorResponseMessage;
                }

                Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Retrieved version info app build version [{0}] {1}, plat build version [{2}] {3}, product name [{4}], installation records [{5}] for topology instance [{6}]",
                        detailedVersionInstance.ApplicationBuildVersion,
                        detailedVersionInstance.ApplicationReleaseName,
                        detailedVersionInstance.PlatformBuildVersion,
                        detailedVersionInstance.PlatformReleaseName,
                        detailedVersionInstance.ProductRegisteredName,
                        detailedVersionInstance.InstallationRecords != null ? detailedVersionInstance.InstallationRecords.Count : 0,
                        topologyInstance);

                if (detailedVersion)
                {
                    return Request.CreateResponse(HttpStatusCode.OK, detailedVersionInstance);
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK, (VersionInstance)detailedVersionInstance);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to get version Instance of topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to get version instance of topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Processes the cloud service location in topology.
        /// </summary>
        /// <param name="topologyInstance">The topology.</param>
        /// <param name="tenantRegistration">The associated tenant.</param>
        /// <param name="errorResponse">The error response, if any.</param>
        /// <returns>Whether the cloud service location was successfully processed.</returns>
        private bool TryProcessCloudServiceLocation(TopologyInstance topologyInstance, TenantRegistration tenantRegistration, out HttpResponseMessage errorResponse)
        {
            string tenantLocation = tenantRegistration.GetDefaultStorageLocation();

            if (string.IsNullOrWhiteSpace(topologyInstance.CloudStorageLocation) && !string.IsNullOrWhiteSpace(tenantLocation))
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Topology instance cloud storage location was not set. The deployment will use default location [{0}] for tenant [{1}] in Azure Subscription [{2}] Topology Instance Id [{3}].",
                    tenantLocation,
                    tenantRegistration.TenantId,
                    tenantRegistration.AzureSubscriptionId,
                    topologyInstance.InstanceId);

                topologyInstance.CloudStorageLocation = tenantLocation;
            }

            if (!string.IsNullOrWhiteSpace(topologyInstance.CloudStorageLocation) || !string.IsNullOrWhiteSpace(tenantLocation))
            {
                topologyInstance.CloudServiceLocation = topologyInstance.CloudStorageLocation ?? tenantLocation;
            }
            else
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Failed to deploy topology [{0}]. No CloudStorageLocation was set and there was no default storage location registered for Tenant ID [{1}] and Azure Subscription ID [{2}].",
                    topologyInstance.InstanceId,
                    tenantRegistration.TenantId,
                    tenantRegistration.AzureSubscriptionId);

                errorResponse = this.CreateErrorResponse(ServiceErrorCode.InvalidTopologyInstance);
                return false;
            }

            errorResponse = null;
            return true;
        }

        /// <summary>
        /// Scans the topology instance for items that require a cloud service and then
        /// creates and inserts cloud services into the topology instance.
        /// This method uses the existing cloud services in the topology as prototypes of
        /// the new cloud services created. The prototypes are removed by this method.
        /// </summary>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="tenantRegistration">The tenant registration.</param>
        private void PopulateCloudServiceInstances(TopologyInstance topologyInstance, TenantRegistration tenantRegistration)
        {
            Contract.Requires(topologyInstance != null);
            Contract.Requires(tenantRegistration != null);

            if (topologyInstance.IsRunningInCloudServiceCompatibilityMode() || topologyInstance.CloudServices == null || !topologyInstance.CloudServices.Any())
            {
                return;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Populating cloud service instances for topology '{0}'.", topologyInstance.InstanceId);

            var cloudServicesDictionary = topologyInstance.CloudServices.ToDictionary(cs => cs.Identifier);

            // Add cloud service instance for the deployment items if any was specified
            // for DR, the cloud services are populated in Enable DR workflow
            var deploymentItems = topologyInstance.DeploymentItems.Where(
                                                di => string.IsNullOrWhiteSpace(di.CloudServiceName) &&
                                                      !string.IsNullOrWhiteSpace(di.CloudServiceId) &&
                                                      di.GetInstanceCount() > 0 &&
                                                      di.IsPrimary());
            foreach (var deploymentItem in deploymentItems)
            {
                this.PopulateCloudServiceInstances(topologyInstance, cloudServicesDictionary, deploymentItem);
            }

            // Add cloud service instance for the topology if any was specified, try to reuse existing ones if any.
            if (!string.IsNullOrWhiteSpace(topologyInstance.CloudServiceId))
            {
                var topologyCloudService = cloudServicesDictionary[topologyInstance.CloudServiceId];
                var topologyCloudServiceDeploymentItem = topologyInstance.DeploymentItems.FirstOrDefault(d => string.Equals(d.CloudServiceId, topologyCloudService.Identifier, StringComparison.OrdinalIgnoreCase));
                var cloudServiceInstanceId = topologyCloudService.GenerateCloudServiceInstanceId(topologyInstance, topologyCloudServiceDeploymentItem, null, null);

                if (!topologyCloudService.CloudServiceInstances.Any())
                {
                    // Only add cloud service instances if necessary.
                    // If there are already cloud service instances for this cloudServiceId, reuse that.
                    var cloudServiceInstance = new CloudServiceInstance(cloudServiceInstanceId);
                    topologyCloudService.CloudServiceInstances.Add(cloudServiceInstance);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Added cloud service instance '{0}' to topology '{1}'.", cloudServiceInstance.Identifier, topologyInstance.InstanceId);
                }
            }
        }

        /// <summary>
        /// Creates corresponding cloud services instances that are needed by the deployment item passed as input.
        /// </summary>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="cloudServicesDictionary">The cloud services dictionary.</param>
        /// <param name="deploymentItem">The deployment item.</param>
        /// <exception cref="System.NotSupportedException"></exception>
        private void PopulateCloudServiceInstances(TopologyInstance topologyInstance, Dictionary<string, Catalog.Model.CloudService> cloudServicesDictionary, DeploymentItem deploymentItem)
        {
            var cloudService = cloudServicesDictionary[deploymentItem.CloudServiceId];
            string cloudServiceInstanceId = null;

            if (!String.Equals(cloudService.SharingMode.ToString(), CloudServiceSharingMode.DeploymentItemInstance.ToString(), StringComparison.OrdinalIgnoreCase))
            {
                cloudServiceInstanceId = cloudService.GenerateCloudServiceInstanceId(topologyInstance, deploymentItem, null, null);
                deploymentItem.CloudServiceInstanceId = cloudServiceInstanceId;

                var matchingCloudServiceInstance = cloudService.CloudServiceInstances.FirstOrDefault(csi => string.Equals(csi.Identifier, cloudServiceInstanceId, StringComparison.OrdinalIgnoreCase));
                if (matchingCloudServiceInstance == null)
                {
                    var cloudServiceInstance = new CloudServiceInstance(cloudServiceInstanceId);
                    cloudService.CloudServiceInstances.Add(cloudServiceInstance);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Added cloud service instance '{0}' to topology '{1}' for deployment item '{2}'.", cloudServiceInstance.Identifier, topologyInstance.InstanceId, deploymentItem.ItemName);
                }
            }
            else
            {
                for (int i = 0; i < deploymentItem.GetInstanceCount(); ++i)
                {
                    cloudServiceInstanceId = cloudService.GenerateCloudServiceInstanceId(topologyInstance, deploymentItem, i, null);

                    var matchingCloudServiceInstance = cloudService.CloudServiceInstances.FirstOrDefault(csi => string.Equals(csi.Identifier, cloudServiceInstanceId, StringComparison.OrdinalIgnoreCase));
                    if (matchingCloudServiceInstance == null)
                    {
                        var cloudServiceInstance = new CloudServiceInstance(cloudServiceInstanceId);
                        cloudService.CloudServiceInstances.Add(cloudServiceInstance);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Added cloud service instance '{0}' to topology '{1}' for deployment item instance '{2}'.", cloudServiceInstance.Identifier, topologyInstance.InstanceId, deploymentItem.ItemName);
                    }
                }
            }

            // For SQLAlwaysOn we need a separate cloud service for quorum. Reuse an existing cloud service based on size if available.
            if (deploymentItem.IsItemType(DeploymentItemType.SqlAlwaysOn) && deploymentItem.GetInstanceCount() % 2 == 0)
            {
                string quorumSize = null;
                if (!deploymentItem.TryGetCustomizationValue(CommonCustomizationNames.QuorumVmSize, out quorumSize))
                {
                    quorumSize = DeploymentConstants.DefaultQuorumVMRoleSize;
                }

                string quorumCloudServiceSuffix = deploymentItem.GetCloudServiceGroupSuffix(quorumSize);
                string quorumCloudServiceInstanceId = cloudService.GenerateCloudServiceInstanceId(topologyInstance, deploymentItem, null, quorumCloudServiceSuffix);

                var matchingCloudServiceInstance = cloudService.CloudServiceInstances.FirstOrDefault(csi => string.Equals(csi.Identifier, quorumCloudServiceInstanceId, StringComparison.OrdinalIgnoreCase));
                if (matchingCloudServiceInstance == null)
                {
                    var cloudServiceInstance = new CloudServiceInstance(quorumCloudServiceInstanceId);
                    cloudService.CloudServiceInstances.Add(cloudServiceInstance);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Added cloud service instance '{0}' - quorum needed - to topology '{1}'.", cloudServiceInstance.Identifier, topologyInstance.InstanceId);
                }

                // save the cloud instance id for quorum as customization
                deploymentItem.SetCustomizationValue(CommonCustomizationNames.QuorumCloudServiceId, quorumCloudServiceInstanceId);
            }
        }

        /// <summary>
        /// Populates the endpoints and VIPs.
        /// </summary>
        /// <param name="topologyInstance">The topology instance.</param>
        private void PopulateEndpointsAndVIPs(TopologyInstance topologyInstance)
        {
            Contract.Requires(topologyInstance != null);

            bool enableDnsRecordCreation;
            if (!topologyInstance.TryGetCustomizationValue<bool>(CommonCustomizationNames.EnableDNSRecordCreationCustomization, out enableDnsRecordCreation) || !enableDnsRecordCreation)
            {
                Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Enable DNS record creation customization is not set to true for topology '{0}' Id '{1}'. Skipping Populate Endpoints and VIPs.",
                        topologyInstance.TopologyName,
                        topologyInstance.InstanceId);
                return;
            }

            if (topologyInstance.DnsRecordSets == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Skipping generation of endpoints and VIPs because DnsRecordSets is null in topology instance [{0}].", topologyInstance.InstanceId);
                return;
            }

            int port = DeploymentConstants.HttpsInternalStartPortNumber;

            foreach (var dnsRecordSet in topologyInstance.DnsRecordSets.Where(dnsRec => string.Equals(dnsRec.RecordType, DnsRecordSet.VirtualIPRecordType, StringComparison.OrdinalIgnoreCase)))
            {
                if (dnsRecordSet.SourceType != "DeploymentItem")
                {
                    var message = String.Format(CultureInfo.InvariantCulture, "Unsupported source type in DnsRecordSet. Failed to generate endpoints and VIPs for DnsRecordSet [{0}].", dnsRecordSet.Identifier);

                    throw new DeploymentException(message);
                }

                var deploymentItem = topologyInstance.DeploymentItems.SingleOrDefault(di => string.Equals(di.ItemName, dnsRecordSet.SourceReference, StringComparison.OrdinalIgnoreCase));

                if (deploymentItem == null)
                {
                    var message = String.Format(CultureInfo.InvariantCulture, "Failed to generate endpoints and VIPs for DnsRecordSet [{0}] because it refers to DeploymentItem [{1}] which was not found in topology instance [{2}].", dnsRecordSet.Identifier, dnsRecordSet.SourceReference, topologyInstance.InstanceId);

                    throw new DeploymentException(message);
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removing endpoints in deployment item [{0}] to process Virtual IPs.", deploymentItem.ItemName);
                deploymentItem.Endpoints.RemoveAll(e => true);
            }

            foreach (var dnsRecordSet in topologyInstance.DnsRecordSets.Where(dnsRec => string.Equals(dnsRec.RecordType, DnsRecordSet.VirtualIPRecordType, StringComparison.OrdinalIgnoreCase)))
            {
                var deploymentItem = topologyInstance.DeploymentItems.SingleOrDefault(di => string.Equals(di.ItemName, dnsRecordSet.SourceReference, StringComparison.OrdinalIgnoreCase));
                var cloudServiceInstance = topologyInstance.CloudServices.SelectMany(cs => cs.CloudServiceInstances).SingleOrDefault(csi => string.Equals(csi.Identifier, deploymentItem.CloudServiceInstanceId));

                if (cloudServiceInstance == null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Failed to find cloud service instance [{0}] in topology instance [{1}] when processing DnsRecordSet [{2}]. Skipping to process DnsRecordSet.", deploymentItem.CloudServiceInstanceId, topologyInstance.InstanceId, dnsRecordSet.Identifier);

                    continue;
                }

                // Adding a VIP to cloud service instance
                var vip = new Microsoft.DynamicsOnline.Deployment.Service.Catalog.Model.VirtualIP
                {
                    Identifier = string.Join(".", cloudServiceInstance.Identifier, dnsRecordSet.Identifier),
                    Name = dnsRecordSet.Identifier,
                };
                cloudServiceInstance.VirtualIPs.Add(vip);
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Added VIP [{0}] to cloud service instance [{1}].", vip.Name, cloudServiceInstance.Identifier);

                // Adding a ReservedIP to topology instance
                var reservedIP = new Microsoft.DynamicsOnline.Deployment.Service.Catalog.Model.ReservedIP
                {
                    Identifier = string.Join(".", cloudServiceInstance.Identifier, dnsRecordSet.Identifier),
                    Name = string.Join(".", cloudServiceInstance.Name, dnsRecordSet.Identifier),
                    VirtualIP = vip.Identifier
                };
                topologyInstance.ReservedIPs.Add(reservedIP);
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Added ReservedIP [{0}] to topology instance [{1}].", reservedIP.Name, topologyInstance.InstanceId);

                string distribution;
                if (!dnsRecordSet.TryGetCustomizationValue(CommonCustomizationNames.EndpointDistribution, out distribution))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "No endpoint distribution found for dns [{0}] in topology instance [{1}].", dnsRecordSet.Identifier, topologyInstance.InstanceId);
                    distribution = "sourceIP";
                }

                int probeInterval = 0;
                if (!dnsRecordSet.TryGetCustomizationValue<int>(CommonCustomizationNames.EndpointProbeInterval, out probeInterval))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "No endpoint probe interval found for dns [{0}] in topology instance [{1}].", dnsRecordSet.Identifier, topologyInstance.InstanceId);
                }

                int probeTimeout = 0;
                if (!dnsRecordSet.TryGetCustomizationValue<int>(CommonCustomizationNames.EndpointProbeTimeOut, out probeTimeout))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "No endpoint probe timeout found for dns [{0}] in topology instance [{1}].", dnsRecordSet.Identifier, topologyInstance.InstanceId);
                }

                var endpoint = new Endpoint
                {
                    Name = dnsRecordSet.Identifier,
                    VirtualIP = vip.Identifier,
                    LocalPort = port,
                    Port = DeploymentConstants.HttpsPublicPortNumber,
                    Protocol = "TCP",
                    ProbePort = port,
                    Configuration = EndpointConfiguration.ExternalLoadBalancer,
                    Distribution = distribution,
                    AddToFirstInstanceOnly = false,
                    DirectServerReturn = false,
                    IdleTimeoutInMinutes = 0,
                    ProbeTimeoutInSeconds = probeTimeout,
                    ProbeIntervalInSeconds = probeInterval
                };

                do
                {
                    port++;
                }
                while (invalidHttpsPortNumbers.Contains(port));

                deploymentItem.Endpoints.Add(endpoint);
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Added Endpoint [{0}] to deployment item [{1}].", endpoint.Name, deploymentItem.ItemName);

                dnsRecordSet.SourceType = DnsSourceType.ReservedIP.ToString();
                dnsRecordSet.SourceReference = reservedIP.Identifier;
                dnsRecordSet.RecordType = "A";
            }
        }

        /// <summary>
        /// Processes the DNS record set in given topology instance.
        /// </summary>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="tenantRegistration">The tenant registration.</param>
        /// <param name="dnsNameSuffix">The DNS name suffix.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>
        /// Returns true if the cloud service names were allocated.
        /// </returns>
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        [SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "DNS is case-insensitive.")]
        private bool ProcessDnsRecordSet(TopologyInstance topologyInstance, TenantRegistration tenantRegistration, string dnsNameSuffix, out HttpResponseMessage errorMessage)
        {
            if (topologyInstance.DnsRecordSets == null || !topologyInstance.DnsRecordSets.Any())
            {
                errorMessage = null;
                return true;
            }

            bool enableDnsRecordCreation = false;
            if (!topologyInstance.TryGetCustomizationValue<bool>(CommonCustomizationNames.EnableDNSRecordCreationCustomization, out enableDnsRecordCreation) || !enableDnsRecordCreation)
            {
                Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Enable DNS record creation customization is not set to true for topology '{0}' Id '{1}'. Skipping to process DNS record set.",
                        topologyInstance.TopologyName,
                        topologyInstance.InstanceId);
                errorMessage = null;
                return true;
            }

            DnsZone dnsZone;
            if (!this.TryGetDnsZone(topologyInstance, out dnsZone, out errorMessage))
            {
                return false;
            }

            // Only look for CHE zone name when environment is CHE and topology is not from CRM 
            // Call graph API and see if wild card URL exists for Tenant, if yes we will continue, if no we will use another zone name
            if (!topologyInstance.IsSandboxOrProdTopology() && !topologyInstance.ProductName.StartsWith(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.CRMProductNamePrefix, StringComparison.Ordinal))
            {
                if (!ServiceControllerHelper.VerifyWildCardUrl(topologyInstance, dnsZone))
                {
                    // Get CHE zone name for the environment
                    DnsZoneManager cHEZoneManager = new DnsZoneManager();
                    string cHEZoneIdentifier;
                    string defaultDnsZoneIdentifier = dnsZone.Identifier;

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Overriding default DNS zone [{0}].", defaultDnsZoneIdentifier);
                    if (string.Equals(topologyInstance.ProductName, Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.AX7ProductName, StringComparison.Ordinal))
                    {
                        cHEZoneIdentifier = Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.AX7CHEDnsZoneIdentifier;
                    }
                    else if (string.Equals(topologyInstance.ProductName, Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.RetailProductName, StringComparison.Ordinal))
                    {
                        cHEZoneIdentifier = Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.RetailCHEDnsZoneIdentifier;
                    }
                    else
                    {
                        Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "CHE DNS zone not defined for Product name [{0}].", topologyInstance.ProductName);
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_NullOrEmptyParameterNoDefault);
                        return false;
                    }

                    dnsZone = cHEZoneManager.GetDnsZone(cHEZoneIdentifier);

                    if (dnsZone == null)
                    {
                        Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "CHE DNS zone could not be found for zoneIdentifier [{0}].", cHEZoneIdentifier);
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.DNSNameNotFoundInLookupTable);
                        return false;
                    }
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Setting 'DNS Zone Identifier' customization with new identifier [{0}].", cHEZoneIdentifier);
                    topologyInstance.SetCustomizationValue(CommonCustomizationNames.DNSZoneIdentifierCustomization, dnsZone.Identifier);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The default DNS zone [{0}] is overridden with CHE DNS zone [{1}].", defaultDnsZoneIdentifier, cHEZoneIdentifier);
                }
                else
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "CHE DNS Zone won't be used.");
                }
            }

            LookupManager lookupManager = new LookupManager(dnsZone.ZoneName);

            // If customization VanityUrl is provided then it replaces environment name usage + any randomization.
            // If customization EnforceEnvironmentNameInDns is enabled we do not use the suffix generated for the cloud service name.
            // This functionality is used in SaaS topologies for migrating environments side by side, preserving the dns names.
            string name;
            string vanityURL;
            bool enforceEnvironmentNameInDns = false;
            if (topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.VanityURL, out vanityURL) && !string.IsNullOrEmpty(vanityURL))
            {
                Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Using vanity URL [{0}] for DNS records; if the records already exist the deploy API will fail in validating the topology [{1}] with id [{2}].",
                        vanityURL,
                        topologyInstance.TopologyName,
                        topologyInstance.InstanceId);

                name = vanityURL;
            }
            else if (topologyInstance.TryGetCustomizationValue<bool>(CommonCustomizationNames.EnforceEnvironmentNameInDns, out enforceEnvironmentNameInDns) && enforceEnvironmentNameInDns)
            {
                Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Preserving environment name in DNS records; if the records already exist the deploy API will fail in validating the topology '{0}' with id '{1}'.",
                        topologyInstance.TopologyName,
                        topologyInstance.InstanceId);

                name = topologyInstance.InstanceId;
            }
            else
            {
                name = string.Concat(topologyInstance.InstanceId, dnsNameSuffix);
            }

            foreach (var dnsRecord in topologyInstance.DnsRecordSets)
            {
                // populate name from source if it is not populated
                if (String.IsNullOrWhiteSpace(dnsRecord.Name))
                {
                    string dnsRecordName = string.Format(CultureInfo.InvariantCulture, dnsRecord.NameFormat, name).ToLowerInvariant();
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "LookupTable: Inserting DNS record name [{0}]", dnsRecordName);
                    if (lookupManager.TryInsertEntity(dnsRecordName))
                    {
                        dnsRecord.Name = dnsRecordName;
                    }
                    else
                    {
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.DnsNameAlreadyExists);
                        return false;
                    }
                }
                else
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNS record name '{0}' already populated for this topology, continuing...", dnsRecord.Name);
                    continue;
                }

                if (String.IsNullOrWhiteSpace(dnsRecord.ZoneName))
                {
                    dnsRecord.ZoneName = dnsZone.ZoneName;
                }

                dnsRecord.SetCustomizationValue(CommonCustomizationNames.DnsRecordId, string.Empty);
                dnsRecord.SetCustomizationValue(CommonCustomizationNames.DNSLookupEntryAcquired, Boolean.TrueString);
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Generates the name of the cloud service.
        /// </summary>
        /// <param name="request">The deployment request.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>Returns true if the cloud service names were allocated.</returns>
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        private bool AllocateCloudServiceNames(DeploymentRequest request, out HttpResponseMessage errorMessage)
        {
            Contract.Requires(request != null);

            TopologyInstance topologyInstance = request.Topology;
            TenantRegistration tenantRegistration = request.TenantRegistration;

            if (topologyInstance.IsRunningInCloudServiceCompatibilityMode() || topologyInstance.CloudServices == null || !topologyInstance.CloudServices.Any())
            {
                errorMessage = null;
                return true;
            }

            var cloudServiceInstances = topologyInstance.CloudServices.SelectMany(cs => cs.CloudServiceInstances).ToArray();
            LookupManager lookupManager = new LookupManager(AzureEnvironmentConfig.AzureBaseHost);
            string cloudServiceNameSuffix = string.Empty;
            foreach (var cloudServiceInstance in cloudServiceInstances)
            {
                if (string.IsNullOrWhiteSpace(cloudServiceInstance.Name))
                {
                    string cloudServiceName = Tasks.CommonHelper.GenerateCloudServiceName(topologyInstance, tenantRegistration, ref cloudServiceNameSuffix, cloudServiceInstance.Identifier);

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "LookupTable: Inserting cloud service name [{0}]", cloudServiceName);
                    if (lookupManager.TryInsertEntity(cloudServiceName))
                    {
                        cloudServiceInstance.Name = cloudServiceName;
                        cloudServiceInstance.SetCustomizationValue(CommonCustomizationNames.CloudServiceLookupEntryAcquired, Boolean.TrueString);
                    }
                    else
                    {
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.DnsNameAlreadyExists);
                        return false;
                    }
                }

                cloudServiceInstance.Location = topologyInstance.CloudStorageLocation ?? tenantRegistration.GetDefaultStorageLocation();

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Azure Cloud Service name for instance '{0}' is '{1}'.", cloudServiceInstance.Identifier, cloudServiceInstance.Name);
            }

            this.PopulateEndpointsAndVIPs(topologyInstance);

            if (!this.ProcessDnsRecordSet(topologyInstance, tenantRegistration, cloudServiceNameSuffix, out errorMessage))
            {
                return false;
            }

            foreach (DeploymentModule module in topologyInstance.Modules)
            {
                module.OnResourceAllocation(request);
            }

            this.UpdateCloudServiceNames(topologyInstance);
            errorMessage = null;

            return true;
        }

        /// <summary>
        /// Sets the cloud service names of the topology and deployment items based on
        /// the cloud service instances existing in the topology.
        /// This is needed because deployment code is unaware of cloud service instance objects,
        /// and is expecting the cloud service name to be set at the topology or deployment item level.
        /// </summary>
        /// <param name="topologyInstance">The topology instance.</param>
        private void UpdateCloudServiceNames(TopologyInstance topologyInstance)
        {
            var cloudServicesDictionary = topologyInstance.CloudServices.ToDictionary(cs => cs.Identifier);
            var cloudServiceInstanceDictionary = topologyInstance.CloudServices.SelectMany(cs => cs.CloudServiceInstances).ToDictionary(csi => csi.Identifier);

            // Set cloud service name at the topology level
            if (!string.IsNullOrWhiteSpace(topologyInstance.CloudServiceId))
            {
                var topologyCloudService = cloudServicesDictionary[topologyInstance.CloudServiceId];
                var topologyCloudServiceIdentifier = topologyCloudService.GenerateCloudServiceInstanceId(topologyInstance, null, null, null);

                CloudServiceInstance cloudServiceInstance;
                if (!cloudServiceInstanceDictionary.TryGetValue(topologyCloudServiceIdentifier, out cloudServiceInstance))
                {
                    // Pick the first cloud service instance.
                    cloudServiceInstance = topologyCloudService.CloudServiceInstances.FirstOrDefault();
                }

                if (cloudServiceInstance != null)
                {
                    topologyInstance.CloudServiceName = cloudServiceInstance.Name;
                }
            }

            var deploymentItems = topologyInstance.DeploymentItems.Where(di => !string.IsNullOrWhiteSpace(di.CloudServiceId) && di.IsPrimary());

            // Do a last pass on the deployment items and set the cloud service name attribute so it plays well with existing code:
            foreach (var deploymentItem in deploymentItems.Where(di => di.GetInstanceCount() > 0))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Accessing cloud service '{0}' in topology instance '{1}'", deploymentItem.CloudServiceId, topologyInstance.InstanceId);
                if (!cloudServicesDictionary.ContainsKey(deploymentItem.CloudServiceId))
                {
                    Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Could not find cloud service '{0}' in topology instance '{1}'", deploymentItem.CloudServiceId, topologyInstance.InstanceId);
                    continue;
                }

                var cloudService = cloudServicesDictionary[deploymentItem.CloudServiceId];
                var cloudServiceIdentifier = cloudService.GenerateCloudServiceInstanceId(topologyInstance, deploymentItem, null, null);

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Accessing cloud service instance '{0}' in cloud service '{1}' in topology instance '{2}'", cloudServiceIdentifier, deploymentItem.CloudServiceId, topologyInstance.InstanceId);
                if (!cloudServiceInstanceDictionary.ContainsKey(cloudServiceIdentifier))
                {
                    Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Could not find cloud service instance '{0}' in cloud service '{1}' in topology instance '{2}'", cloudServiceIdentifier, deploymentItem.CloudServiceId, topologyInstance.InstanceId);
                    continue;
                }

                var cloudServiceInstance = cloudServiceInstanceDictionary[cloudServiceIdentifier];
                deploymentItem.CloudServiceName = cloudServiceInstance.Name;
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The cloud service name for deployment item '{0}' has been set to '{1}' in topology instance '{2}'", deploymentItem.ItemName, deploymentItem.CloudServiceName, topologyInstance.InstanceId);

                // For SQLAlwaysOn we need a separate cloud service for quorum. Reuse an existing cloud service based on size if available.
                if (deploymentItem.IsItemType(DeploymentItemType.SqlAlwaysOn) && deploymentItem.GetInstanceCount() % 2 == 0)
                {
                    // we set this previously
                    string quorumCloudServiceInstanceId = null;

                    if (deploymentItem.TryGetCustomizationValue<string>(CommonCustomizationNames.QuorumCloudServiceId, out quorumCloudServiceInstanceId) &&
                        !string.IsNullOrEmpty(quorumCloudServiceInstanceId) &&
                        cloudServiceInstanceDictionary[quorumCloudServiceInstanceId] != null)
                    {
                        // save the cloud service name for quorum as a customization
                        deploymentItem.SetCustomizationValue(CommonCustomizationNames.QuorumCloudServiceName, cloudServiceInstanceDictionary[quorumCloudServiceInstanceId].Name);
                    }
                    //// on the else case quorum (backward compatibility) will use the same cloud service name as SQLAlwaysOn, existing behavior
                }
            }
        }

        /// <summary>
        /// Tries to process image gallery customizations.
        /// </summary>
        /// <param name="tenantRegistration">The tenant registration.</param>
        /// <param name="topology">The topology.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>
        /// Whether or not the topology was processed successfully.
        /// </returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.StyleCop.CSharp.NamingRules", "SA1305:FieldNamesMustNotUseHungarianNotation", Justification = "Not a hungarian notation.")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmantainableCode", Justification = "This is by design.")]
        private bool TryProcessImageGalleryCustomization(TenantRegistration tenantRegistration, TopologyInstance topology, out HttpResponseMessage errorMessage)
        {
            Contract.Requires(tenantRegistration != null);
            Contract.Requires(tenantRegistration.AzureSubscriptionId != Guid.Empty);
            Contract.Requires(topology != null);

            if (topology.ShouldUseAzureResourceManager())
            {
                const string LatestImageVersionLabel = "latest";
                string location = topology.GetARMLocation();

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Start to validate availability of Azure Image Gallery in location [{0}].", location);

                using (var manager = tenantRegistration.CreateAzureResourceManager())
                {
                    var virtualMachineDeploymentItems = topology.GetVirtualMachines();

                    foreach (var vm in virtualMachineDeploymentItems)
                    {
                        string sku;
                        if (!vm.TryGetCustomizationValue<string>(CommonCustomizationNames.AzureImageSKU, out sku) || String.IsNullOrWhiteSpace(sku))
                        {
                            string message = String.Format(CultureInfo.InvariantCulture, "Could not get value of customization [{0}] in virtual machine deployment item with name [{1}].", CommonCustomizationNames.AzureImageSKU, vm.ItemName);

                            Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, new DOException((int)ServiceErrorCode.InvalidCustomizationValue, message), message);

                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidCustomizationValue, CommonCustomizationNames.AzureImageSKU);
                            return false;
                        }

                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Requesting image metadata for SKU [{0}]", sku);
                        AzureVMImageMetadataTableItem vmImageMetadata = AzureVMImageMetadataDAC.GetVmImageMetadata(sku);

                        if (topology.ProductName.StartsWith(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.CRMProductNamePrefix, StringComparison.Ordinal))
                        {
                            if (vm.TryGetCustomizationValue<string>(CommonCustomizationNames.AzureImagePublisher, out string publisher) || !string.IsNullOrWhiteSpace(publisher))
                            {
                                vmImageMetadata.Publisher = publisher;
                            }
                            else
                            {
                                string message = string.Format(CultureInfo.InvariantCulture, "Could not get value of customization [{0}] in virtual machine deployment item with name [{1}]. Defaulting to metadata value [{2}].", CommonCustomizationNames.AzureImagePublisher, vm.ItemName, vmImageMetadata.Publisher);

                                Tracer.WriteWarningEvent(TraceComponent.DeploymentServiceApi, new DOException((int)ServiceErrorCode.InvalidCustomizationValue, message), message);
                            }

                            if (vm.TryGetCustomizationValue<string>(CommonCustomizationNames.AzureImageOffer, out string offer) || !string.IsNullOrWhiteSpace(offer))
                            {
                                vmImageMetadata.Offer = offer;
                            }
                            else
                            {
                                string message = string.Format(CultureInfo.InvariantCulture, "Could not get value of customization [{0}] in virtual machine deployment item with name [{1}]. Defaulting to metadata value [{2}].", CommonCustomizationNames.AzureImageOffer, vm.ItemName, vmImageMetadata.Offer);

                                Tracer.WriteWarningEvent(TraceComponent.DeploymentServiceApi, new DOException((int)ServiceErrorCode.InvalidCustomizationValue, message), message);
                            }
                        }

                        string imageVersion;
                        if (!vm.TryGetCustomizationValue<string>(CommonCustomizationNames.AzureImageSKUVersion, out imageVersion) || String.IsNullOrWhiteSpace(imageVersion))
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Customization for VM image version was not provided for deployment item [{0}]. Defaulting to latest version.", vm.ItemName);
                            imageVersion = LatestImageVersionLabel;
                        }

                        if (String.Equals(imageVersion, LatestImageVersionLabel, StringComparison.OrdinalIgnoreCase))
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Requested latest version for VM image for deployment item [{0}]. Using latest version from metadata: [{1}].", vm.ItemName, vmImageMetadata.LatestVersion);
                            imageVersion = vmImageMetadata.LatestVersion;
                        }

                        // getting all images with the same SKU
                        var images = manager.Compute.Value.GetVirtualMachineImageVersions(location, vmImageMetadata.Publisher, vmImageMetadata.Offer, sku);

                        if (!images.Any())
                        {
                            Tracer.WriteWarningEvent(TraceComponent.DeploymentServiceApi, null, "Could not find any image corresponding to metadata [{0}] in location [{1}]", vmImageMetadata, location);
                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.MissingAzureBaseOsImage);
                            return false;
                        }

                        // searching image with necessary version
                        if (!String.Equals(imageVersion, LatestImageVersionLabel, StringComparison.OrdinalIgnoreCase))
                        {
                            var necessaryImage = images.FirstOrDefault(im => String.Equals(im.Name, imageVersion, StringComparison.OrdinalIgnoreCase));

                            if (necessaryImage == null)
                            {
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Could not find the VM image version [{0}] in Azure Image Gallery in location [{1}]. Defaulting to latest from Azure Gallery.", imageVersion, location);
                                imageVersion = LatestImageVersionLabel;
                            }
                            else
                            {
                                Tracer.WriteExecutionEvent(
                                    TraceComponent.DeploymentServiceApi,
                                    "The VM image ['publisher': '{0}', 'offer': '{1}', 'sku': '{2}', version: '{3}'] is available in location [{4}]. Virtual machine deployment item [{5}].",
                                    vmImageMetadata.Publisher,
                                    vmImageMetadata.Offer,
                                    sku,
                                    imageVersion,
                                    location,
                                    vm.ItemName);
                            }
                        }

                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Value of VM image version that will be used for deployment item [{0}] is [{1}].", vm.ItemName, imageVersion);
                        vm.SetCustomizationValue<string>(CommonCustomizationNames.AzureImageSKUVersion, imageVersion);
                    }
                }

                errorMessage = null;
                return true;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Selecting Azure Gallery OS images in subscription '{0}' for topology instance '{1}'", tenantRegistration.AzureSubscriptionId.ToString(), topology.InstanceId);

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Fetching list of Azure OS images available for subscription '{0}'.", tenantRegistration.AzureSubscriptionId);
            IServiceManagement azureProxy = tenantRegistration.CreateAzureServiceManagement();
            var imageList = azureProxy.ListOSImages(tenantRegistration.AzureSubscriptionId.ToString());

            foreach (DeploymentItem deploymentItem in topology.DeploymentItems)
            {
                bool useOSImageFromGalleryCustomization;
                if (deploymentItem.TryGetCustomizationValue<bool>(CommonCustomizationNames.UseOsImageFromGalleryCustomization, out useOSImageFromGalleryCustomization))
                {
                    var osDeploymentFile = deploymentItem.DeploymentFiles.SingleOrDefault(f => f.FileType == DeploymentFileType.OsVHD.ToString());
                    var azureOsImageFamilyNameCustomization = deploymentItem.Customizations.SingleOrDefault(c => CommonCustomizationNames.AzureOsImageFamilyName.Equals(c.FieldName, StringComparison.OrdinalIgnoreCase));

                    if (useOSImageFromGalleryCustomization)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Processing deployment item '{0}' to use OS image from Azure Gallery.", deploymentItem.ItemName);

                        if (azureOsImageFamilyNameCustomization == null || string.IsNullOrWhiteSpace(azureOsImageFamilyNameCustomization.SelectedValue))
                        {
                            string message = Tracer.FormatMessage("Topology does not have an OS family image specified in the customization for deployment item {0}.", deploymentItem.ItemName);

                            Tracer.WriteErrorEvent(
                                TraceComponent.DeploymentServiceApi,
                                new DOException((int)ServiceErrorCode.MissingAzureBaseOsImage, message),
                                message);

                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.MissingAzureBaseOsImage);
                            return false;
                        }

                        if (osDeploymentFile != null)
                        {
                            deploymentItem.DeploymentFiles.Remove(osDeploymentFile);
                        }

                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Deployment item '{0}' will use OS image from Azure Gallery.", deploymentItem.ItemName);
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Processing deployment item '{0}' to use custom OS image.", deploymentItem.ItemName);

                        if (osDeploymentFile == null)
                        {
                            string message = Tracer.FormatMessage("Topology does not have an OS deployment file specified for deployment item {0}.", deploymentItem.ItemName);

                            Tracer.WriteErrorEvent(
                                TraceComponent.DeploymentServiceApi,
                                new DOException((int)ServiceErrorCode.MissingAzureBaseOsImage, message),
                                message);

                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.MissingAzureBaseOsImage);
                            return false;
                        }

                        if (azureOsImageFamilyNameCustomization != null)
                        {
                            deploymentItem.Customizations.Remove(azureOsImageFamilyNameCustomization);
                        }

                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Deployment item '{0}' will use custom OS image.", deploymentItem.ItemName);
                    }
                }

                if (deploymentItem.UseAzureImage)
                {
                    Customization imageFamilyCustomization = deploymentItem.Customizations.FirstOrDefault(c => String.Equals(c.FieldName, CommonCustomizationNames.AzureOsImageFamilyName));
                    Customization imageLabelCustomization = deploymentItem.Customizations.FirstOrDefault(c => String.Equals(c.FieldName, CommonCustomizationNames.AzureOsImageLabel));

                    if ((imageFamilyCustomization != null && !String.IsNullOrWhiteSpace(imageFamilyCustomization.SelectedValue)) ||
                        (imageLabelCustomization != null && !String.IsNullOrWhiteSpace(imageLabelCustomization.SelectedValue)))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}': deployment item '{1}' requires Image of family '{2}'", tenantRegistration.AzureSubscriptionId.ToString(), deploymentItem.ItemName, imageFamilyCustomization.SelectedValue);

                        IEnumerable<OSImage> suitableImages = imageList.Where(image => String.Equals(image.OS, "Windows")
                                                            && ((imageFamilyCustomization != null && String.Equals(image.ImageFamily, imageFamilyCustomization.SelectedValue, StringComparison.OrdinalIgnoreCase))
                                                            || (imageLabelCustomization != null && String.Equals(image.Label, imageLabelCustomization.SelectedValue, StringComparison.OrdinalIgnoreCase)))
                                                            && !String.IsNullOrWhiteSpace(image.Location) && image.Location.Split(';').Contains(topology.CloudServiceLocation));

                        if (suitableImages.Any())
                        {
                            var image = suitableImages.OrderByDescending(newestImage => newestImage.PublishedDate).First();

                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}': deployment item '{1}' using image '{2}'", tenantRegistration.AzureSubscriptionId.ToString(), deploymentItem.ItemName, image.Name);

                            Customization imageCustomization = deploymentItem.Customizations.FirstOrDefault(c => String.Equals(c.FieldName, CommonCustomizationNames.AzureOsImageName));
                            if (imageCustomization != null)
                            {
                                imageCustomization.SelectedValue = image.Name;
                            }
                            else
                            {
                                deploymentItem.Customizations.Add(new Customization()
                                {
                                    SelectedValue = image.Name,
                                    FieldName = CommonCustomizationNames.AzureOsImageName,
                                    ValueType = CustomizationValueType.String.ToString(),
                                });
                            }
                        }
                        else
                        {
                            string message = Tracer.FormatMessage(
                                "Subscription '{0}' does not have an OS image of family '{1}' in the Image Gallery that is required by deployment item '{2}'.",
                                tenantRegistration.AzureSubscriptionId,
                                imageFamilyCustomization.SelectedValue,
                                deploymentItem.ItemName);

                            Tracer.WriteErrorEvent(
                                TraceComponent.DeploymentServiceApi,
                                new DOException((int)ServiceErrorCode.MissingAzureBaseOsImage, message),
                                message);

                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.MissingAzureBaseOsImage);
                            return false;
                        }
                    }
                }
            }

            errorMessage = null;

            return true;
        }

        /// <summary>
        /// Tries to process a dynamic build topology.
        /// </summary>
        /// <param name="topology">Topology to be resolved.</param>
        /// <param name="errorMessage">Message of the error, if any.</param>
        /// <returns>Whether or not the topology was processed successfully.</returns>
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "Pending.")]
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "BlobHelper is wrapping exceptions in such a way that makes it difficult to be precise.")]
        private bool TryProcessDynamicBuildTopology(DeploymentTopology topology, out HttpResponseMessage errorMessage)
        {
            if (!topology.IsBuildDynamic())
            {
                errorMessage = null;
                return true;
            }

            string build;
            string branch;
            Guid catalogComponentId;
            Component selectedComponent;

            ComponentManager componentManager = new ComponentManager();

            if (topology.TryGetCustomizationValue(CommonCustomizationNames.Build, out build) && !String.IsNullOrWhiteSpace(build) &&
                 topology.TryGetCustomizationValue(CommonCustomizationNames.Branch, out branch) && !String.IsNullOrWhiteSpace(branch))
            {
                // Build/branch selection
                string product;
                string version;
                string customProductVersion;
                topology.TryGetCustomizationValue(CommonCustomizationNames.Product, out product);
                topology.TryGetCustomizationValue(CommonCustomizationNames.Version, out version);
                topology.TryGetCustomizationValue(CommonCustomizationNames.CustomProductVersion, out customProductVersion);

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Dynamic build: Fetching catalog Component Id for build [{0}], branch [{1}], product [{2}], version [{3}]", build, branch, product, customProductVersion ?? version);
                selectedComponent = componentManager.GetComponent(product, customProductVersion ?? version, build, branch);
                if (selectedComponent == null)
                {
                    string message = string.Format(CultureInfo.InvariantCulture, "Invalid product build and branch for a dynamic build topology. Could not retrieve catalog Component Id for build [{0}] branch [{1}] product [{2}] product version [{3}]", build, branch, product, version);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                    errorMessage = this.CreateErrorResponse(message);
                    return false;
                }

                catalogComponentId = selectedComponent.ComponentId;
            }
            else
            {
                // Custom build selection
                string catalogComponent;
                topology.TryGetCustomizationValue(CommonCustomizationNames.ProductVersion, out catalogComponent);

                if (String.IsNullOrWhiteSpace(catalogComponent))
                {
                    errorMessage = this.CreateErrorResponse("Did not select a product version or provide a custom version for a dynamic build topology.");
                    return false;
                }

                if (!Guid.TryParse(catalogComponent, out catalogComponentId))
                {
                    errorMessage = this.CreateErrorResponse("Invalid product version for a dynamic build topology. Could not parse the selected value to GUID.");
                    return false;
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Dynamic build: Fetching catalog Component Id [{0}]", catalogComponentId);
                selectedComponent = componentManager.GetComponent(catalogComponentId);
                if (selectedComponent == null)
                {
                    string message = string.Format(CultureInfo.InvariantCulture, "Invalid product version for a dynamic build topology. Could not retrieve catalog Component Id for catalog component [{0}] with id [{1}]", catalogComponent, catalogComponentId);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                    errorMessage = this.CreateErrorResponse(message);
                    return false;
                }

                build = selectedComponent.ComponentVersion;
                branch = selectedComponent.Label;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Dynamic build: Using catalog Component [{0}] for build [{1}] and branch [{2}]", selectedComponent, build, branch);

            if (!String.IsNullOrWhiteSpace(selectedComponent.State) && String.Equals(selectedComponent.State, Component.ComponentState.InProgress.ToString(), StringComparison.OrdinalIgnoreCase))
            {
                string message = string.Format(CultureInfo.InvariantCulture, "Component [{0}] is not ready for consumption. Please try again at a later time.", selectedComponent);
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                errorMessage = this.CreateErrorResponse(message);
                return false;
            }

            topology.TrySetCustomizationValue(CommonCustomizationNames.Branch, branch);
            topology.TrySetCustomizationValue(CommonCustomizationNames.Build, build);
            topology.TrySetCustomizationValue(CommonCustomizationNames.ProductVersion, catalogComponentId.ToString());

            var artifactManager = new ArtifactManager();
            var artifacts = artifactManager.GetArtifactsByComponentId(catalogComponentId, false);
            if (!artifacts.Any())
            {
                errorMessage = this.CreateErrorResponse("Invalid product version for a dynamic build topology. The select product version does not exist. Please refresh and try again later.");
                return false;
            }

            if (!this.TryProcessArtifactDeploymentFiles(topology, artifacts, out errorMessage))
            {
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Process the deployment elastic pool settings.
        /// </summary>
        /// <param name="topology">Topology to be resolved.</param>
        /// <param name="errorMessage">Message of the error, if any.</param>
        /// <returns>Whether or not the topology was processed successfully.</returns>
        private bool TryProcessElasticPoolSettings(TopologyInstance topology, out HttpResponseMessage errorMessage)
        {
            List<DeploymentItem> deploymentItems = topology.DeploymentItems.ToList();

            // Should only contain the primary databases and not the Disaster Recovery/Read-Only databases.
            List<DeploymentItem> primaryElasticDatabases = deploymentItems.GetAll(DeploymentItemType.AzureSQLDatabase)
            .Where(db => String.Equals(db.ParentItemName, CommonDeploymentItemNames.AppDBServerName) && db.IsElasticPoolEnabled())
            .ToList();

            if (!primaryElasticDatabases.Any())
            {
                errorMessage = null;
                return true;
            }

            if (string.IsNullOrEmpty(DbmsConfig.DbmsManagementEndpoint) || string.IsNullOrEmpty(DbmsConfig.DbmsManagementResource))
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "There is either no Database Management System Endpoint or Resource defined in the ServiceModel Configuration. Setting all databases to be Non-Elastic based for Topology Instance [{0}].",
                    topology.InstanceId);

                foreach (DeploymentItem elasticDatabase in primaryElasticDatabases)
                {
                    elasticDatabase.SetCustomizationValue(CommonCustomizationNames.ElasticPoolEnabled, CommonCustomizationNames.EnabledNo);
                }

                errorMessage = null;
                return true;
            }

            string deploymentLocation = topology.CloudStorageLocation;
            string deploymentFailoverLocation = topology.DisasterRecoveryLocation;

            string topologySkuType;

            // Check if the primary region is supported for all environments.
            // If the environment is a production offer SKU then also check the fail over region.
            if (!AzureSQLLocations.IsElasticPoolSupported(deploymentLocation) ||
                (topology.TryGetCustomizationValue(CommonCustomizationNames.LcsEnvironmentTag, out topologySkuType) && string.Equals(topologySkuType, CommonCustomizationNames.LcsEnvironmentTagProd, StringComparison.OrdinalIgnoreCase) && !AzureSQLLocations.IsElasticPoolSupported(deploymentFailoverLocation)))
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "The selected region and/or its failover region are not supported for elastic pool deployments. Setting all databases to be Non-Elastic based for Topology Instance [{0}].",
                    topology.InstanceId);

                IEnumerable<DeploymentItem> revertElasticDatabases = topology.DeploymentItems.GetAll(DeploymentItemType.AzureSQLDatabase).Where(di => di.IsElasticPoolEnabled());

                foreach (DeploymentItem elasticDatabase in revertElasticDatabases)
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Setting the deployment Item [{0}] to elastic pool disabled on Topology Instance [{1}].",
                        elasticDatabase,
                        topology.InstanceId);

                    elasticDatabase.SetCustomizationValue(CommonCustomizationNames.ElasticPoolEnabled, CommonCustomizationNames.EnabledNo);
                }

                errorMessage = null;
                return true;
            }

            // Check that the specific Deployment Item is enabled in the specified region.
            foreach (DeploymentItem elasticDatabase in primaryElasticDatabases)
            {
                if (!AzureSQLLocations.IsElasticPoolSupported(deploymentLocation, elasticDatabase.ItemName, topologySkuType))
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Deployment Item [{0}] is not supported in a region [{1}]. Elastic pool has been disabled on deployment item [{0}] in Topology Instance [{2}].",
                        elasticDatabase,
                        deploymentLocation,
                        topology.InstanceId);

                    elasticDatabase.SetCustomizationValue(CommonCustomizationNames.ElasticPoolEnabled, CommonCustomizationNames.EnabledNo);
                }

                // Making sure that the if the database has an offline secondary enabled to check its region is supported as well.
                IEnumerable<DeploymentItem> relatedDatabases = deploymentItems.GetAll(DeploymentItemType.AzureSQLDatabase)
                    .Where(d => d.HasCustomizationValue(CommonCustomizationNames.AzureSQLDatabasePrimaryCopy, elasticDatabase.ItemName))
                    .Where(d => d.HasCustomizationValue(CommonCustomizationNames.AzureSQLDatabaseCopyType, (int)AzureDatabaseCopyOperation.CopyType.Offline));

                if (relatedDatabases.Any() && !AzureSQLLocations.IsElasticPoolSupported(deploymentFailoverLocation, elasticDatabase.ItemName, topologySkuType))
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Deployment Item [{0}] has an Offline-Secondary database that is not supported in a region [{1}]. Elastic pool has been disabled on deployment item [{0}] in Topology Instance [{2}].",
                        elasticDatabase,
                        deploymentFailoverLocation,
                        topology.InstanceId);

                    elasticDatabase.SetCustomizationValue(CommonCustomizationNames.ElasticPoolEnabled, CommonCustomizationNames.EnabledNo);
                }
            }

            primaryElasticDatabases = deploymentItems.GetAll(DeploymentItemType.AzureSQLDatabase)
            .Where(db => String.Equals(db.ParentItemName, CommonDeploymentItemNames.AppDBServerName) && db.IsElasticPoolEnabled())
            .ToList();

            // Looking for the Item names that match the primary database Item name. For example, if AxDB is passed I want the
            // AxDB-RO and AxDB-DR and have them both set to an elastic pool as well.
            foreach (DeploymentItem elasticDatabase in primaryElasticDatabases)
            {
                var relatedDatabases = deploymentItems.GetAll(DeploymentItemType.AzureSQLDatabase)
                    .Where(d => d.HasCustomizationValue(CommonCustomizationNames.AzureSQLDatabasePrimaryCopy, elasticDatabase.ItemName));

                foreach (DeploymentItem relatedDatabase in relatedDatabases)
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Setting the deployment Item [{0}] to elastic pool enabled on Topology Instance [{1}].",
                        relatedDatabase,
                        topology.InstanceId);

                    relatedDatabase.SetCustomizationValue(CommonCustomizationNames.ElasticPoolEnabled, CommonCustomizationNames.EnabledYes);
                    relatedDatabase.SetCustomizationValue(CommonCustomizationNames.DisasterRecoveryItemName, elasticDatabase.ItemName);
                }

                foreach (Credential credential in elasticDatabase.Credentials)
                {
                    // Reduces SQL Database login to database only for Elastic Pool Databases.
                    credential.IsSqlSysadmin = false;
                }
            }

            // Update the list with the primary databases plus any additional databases that are in an elastic pool.
            List<DeploymentItem> elasticDatabases = deploymentItems.GetAll(DeploymentItemType.AzureSQLDatabase)
                .Where(di => di.IsElasticPoolEnabled())
                .ToList();

            // Create new DeploymentItems of type AzureSQLServer to be the parents of the elastic Databases.
            foreach (DeploymentItem elasticDatabase in elasticDatabases)
            {
                DeploymentItem elasticSqlServer = new DeploymentItem();
                string elasticSqlServerName = elasticDatabase.GenerateElasticSQLServerItemName();
                elasticSqlServer.ItemName = elasticSqlServerName;
                elasticSqlServer.DisplayName = elasticDatabase.DisplayName;
                elasticSqlServer.ItemType = DeploymentItemType.AzureSQLServer.ToString();
                elasticSqlServer.SetCustomizationValue(CommonCustomizationNames.ElasticPoolEnabled, CommonCustomizationNames.EnabledYes);

                // Set the ParentItemName of the Database to the new one.
                elasticDatabase.ParentItemName = elasticSqlServerName;

                // Create a Pseudo-SQL Server Admin. This user will only have access to the Database.
                elasticSqlServer.Credentials = new List<Credential>()
                {
                    new Credential()
                    {
                        SymbolicName = CommonCustomizationNames.AzureSQLServerAdminSymbolicName,
                        UserName = "sqladmin",
                        IsLocal = true,
                        IsVisible = false,
                        IsSqlSysadmin = false
                    }
                };

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Creating a new SQL Server item [{0}] for the [{1}] database on Topology Instance [{2}].",
                    elasticSqlServer,
                    elasticDatabase,
                    topology.InstanceId);

                topology.DeploymentItems.Add(elasticSqlServer);
            }

            // Hide non-referenced SQL Servers
            if (!topology.DeploymentItems.GetAll(DeploymentItemType.AzureSQLDatabase).Any(di => !di.IsElasticPoolEnabled()))
            {
                foreach (DeploymentItem azureSQLServer in topology.DeploymentItems.GetAll(DeploymentItemType.AzureSQLServer).Where(di => !di.IsElasticPoolEnabled()))
                {
                    azureSQLServer.IsVisible = false;
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Tries to process the artifacts into the deployment files.
        /// </summary>
        /// <param name="topology">The target topology.</param>
        /// <param name="artifacts">The artifacts to add.</param>
        /// <param name="errorMessage">Message of the error, if any.</param>
        /// <returns>Whether or not the topology was processed successfully.</returns>
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "Pending.")]
        private bool TryProcessArtifactDeploymentFiles(DeploymentTopology topology, IEnumerable<Artifact> artifacts, out HttpResponseMessage errorMessage)
        {
            // We only push white listed files.
            string fileTypes;
            if (!topology.TryGetCustomizationValue(CommonCustomizationNames.BuildFileTypes, out fileTypes))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "No build file type customization found in topology. Defaulting to filter on BACPAC and VHD.");
                fileTypes = string.Join(DeploymentConstants.CustomizationPairSeparator.ToString(), Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.BacpacArtifact, Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.VHDArtifact);
            }

            List<string> artifactTypes = fileTypes.Split(DeploymentConstants.CustomizationPairSeparator).ToList();

            var filteredArtifacts = artifacts.Where(a => artifactTypes.Contains(a.ArtifactType));
            foreach (var deploymentItem in topology.DeploymentItems)
            {
                IEnumerable<Artifact> artifactsToAdd;

                if (deploymentItem.Components == null || !deploymentItem.Components.Any())
                {
                    artifactsToAdd = filteredArtifacts.Where(a => string.Equals(a.ServiceType, Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.CommonArtifact, StringComparison.OrdinalIgnoreCase));
                }
                else
                {
                    artifactsToAdd = filteredArtifacts.Where(a => string.Equals(a.ServiceType, Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.CommonArtifact, StringComparison.OrdinalIgnoreCase) ||
                                                                  deploymentItem.Components.Contains(a.ServiceType));
                }

                foreach (var componentArtifact in artifactsToAdd)
                {
                    DeploymentFile file = new DeploymentFile(componentArtifact);

                    deploymentItem.DeploymentFiles.Add(file);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Dynamic build: added deployment file [{0}] to deployment item [{1}]", file, deploymentItem);
                }

                // Validate .BACPAC files
                if (deploymentItem.IsItemType(DeploymentItemType.AzureSQLDatabase))
                {
                    string dataSetName;

                    // If the item intends a Data Set, and it doesn't have an external location, attempt to find it in the deployment files.
                    if (deploymentItem.TryGetCustomizationValue(CommonCustomizationNames.AzureSQLDatabaseDataset, out dataSetName) &&
                        !String.Equals(dataSetName, CommonCustomizationNames.SQLDatabaseNoDataset, StringComparison.OrdinalIgnoreCase) &&
                        !deploymentItem.HasCustomizationValue(CommonCustomizationNames.AzureSQLDatabaseDatasetLocation))
                    {
                        DeploymentFile bacpacFile = AzureSQLDatabaseDeploymentWorkflow.GetBACPACDeploymentFile(deploymentItem, dataSetName);
                        if (bacpacFile == null)
                        {
                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.AzureSQLBacpacFileMissing, deploymentItem.ItemName, dataSetName);
                            return false;
                        }
                    }
                }
            }

            IEnumerable<Artifact> deploymentComponentArtifacts = artifacts.Where(a => string.Equals(a.ArtifactType, "ServiceComponent", StringComparison.OrdinalIgnoreCase)).ToList();
            foreach (Artifact deploymentComponentArtifact in deploymentComponentArtifacts)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Retrieved deployment component artifact for '{0}' service.", deploymentComponentArtifact.ServiceType);

                IEnumerable<DeploymentComponent> deploymentComponentOverrides = this.GetDeploymentComponents(deploymentComponentArtifact);
                DeploymentComponent deploymentComponentOverride = deploymentComponentOverrides.FirstOrDefault(c => string.Equals(c.TopologyType, topology.TopologyType, StringComparison.OrdinalIgnoreCase));
                if (deploymentComponentOverride == null)
                {
                    deploymentComponentOverride = deploymentComponentOverrides.FirstOrDefault(c => string.Equals(c.TopologyType, "All", StringComparison.OrdinalIgnoreCase));
                }

                if (deploymentComponentOverride == null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Skipping to process deployment component artifact for '{0}' service. No matching deployment component found for current topology type.", deploymentComponentArtifact.ServiceType);
                    continue;
                }

                DeploymentComponent deploymentComponent = topology.DeploymentComponents.SingleOrDefault(c => string.Equals(c.Identifier, deploymentComponentOverride.Identifier, StringComparison.OrdinalIgnoreCase));
                if (deploymentComponent != null && deploymentComponent.DisableDynamicOverride)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The topology has disable deployment component override flag set. Skipping to process deployment component artifact for '{0}' service.", deploymentComponentArtifact.ServiceType);
                    continue;
                }

                if (deploymentComponentOverride.MinVersion != 0 && topology.TopologyVersion < deploymentComponentOverride.MinVersion)
                {
                    string message = string.Format(CultureInfo.InvariantCulture, "Invalid product build and branch for a dynamic build topology. The current topology version [{0}] is not compatible as the selected build requires at least version [{1}].", topology.TopologyVersion, deploymentComponentOverride.MinVersion);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                    errorMessage = this.CreateErrorResponse(message);
                    return false;
                }

                if (deploymentComponent != null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Replacing deployment component from build artifacts for '{0}' service.", deploymentComponentArtifact.ServiceType);

                    // Preserve the position of the deployment component
                    int deploymentComponentIndex = topology.DeploymentComponents.IndexOf(deploymentComponent);
                    topology.DeploymentComponents.Remove(deploymentComponent);
                    topology.DeploymentComponents.Insert(deploymentComponentIndex, deploymentComponentOverride);
                }
                else
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Skipping to replace deployment component for '{0}' service. The component is not present in topology.", deploymentComponentArtifact.ServiceType);
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Takes in the DeploymentTopology object and randomizes the Local Administrator Accounts to obscure the names.
        /// </summary>
        /// <param name="topology">The target topology.</param>
        /// <param name="errorMessage">Message of the error, if any.</param>
        /// <returns>Whether or not the topology was processed successfully.</returns>
        [SuppressMessage("Microsoft.StyleCop.CSharp.NamingRules", "SA1305:FieldNamesMustNotUseHungarianNotation", Justification = "Not a hungarian notation.")]
        private bool TryProcessCredentials(DeploymentTopology topology, out HttpResponseMessage errorMessage)
        {
            var vmDeploymentItem = topology.DeploymentItems.Where(di => di.IsItemType(DeploymentItemType.VirtualMachine));

            foreach (DeploymentItem di in vmDeploymentItem)
            {
                foreach (Credential cred in di.Credentials.Where(c => c.RandomizeUsername))
                {
                    if (String.Equals(cred.SymbolicName, CommonCustomizationNames.LocalAdminCredential))
                    {
                        cred.UserName = RandomData.GenerateRandomPrefixedName("Admin", 15);
                    }
                    else if (String.Equals(cred.SymbolicName, CommonCustomizationNames.LocalUserCredential))
                    {
                        cred.UserName = RandomData.GenerateRandomPrefixedName("User", 15);
                    }
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Gets the deployment components.
        /// </summary>
        /// <param name="deploymentComponentArtifact">The deployment component artifact.</param>
        /// <returns>The deployment components for the given artifact.</returns>
        private IEnumerable<DeploymentComponent> GetDeploymentComponents(Artifact deploymentComponentArtifact)
        {
            List<DeploymentComponent> components = new List<DeploymentComponent>();
            DeploymentTopology topology = Tasks.CommonHelper.RetrieveBuildArtifact<DeploymentTopology>(deploymentComponentArtifact);
            if (topology != null && topology.DeploymentComponents != null && topology.DeploymentComponents.Any())
            {
                components.AddRange(topology.DeploymentComponents);
            }

            return components;
        }

        /// <summary>
        /// Validates that the given topology can be deployed.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology will be deployed.</param>
        /// <param name="entity">The topology instance to be deployed.</param>
        /// <param name="tenantRegistration">Registration that corresponds to this tenant.</param>
        /// <param name="action">Deployment action.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be deployed, if any.</param>
        /// <returns>A value indicating whether or not the topology can be deployed.</returns>
        [SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmantainableCode", Justification = "Breaking into more function will increase code complexity.")]
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        private bool ValidateTopologyForDeploy(Guid tenantId, Guid azureSubscriptionId, TopologyInstance entity, TenantRegistration tenantRegistration, DeploymentRequest.DeploymentAction action, out HttpResponseMessage errorMessage)
        {
            RE.Regex topologyNameRegex = new RE.Regex(TopologyNameRegEx);
            if (!topologyNameRegex.IsMatch(entity.InstanceId))
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Topology instance id '{0}' did not match the regex {1}",
                    entity.InstanceId,
                    TopologyNameRegEx);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopologyName);
                return false;
            }

            // validate correctness of the topology values.
            // These are soft checks should be done early before the heavier checks that hit Azure.
            if (!this.ValidateTopologyConsistency(entity, azureSubscriptionId, tenantRegistration, action, out errorMessage))
            {
                return false;
            }

            if (!this.ValidateVMBaseDeploymentItems(entity.InstanceId, entity.GetPrimaryVirtualMachineItems(), out errorMessage))
            {
                return false;
            }

            // validate correctness of the customizations values. Keep it to server side validation of the values provided minimum then checks with Azure/etc.
            if (!this.ValidateCustomizations(entity, out errorMessage))
            {
                return false;
            }

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                "Validating that subscription [{0}] does not contain a topology with instance ID [{1}]",
                azureSubscriptionId.ToString(),
                entity.InstanceId);

            TopologyInstanceTableItem existingInstance = this.GetTopologyInstanceTableItem(tenantRegistration.TenantId, tenantRegistration.AzureSubscriptionId, entity.InstanceId, entity.EnvironmentGroup);
            if (existingInstance != null)
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "There already exists a topology instance in the TopologyInstance table for tenant [{0}] subscription [{1}] instance ID [{2}] and environment group [{3}]",
                    tenantRegistration.TenantId,
                    tenantRegistration.AzureSubscriptionId,
                    entity.InstanceId,
                    entity.EnvironmentGroup);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_DuplicateName);
                return false;
            }

            if (!this.ValidateSQLAzureAvailability(azureSubscriptionId, entity, out errorMessage))
            {
                return false;
            }

            List<TopologyInstance> ongoingTopologyInstances;
            this.GetDeployingTopologyInstances(tenantRegistration.TenantId, out ongoingTopologyInstances);

            if (entity.ShouldUseAzureResourceManager())
            {
                // If ARM, validate applications are correctly provisioned.
                IEnumerable<AADApplicationMetadata> applicationsMetadata = ActiveDirectoryApplicationDAC.GetApplicationMetadata(entity.ProductName);

                if (applicationsMetadata.Any())
                {
                    if (this.PopulateTenantApplications(tenantRegistration, entity.ProductName, tenantRegistration.ActiveDirectorySubscriptionTenantID, applicationsMetadata))
                    {
                        TenantRegistrationDAC.UpsertTenantRegistration(tenantRegistration, decryptAfterUpsert: true);
                    }

                    if (!this.TryRegisterRequiredARMResourceProviderNamespaces(tenantRegistration, entity, ARMConfig.RequiredResourceProviderNamespaces, out errorMessage))
                    {
                        Tracer.WriteExecutionEvent(
                                    TraceComponent.DeploymentServiceApi,
                                    "Attempted to register Azure resource providers for topology [{0}], subscription ID [{1}], but not all providers could be registered. Error message [{2}].",
                                    entity.InstanceId,
                                    tenantRegistration.AzureSubscriptionId.ToString(),
                                    errorMessage);
                        return false;
                    }
                }

                // We want to skip this check when we are creating an Elastic Pool.
                if (!entity.ShouldCreateElasticPools())
                {
                    if (!this.ValidateResourceGroupAvailability(tenantRegistration, entity, out errorMessage))
                    {
                        return false;
                    }
                }

                if (!this.ValidateARMStorageAccounts(entity, tenantRegistration, out errorMessage))
                {
                    return false;
                }

                if (!this.ValidateTopologyARMResourceAvailability(tenantRegistration, entity, ongoingTopologyInstances.Where(d => d.ShouldUseAzureResourceManager()).ToList(), out errorMessage))
                {
                    return false;
                }

                if (!this.ValidateLocationAvailability(tenantRegistration, entity, out errorMessage))
                {
                    return false;
                }

                if (!this.ValidateAvailabilityOfReservedIPDNSNames(tenantRegistration, entity, out errorMessage))
                {
                    return false;
                }
            }
            else
            {
                IServiceManagement azureProxy = null;
                AzureSubcription subscription;
                Func<IServiceManagement, AzureSubcription> getSubscription = (proxy) => proxy.GetAzureSubscription(tenantRegistration.AzureSubscriptionId);

                if (!this.ValidateTenantRegistrationCertificate(tenantRegistration, out errorMessage, out azureProxy, out subscription, getSubscription))
                {
                    return false;
                }

                if (!this.ValidateDNSAvailability(azureSubscriptionId, entity, out errorMessage, subscription, azureProxy))
                {
                    return false;
                }

                if (!this.ValidateRDFEStorageAccounts(azureSubscriptionId, entity, tenantRegistration, subscription, azureProxy, out errorMessage))
                {
                    return false;
                }

                if (!this.ValidateTopologyRDFEResourceAvailability(azureSubscriptionId, entity, out errorMessage, subscription, ongoingTopologyInstances.Where(d => !d.ShouldUseAzureResourceManager()).ToList(), azureProxy))
                {
                    return false;
                }

                if (!this.ValidateApplicationGateway(azureSubscriptionId, entity, out errorMessage, azureProxy))
                {
                    return false;
                }
            }

            // Check Compute Quotas.
            if (!this.ValidateTopologyCoresAvailability(tenantRegistration, entity, ongoingTopologyInstances, out errorMessage, entity.GetCoreCount(), action))
            {
                return false;
            }

            if (!this.ValidateNetworkConfiguration(tenantRegistration, entity, out errorMessage))
            {
                return false;
            }

            if (!this.ValidateDnsRecordSet(azureSubscriptionId, entity, out errorMessage))
            {
                return false;
            }

            if (!this.ValidateStorageAccount(tenantRegistration, entity, out errorMessage))
            {
                return false;
            }

            if (!this.ValidateWinRmAttributeForSingleInstanceOnly(entity, out errorMessage))
            {
                return false;
            }

            if (!TopologyInstanceExtensions.ValidateAzureSqlDBDeploymentEnabled(entity))
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.AzureSQLLocationAzureSQLDbDeploymentNotEnabled, entity.CloudServiceLocation);
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates that the given topology can be deleted.
        /// </summary>
        /// <param name="entity">The topology instance to be deployed.</param>
        /// <param name="tenantRegistration">Registration that corresponds to this tenant.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be deployed, if any.</param>
        /// <returns>A value indicating whether or not the topology can be deleted.</returns>
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "We do not localize Service errors.")]
        private bool ValidateTopologyForDelete(TopologyInstance entity, TenantRegistration tenantRegistration, out HttpResponseMessage errorMessage)
        {
            if (entity.ShouldUseAzureResourceManager())
            {
                using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager(entity.ARM.ResourceGroupName))
                {
                    if (!this.ValidateSubnetIsNotInUseByOtherResourceGroups(entity, manager, out errorMessage))
                    {
                        return false;
                    }
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates that the subnet is not in use by other resource groups by obtaining the app subnet and
        /// comparing the resource groups to which its IP Configurations belong to.
        /// </summary>
        /// <param name="entity">The topology instance to be deployed.</param>
        /// <param name="manager">The Azure Resource Manager.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True if the subnet is not in use by other resource groups, else false.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Must be robust.")]
        private bool ValidateSubnetIsNotInUseByOtherResourceGroups(TopologyInstance entity, AzureResourceManager manager, out HttpResponseMessage errorMessage)
        {
            try
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Validating that topology instance id: [{0}] is not sharing its application subnet with other resource groups.", entity.InstanceId);

                // Get the primary Network Deployment Item from the topology
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Fetching the primary network deployment item from the topology.");
                DeploymentItem networkItem = entity.GetPrimaryNetworkDeploymentItem();
                if (networkItem == null)
                {
                    // Proceed with deletion if the primary network deployment item couldn't be found
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Did not find a primary network deployment item from the topology.");
                    errorMessage = null;
                    return true;
                }

                string vnetName;
                string appSubnetName;
                networkItem.TryGetCustomizationValue(CommonCustomizationNames.VnetName, out vnetName);
                networkItem.TryGetCustomizationValue(CommonCustomizationNames.ApplicationSubnetName, out appSubnetName);

                // Get the Application Subnet from this resource group's Virtual Network
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Fetching the virtual network [{0}].", vnetName);
                VirtualNetwork vnet = manager.Network.Value.GetVirtualNetwork(vnetName, manager.ResourceGroup);
                if (vnet == null)
                {
                    // Return true as it's possible that it is using a virtual network of another environment
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Did not find a virtual network [{0}].", vnetName);
                    errorMessage = null;
                    return true;
                }

                if (vnet.Subnets == null)
                {
                    // Proceed with delete if there are no subnets in the virtual network
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Did not find any subnets in the virtual network [{0}].", vnetName);
                    errorMessage = null;
                    return true;
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Fetching the subnet [{0}].", appSubnetName);
                NetworkModels.Subnet appNet = vnet.Subnets.FirstOrDefault(s => string.Equals(s.Name, appSubnetName, StringComparison.OrdinalIgnoreCase));
                if (appNet == null)
                {
                    // Proceed with delete if it couldn't find the application subnet
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Did not find subnet [{0}] in the virtual network [{1}].", appSubnetName, vnetName);
                    errorMessage = null;
                    return true;
                }

                // Get the application subnet's IP configurations
                IEnumerable<IPConfiguration> ipConfigs = appNet.IpConfigurations;
                if (ipConfigs == null || !ipConfigs.Any())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Did not find any IP Configurations for subnet [{0}].", appSubnetName);
                }

                // Determine if any IP configurations of the app subnet are associated to resource groups other than this one
                HashSet<string> uniqueResourceGroupConflicts = new HashSet<string>();
                foreach (IPConfiguration ipConfig in ipConfigs)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Found IP Configuration in subnet [{0}] with id: [{1}].", appNet.Name, ipConfig.Id);
                    string resourceGroup = manager.Network.Value.GetIPConfigResourceGroup(ipConfig);
                    if (!string.IsNullOrWhiteSpace(resourceGroup) && !string.Equals(resourceGroup, manager.ResourceGroup, StringComparison.OrdinalIgnoreCase))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Found IP Configuration with id: [{0}] that belongs to another resource group with name [{1}].", ipConfig.Id, resourceGroup);
                        uniqueResourceGroupConflicts.Add(resourceGroup);
                    }
                }

                List<string> resourceGroupConflicts = uniqueResourceGroupConflicts.ToList();
                if (resourceGroupConflicts.Count > 0)
                {
                    string resourceGroupNames = string.Join(", ", resourceGroupConflicts);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.Delete_ValidateSubnetNotInUse, resourceGroupNames);
                    return false;
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Successfully validated that topology instance id: [{0}] is not sharing its application subnet.", entity.InstanceId);
            }
            catch (Exception ex)
            {
                Tracer.WriteErrorEvent(
                                TraceComponent.DeploymentServiceApi,
                                ex,
                                "Unable to successfully validate that toplogy instance id [{0}] is not sharing its application subnet. Proceeding with the deletion attempt.",
                                entity.InstanceId);
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates the storage account availability, based on the type regular or XIO.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="tenantRegistration">Registration that corresponds to this tenant.</param>
        /// <param name="subscription">Azure subscription containing resourcing information.</param>
        /// <param name="azureProxy">Azure proxy.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        private bool ValidateRDFEStorageAccounts(Guid azureSubscriptionId, TopologyInstance entity, TenantRegistration tenantRegistration, AzureSubcription subscription, IServiceManagement azureProxy, out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            HttpResponseMessage lastErrorMessage;

            // validate the standard storage account.
            this.ValidateRDFEStorageAccount(azureSubscriptionId, entity, tenantRegistration, StorageAccountType.Standard, subscription, azureProxy, isDisasterRecovery: false, errorMessage: out lastErrorMessage);
            errorMessage = errorMessage ?? lastErrorMessage;

            // If the deployment requires XIO enabled VMs, check for the XIO storage account.
            if (entity.RequireXIOStorage())
            {
                this.ValidateRDFEStorageAccount(azureSubscriptionId, entity, tenantRegistration, StorageAccountType.PremiumXIO, subscription, azureProxy, isDisasterRecovery: false, errorMessage: out lastErrorMessage);
                errorMessage = errorMessage ?? lastErrorMessage;
            }

            // If the deployment requires Disaster Recovery, check for the DR storage accounts.
            if (entity.IsDisasterRecoveryEnabled())
            {
                this.ValidateRDFEStorageAccount(azureSubscriptionId, entity, tenantRegistration, StorageAccountType.Standard, subscription, azureProxy, isDisasterRecovery: true, errorMessage: out lastErrorMessage);
                errorMessage = errorMessage ?? lastErrorMessage;

                if (entity.RequireXIOStorage())
                {
                    this.ValidateRDFEStorageAccount(azureSubscriptionId, entity, tenantRegistration, StorageAccountType.PremiumXIO, subscription, azureProxy, isDisasterRecovery: true, errorMessage: out lastErrorMessage);
                    errorMessage = errorMessage ?? lastErrorMessage;
                }
            }

            return errorMessage == null;
        }

        /// <summary>
        /// Validates the ARM storage accounts.
        /// </summary>
        /// <param name="entity">The deployment request.</param>
        /// <param name="tenantRegistration">Registration that corresponds to this tenant.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>Returns a boolean value if the Subscription was found.</returns>
        private bool ValidateARMStorageAccounts(TopologyInstance entity, TenantRegistration tenantRegistration, out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            HttpResponseMessage lastErrorMessage;

            // validate the standard storage account.
            this.ValidateARMStorageAccount(entity, tenantRegistration, StorageAccountType.Standard, isDisasterRecovery: false, errorMessage: out lastErrorMessage);
            errorMessage = errorMessage ?? lastErrorMessage;

            // If the deployment requires XIO enabled VMs, check for the XIO storage account.
            if (entity.RequireXIOStorage())
            {
                this.ValidateARMStorageAccount(entity, tenantRegistration, StorageAccountType.PremiumXIO, isDisasterRecovery: false, errorMessage: out lastErrorMessage);
                errorMessage = errorMessage ?? lastErrorMessage;
            }

            // If the deployment requires Disaster Recovery, check for the DR storage accounts.
            if (entity.IsDisasterRecoveryEnabled())
            {
                this.ValidateARMStorageAccount(entity, tenantRegistration, StorageAccountType.Standard, isDisasterRecovery: true, errorMessage: out lastErrorMessage);
                errorMessage = errorMessage ?? lastErrorMessage;

                if (entity.RequireXIOStorage())
                {
                    this.ValidateARMStorageAccount(entity, tenantRegistration, StorageAccountType.PremiumXIO, isDisasterRecovery: true, errorMessage: out lastErrorMessage);
                    errorMessage = errorMessage ?? lastErrorMessage;
                }
            }

            return errorMessage == null;
        }

        /// <summary>
        /// Sanity check of topology data.
        /// </summary>
        /// <param name="entity">The topology instance.</param>
        /// <param name="azureSubscriptionId">The azure subscription identifier.</param>
        /// <param name="tenantRegistration">The TenantRegistration object for the request.</param>
        /// <param name="action">Deployment action.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True or false.</returns>
        private bool ValidateTopologyConsistency(TopologyInstance entity, Guid azureSubscriptionId, TenantRegistration tenantRegistration, DeploymentRequest.DeploymentAction action, out HttpResponseMessage errorMessage)
        {
            Contract.Requires(entity != null);

            IEnumerable<VirtualMachineSize> armRoleSizes = null;
            Microsoft.DynamicsOnline.Deployment.WindowsAzure.ServiceManagement.RoleSizeList rdfeRoleSizes = null;

            IEnumerable<string> roleSizes = new List<string>();

            // Get role sizes for input storageLocation
            if (entity.ShouldUseAzureResourceManager())
            {
                using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager())
                {
                    armRoleSizes = manager.Compute.Value.GetVirtualMachineSizes(entity.GetARMLocation());
                    roleSizes = armRoleSizes.Select(r => r.Name);
                }
            }
            else
            {
                IServiceManagement azureProxy = tenantRegistration.CreateAzureServiceManagement();

                rdfeRoleSizes = this.GetAvailableRoleSizes(azureProxy, azureSubscriptionId, entity.CloudServiceLocation);
                roleSizes = rdfeRoleSizes.Select(r => r.Name);
            }

            foreach (var item in entity.DeploymentItems)
            {
                // check role sizes provided are supported by selected data center
                if (item.IsItemType(DeploymentItemType.VirtualMachine) && item.IsPrimary())
                {
                    string roleSize;
                    if (item.TryGetCustomizationValue(CommonCustomizationNames.RoleSize, out roleSize) && !string.IsNullOrEmpty(roleSize))
                    {
                        if (!roleSizes.Any(r => string.Equals(r, roleSize, StringComparison.OrdinalIgnoreCase)))
                        {
                            Tracer.WriteExecutionEvent(
                                TraceComponent.DeploymentServiceApi,
                                null,
                                "RoleSize selected [{3}] is not supported in the data center [{0}]. DeploymentTopology: [{1}] Item: [{2}]",
                                entity.CloudServiceLocation,
                                entity.InstanceId,
                                item.ItemName,
                                roleSize);

                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.RoleSizeNotSupported, entity.CloudServiceLocation);
                            return false;
                        }
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(
                            TraceComponent.DeploymentServiceApi,
                            null,
                            "RoleSize customization is empty. DeploymentTopology: [{0}] Item: [{1}]",
                            entity.InstanceId,
                            item.ItemName);

                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.RoleSizeIsEmpty);
                        return false;
                    }
                }

                // Check deployment files.
                foreach (var file in item.DeploymentFiles)
                {
                    if (string.IsNullOrWhiteSpace(file.Path))
                    {
                        Tracer.WriteErrorEvent(
                            TraceComponent.DeploymentServiceApi,
                            null,
                            "Deployment file has an empty path. DeploymentTopology: '{0}' Item: '{1}', File: '{2}'",
                            entity.InstanceId,
                            item.ItemName,
                            file.FileName);

                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopologyInstance);
                        return false;
                    }

                    Uri blobUrl;
                    if (!Uri.TryCreate(file.Path, UriKind.Absolute, out blobUrl))
                    {
                        Tracer.WriteErrorEvent(
                            TraceComponent.DeploymentServiceApi,
                            null,
                            "Deployment file has a path that cannot be cast to a URI. DeploymentTopology: '{0}' Item: '{1}', File: '{2}'",
                            entity.InstanceId,
                            item.ItemName,
                            file.FileName);

                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopologyInstance);
                        return false;
                    }
                }
            }

            // if RDS deployment items deployed then we should have at least on client machine selected (R3).
            DeploymentItem rdsdeploymentItem = entity.DeploymentItems.FirstOrDefault(di => di.IsItemType(DeploymentItemType.RemoteDesktopService));
            if (rdsdeploymentItem != null && rdsdeploymentItem.GetInstanceCount() > 0)
            {
                // check client machines
                DeploymentItem clientDeploymentItem = entity.DeploymentItems.FirstOrDefault(di => di.ItemPurpose == ItemPurposeType.Client);
                if (clientDeploymentItem.GetInstanceCount() == 0)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "RDSRequiresClients: If RemoteDesktopServices are enabled then at least one client item must be deployed.");
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.RDSRequiresClients);
                    return false;
                }
            }

            // check Premium storage dependencies.
            if (action == DeploymentRequest.DeploymentAction.Deploy)
            {
                foreach (DeploymentItem item in entity.DeploymentItems)
                {
                    // if Premium Storage selected then the size must be compatible.
                    // Check if this a previously deployed environment (update operation) that has the Premium storage enabled without consistency check.
                    // UI doesn't provide ability to make changes in advanced settings, so this check if fails cannot be resolved by user.
                    bool isXIOEnabled = false;
                    if (item.TryGetCustomizationValue<bool>(CommonCustomizationNames.XIOEnabled, out isXIOEnabled) && isXIOEnabled)
                    {
                        if (!RoleSizeMetadata.IsXIOStorageRequired(item.GetRoleSizeString()))
                        {
                            Tracer.WriteExecutionEvent(
                                    TraceComponent.DeploymentServiceApi,
                                    "PremiumStorageDSGSRequired: If Premium Storage is enabled then the VM size for the selected role must be a DS or GS. Selected value is [{0}].",
                                    item.GetRoleSizeString());
                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.PremiumStorageDSGSRequired);
                            return false;
                        }
                    }

                    // Check managed disk SKU and VM size compatibility.
                    // Premium SSD Managed Disks (Premium_LRS) are supported by DS-series, DSv2-series, FS-series, and
                    // GS -series VM sizes which are specifically targeted for Premium SSD Managed Disks.
                    string managedDiskType;
                    if (item.TryGetCustomizationValue<string>(CommonCustomizationNames.ManagedDiskType, out managedDiskType) &&
                        managedDiskType.Equals(Microsoft.DynamicsOnline.Deployment.Constants.XIOStorageAccountType, StringComparison.OrdinalIgnoreCase))
                    {
                        if (!RoleSizeMetadata.IsXIOStorageRequired(item.GetRoleSizeString()))
                        {
                            Tracer.WriteExecutionEvent(
                                        TraceComponent.DeploymentServiceApi,
                                        "PremiumManagedDiskDSGSRequired: If Premium Managed Disk is enabled then the VM size for the selected role must be a DS or GS. Selected value is [{0}].",
                                        item.GetRoleSizeString());
                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.PremiumManagedDiskDSGSRequired);
                            return false;
                        }
                    }
                }
            }

            // Enforce all VM sizes have the same Azure characteristics as defined by the Azure Compute Unit.
            // Normally we create different cloud services to align to Azure Compute Unit definition where we group the VM by SKU.
            // For AX7 HA we cannot deploy the VMs in different cloud services due to limitations of Azure in resolving VM names across cloud services (internal DNS).
            // Restrict VM size combination that takes us in this situation.
            bool enforceCompatibleVMSKUs = false;
            if (entity.TryGetCustomizationValue<bool>(CommonCustomizationNames.EnforceCompatibleVMSKUs, out enforceCompatibleVMSKUs) && enforceCompatibleVMSKUs)
            {
                string sizeSKULookup = String.Empty;

                Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "EnforceCompatibleVMSKUs: Checking VM sizes");

                foreach (DeploymentItem item in entity.DeploymentItems)
                {
                    if (item.IsItemType(DeploymentItemType.VirtualMachine) && item.IsPrimary())
                    {
                        string skuType = item.GetCloudServiceGroupSuffix();
                        Tracer.WriteExecutionEvent(
                                TraceComponent.DeploymentServiceApi,
                                "EnforceCompatibleVMSKUs: VM SKU suffix [{0}].",
                                skuType);

                        if (!string.IsNullOrEmpty(skuType))
                        {
                            if (string.IsNullOrEmpty(sizeSKULookup))
                            {
                                sizeSKULookup = skuType;
                            }
                            else if (!string.Equals(skuType, sizeSKULookup, StringComparison.OrdinalIgnoreCase))
                            {
                                Tracer.WriteExecutionEvent(
                                        TraceComponent.DeploymentServiceApi,
                                        "EnforceCompatibleVMSKUs: All VM sizes must be of the same hardware profile as specified by Azure Compute Units.");
                                errorMessage = this.CreateErrorResponse(ServiceErrorCode.IncompatibleVMSizes);
                                return false;
                            }
                        }
                    }
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates if there is VM based deployment item with at least one instance.
        /// </summary>
        /// <param name="instanceId">Related topology identifier.</param>
        /// <param name="vmBasedDeploymentItems">VM based deployment items.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True or false.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.StyleCop.CSharp.NamingRules", "SA1305:FieldNamesMustNotUseHungarianNotation", Justification = "Not a Hungarian notation.")]
        private bool ValidateVMBaseDeploymentItems(string instanceId, IEnumerable<DeploymentItem> vmBasedDeploymentItems, out HttpResponseMessage errorMessage)
        {
            DeploymentItem[] deploymentItems = vmBasedDeploymentItems.ToArray();

            if (deploymentItems.Any() && deploymentItems.Sum(i => i.GetInstanceCount()) == 0)
            {
                Tracer.WriteExecutionEvent(
                            TraceComponent.DeploymentServiceApi,
                            null,
                            "There is not VM based deployment item with instances for the topology. DeploymentTopology: [{0}]",
                            instanceId);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_VirtualMachinesWithoutIntances, instanceId);

                return false;
            }

            errorMessage = null;

            return true;
        }

        /// <summary>
        /// Validates if the customizations meet required conditions.
        /// </summary>
        /// <param name="entity">The topology instance.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True or false.</returns>
        private bool ValidateCustomizations(TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            // Validate the customization constraints
            if (!this.ValidateCustomizationsConstraints(entity, out errorMessage))
            {
                return false;
            }

            // Check for VM name validity
            if (!this.ValidateVMName(entity, out errorMessage))
            {
                return false;
            }

            // validate ActiveDirectory settings
            if (!this.ValidateActiveDirectoryCustomization(entity, out errorMessage))
            {
                return false;
            }

            // validate the disks settings for each deployment Item
            if (entity != null && entity.DeploymentItems != null)
            {
                foreach (DeploymentItem item in entity.DeploymentItems)
                {
                    if (item != null && !this.ValidateDiskPoolSettings(item, out errorMessage))
                    {
                        return false;
                    }
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates if the customizations meet the general constraints .
        /// </summary>
        /// <param name="entity">The topology instance.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True or false.</returns>
        private bool ValidateCustomizationsConstraints(TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            // check the UI customizations first
            if (entity.CustomizationGroups != null)
            {
                foreach (CustomizationGroup customizationGroup in entity.CustomizationGroups)
                {
                    if (!this.ValidateCustomizationGroup(customizationGroup, out errorMessage))
                    {
                        return false;
                    }
                }
            }

            if (entity.DeploymentItems != null)
            {
                // check the UI customizations first
                foreach (DeploymentItem item in entity.DeploymentItems)
                {
                    if (item.CustomizationGroups != null)
                    {
                        foreach (CustomizationGroup customizationGroup in item.CustomizationGroups)
                        {
                            if (!this.ValidateCustomizationGroup(customizationGroup, out errorMessage))
                            {
                                return false;
                            }
                        }
                    }

                    if (item.Customizations != null)
                    {
                        foreach (Customization customization in item.Customizations)
                        {
                            if (!this.ValidateCustomization(customization, out errorMessage))
                            {
                                return false;
                            }
                        }
                    }
                }
            }

            if (entity.Customizations != null)
            {
                foreach (Customization customization in entity.Customizations)
                {
                    if (!this.ValidateCustomization(customization, out errorMessage))
                    {
                        return false;
                    }
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates if the given customization.
        /// </summary>
        /// <param name="customization">The customization.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True or false.</returns>
        private bool ValidateCustomization(Customization customization, out HttpResponseMessage errorMessage)
        {
            ServiceErrorCode errorCode = ServiceErrorCode.Undefined;
            object[] messageParameters = null;

            if (customization != null && !customization.ValidateConstraints(false, out errorCode, out messageParameters))
            {
                string message = Tracer.FormatMessage("Validation failed for customization '{0}' with error code '{1}'", customization.FieldName, errorCode);

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    message);

                errorMessage = this.CreateErrorResponse(errorCode, messageParameters);
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates if the given customization group.
        /// </summary>
        /// <param name="customizationGroup">The customization group.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True or false.</returns>
        private bool ValidateCustomizationGroup(CustomizationGroup customizationGroup, out HttpResponseMessage errorMessage)
        {
            ServiceErrorCode errorCode = ServiceErrorCode.Undefined;
            object[] messageParameters = null;
            Customization customization = null;

            if (customizationGroup != null && !customizationGroup.ValidateConstraints(out customization, out errorCode, out messageParameters))
            {
                string message = Tracer.FormatMessage("Validation failed for customization '{0}' in customization '{1}' with error code '{2}'", customizationGroup.Name, customization.FieldName, errorCode);

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    message);

                errorMessage = this.CreateErrorResponse(errorCode, messageParameters);
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates the disks settings for SQL Always On.
        /// </summary>
        /// <param name="item">The deployment item.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True or false.</returns>
        private bool ValidateDiskPoolSettings(DeploymentItem item, out HttpResponseMessage errorMessage)
        {
            Contract.Requires(item != null);
            Customization diskCountCustomization = null;
            Customization diskSizeCustomization = null;

            if (item.Customizations != null)
            {
                diskCountCustomization = item.Customizations.FirstOrDefault(di => di.FieldName.Equals(CommonCustomizationNames.NumberOfBlankDataDisks, StringComparison.OrdinalIgnoreCase));
                diskSizeCustomization = item.Customizations.FirstOrDefault(di => di.FieldName.Equals(CommonCustomizationNames.BlankDataDiskSizeInGb, StringComparison.OrdinalIgnoreCase));
            }

            // disk count validation
            if (diskCountCustomization == null)
            {
                // no customization, no disk pool will be created
                errorMessage = null;
                return true;
            }

            // get the pool disk count from customization input
            int numberOfPoolDisks = 0;
            string valuePoolDisksCount = string.IsNullOrEmpty(diskCountCustomization.SelectedValue) ? diskCountCustomization.DefaultValue : diskCountCustomization.SelectedValue;

            if (string.IsNullOrEmpty(valuePoolDisksCount))
            {
                numberOfPoolDisks = 0;
            }
            else if (!int.TryParse(valuePoolDisksCount, out numberOfPoolDisks) || numberOfPoolDisks < 0)
            {
                string message = Tracer.FormatMessage("Invalid pool disk count value '{0}'", valuePoolDisksCount);

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    message);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.PoolDiskCountInvalidString);
                return false;
            }

            // constraints on min/max validated in ValidateCustomizationsConstraints

            // get how many disks we deploy from Data VHDs
            int dataDisksCount = item.DeploymentFiles.Count(f => f.FileType == DeploymentFileType.DataVHD.ToString());

            // If numberOfPoolDisks is 0, we assume the # disks in the pool is what's remaining up to the max size. From conditions above we have at least 1.
            // Otherwise, the total number of disks in the pool is limited by max allowed by the VM size selected
            numberOfPoolDisks = (numberOfPoolDisks == 0) ? item.RoleSizeToDiskCount() - dataDisksCount : numberOfPoolDisks;
            if (numberOfPoolDisks + dataDisksCount > item.RoleSizeToDiskCount())
            {
                string message = Tracer.FormatMessage(
                                        "The number of disks selected '{0}' + existing data disks '{1}' exceeds the total capacity of the VM of '{2}' disks",
                                        numberOfPoolDisks,
                                        dataDisksCount,
                                        item.RoleSizeToDiskCount());

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    message);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.PoolDiskCountTooBig, numberOfPoolDisks, item.RoleSizeToDiskCount(), dataDisksCount);
                return false;
            }

            // disk size validation
            if (diskSizeCustomization == null)
            {
                // no customization, disk size will be the default
                errorMessage = null;
                return true;
            }

            string valueDiskSize = string.IsNullOrEmpty(diskSizeCustomization.SelectedValue) ? diskSizeCustomization.DefaultValue : diskSizeCustomization.SelectedValue;
            int diskSize = 0;
            if (!int.TryParse(valueDiskSize, out diskSize) || diskSize <= 0)
            {
                string message = Tracer.FormatMessage("Invalid disk size value '{0}'", valueDiskSize);

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    message);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.PoolDiskSizeInvalidString);
                return false;
            }

            // constraints on min/max validated in ValidateCustomizationsConstraints

            // Additionally, check the total size of the pool, #disk * size >= minimum
            if (diskSize * numberOfPoolDisks < DeploymentConstants.DiskPoolMinTotalSize)
            {
                string message = Tracer.FormatMessage("The total disk pool size capacity is '{0}' and it must be at least '{1}'", diskSize * numberOfPoolDisks, DeploymentConstants.DiskPoolMinTotalSize);

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    message);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.PoolDiskTotalSizeInvalid, diskSize * numberOfPoolDisks, DeploymentConstants.DiskPoolMinTotalSize);
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates if the active directory customization met the required pre-requisites.
        /// </summary>
        /// <param name="entity">The topology instance.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True or false.</returns>
        private bool ValidateActiveDirectoryCustomization(TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            Contract.Requires(entity != null);
            errorMessage = null;

            if (entity.CustomizationGroups == null)
            {
                return true;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Validating if the Active Directory customization met the required prerequisites.");
            DeploymentItem networkItem = entity.GetPrimaryNetworkDeploymentItem();
            CustomizationGroup vnetCustomizationGroup = null;
            if (networkItem != null &&
                networkItem.CustomizationGroups != null)
            {
                vnetCustomizationGroup = networkItem.CustomizationGroups.FirstOrDefault(cg => cg.Name.Equals(CommonCustomizationNames.VnetName, StringComparison.OrdinalIgnoreCase));
            }

            CustomizationGroup activeDirectoryCustomizationGroup = entity.CustomizationGroups.FirstOrDefault(cg => cg.Name.Equals(CommonCustomizationNames.DomainName, StringComparison.OrdinalIgnoreCase));
            if (activeDirectoryCustomizationGroup == null)
            {
                return true;
            }

            if (!this.ValidateDomainName(activeDirectoryCustomizationGroup, out errorMessage))
            {
                return false;
            }

            Group useExistingAd = activeDirectoryCustomizationGroup.Groups.FirstOrDefault(group => group.Name.Equals(CommonCustomizationNames.UseExistingDomain, StringComparison.OrdinalIgnoreCase) && group.Selected);
            if (useExistingAd != null)
            {
                if (vnetCustomizationGroup == null)
                {
                    string message = Tracer.FormatMessage(
                      "User chose to use an existing AD infrastructure but there isn't a VNET customization group which is disallowed. Ensure that the topology allows the user to deploy to an existing VNET.");

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);

                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_MissingVnetPrerequisite);
                    return false;
                }

                Group useExistingVnet = vnetCustomizationGroup.Groups.FirstOrDefault(group => group.Name.Equals(CommonCustomizationNames.UseExistingVnet, StringComparison.OrdinalIgnoreCase) && group.Selected);

                if (useExistingVnet == null)
                {
                    string message = Tracer.FormatMessage(
                    "User chose to use an existing AD infrastructure but did not select an existing VNET to deploy to.");

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);

                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_MissingVnetPrerequisite);
                    return false;
                }
            }

            if (!this.ValidateServiceAccountCustomization(entity, out errorMessage))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Validates the service account customization.
        /// </summary>
        /// <param name="entity">The entity.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>
        /// True or false.
        /// </returns>
        private bool ValidateServiceAccountCustomization(TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            // Indicates if the service accounts are for an existing AD. In that case we just check for null or empty credentials.
            bool useExistingAd = entity.UsesExistingActiveDirectoryInfrastructure();

            errorMessage = null;
            var serviceAccountCustomizationGroup = entity.CustomizationGroups.Where(g => g.Name.Equals(CommonCustomizationNames.ServiceAccount)).FirstOrDefault();

            if (serviceAccountCustomizationGroup == null || serviceAccountCustomizationGroup.Groups == null)
            {
                return true;
            }

            foreach (var group in serviceAccountCustomizationGroup.Groups)
            {
                if (group.Customizations == null)
                {
                    continue;
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Validating service account customization for symbolic name '{0}'", group.Name);
                var usernameCustomization = group.Customizations.Where(c => c.FieldName.Equals(CommonCustomizationNames.UserName)).FirstOrDefault();
                if (usernameCustomization == null)
                {
                    continue;
                }

                if (useExistingAd)
                {
                    if (String.IsNullOrEmpty(usernameCustomization.SelectedValue))
                    {
                        string message = Tracer.FormatMessage("Service account customization for '{0}' user name should not be empty or null when using an existing AD.", group.DisplayName);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_InvalidUserName);
                        return false;
                    }
                }
                else if (!String.IsNullOrEmpty(usernameCustomization.SelectedValue))
                {
                    if (usernameCustomization.SelectedValue.Length >= UserNameLength)
                    {
                        string message = Tracer.FormatMessage("Service account customization for '{0}' user name should be less than 20 characters.", group.DisplayName);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_InvalidUserName);
                        return false;
                    }

                    if (usernameCustomization.SelectedValue.Any(c => invalidUserNameCharacters.Contains(c)))
                    {
                        string message = Tracer.FormatMessage("Service account customization for '{0}' user name has invalid special characters.", group.DisplayName);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_InvalidUserName);
                        return false;
                    }
                }

                var passwordCustomization = group.Customizations.Where(c => c.FieldName.Equals(CommonCustomizationNames.Password)).FirstOrDefault();
                if (passwordCustomization == null)
                {
                    continue;
                }

                if (useExistingAd)
                {
                    if (String.IsNullOrEmpty(passwordCustomization.SelectedValue))
                    {
                        string message = Tracer.FormatMessage("Service account customization for '{0}' password should not be empty or null when using an existing AD.", group.DisplayName);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_InvalidPassword, CredentialUtils.DefaultPasswordLength);
                        return false;
                    }
                }
                else if (!String.IsNullOrEmpty(passwordCustomization.SelectedValue) && !CredentialUtils.IsValidPassword(passwordCustomization.SelectedValue))
                {
                    string message = Tracer.FormatMessage("Service account customization for '{0}' password contains invalid characters or less than default length '{1}'.", group.DisplayName, CredentialUtils.DefaultPasswordLength);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_InvalidPassword, CredentialUtils.DefaultPasswordLength);
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Validates if SQL Collation is provided and populates the customizations at the DB level.
        /// Replaces the data sets on all databases if collation is not the default.
        /// </summary>
        /// <param name="entity">The topology instance.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True or false.</returns>
        private bool ProcessSQLDatabaseCollation(TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            Contract.Requires(entity != null);
            errorMessage = null;

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Processing SQLDatabaseCollation.");

            string collation;
            if (!entity.TryGetCustomizationValue(CommonCustomizationNames.SQLDatabaseCollation, out collation) || string.IsNullOrWhiteSpace(collation.Trim()))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Topology [{0}], type [{1}] does not provide a SQL Collation.", entity.InstanceId, entity.TopologyName);
                return true;
            }

            // this can be set from a free text box, remove spaces
            collation = collation.Trim();

            // populate all database items with topology level collation (utilized later in DR flows)
            IEnumerable<DeploymentItem> databaseDeploymentItems = entity.DeploymentItems.Where(d => d.IsItemType(DeploymentItemType.AzureSQLDatabase));
            bool isDefaultCollation = string.Equals(collation, DeploymentConstants.AzureSQLDefaultCollation, StringComparison.OrdinalIgnoreCase);

            foreach (DeploymentItem database in databaseDeploymentItems)
            {
                database.SetCustomizationValue(CommonCustomizationNames.SQLDatabaseCollation, collation, CustomizationValueType.String);
                if (!isDefaultCollation)
                {
                    // reset whatever data set was selected
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Collation processing: Resetting AzureSQLDatabase_Dataset to NA for deployment item [{0}], topology [{0}], type [{1}].", database.ItemName, entity.InstanceId, entity.TopologyName);
                    database.SetCustomizationValue(CommonCustomizationNames.AzureSQLDatabaseDataset, CommonCustomizationNames.SQLDatabaseNoDataset);
                }
            }

            return true;
        }

        /// <summary>
        /// Sets the database short term backup retention policy in the database items.
        /// </summary>
        /// <param name="entity">The topology instance.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True or false.</returns>
        private bool ProcessSQLDatabaseShortTermBackupRetention(TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            Contract.Requires(entity != null);
            errorMessage = null;

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Processing SQLDatabaseShortTermBackupRetention.");

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, string.Format(CultureInfo.InvariantCulture, "Setting SQLDatabaseShortTermBackupRetention for topology [{0}] to [{1}] days.", entity, AzureSQLDatabaseDeploymentWorkflow.ShortTermBackupRetentionInDays));
            entity.SetCustomizationValue(CommonCustomizationNames.AzureDatabasePiTRRetentionInDays, AzureSQLDatabaseDeploymentWorkflow.ShortTermBackupRetentionInDays);

            return true;
        }

        /// <summary>
        /// Validates the entered domain name, if any.
        /// </summary>
        /// <param name="activeDirectoryCustomizationGroup">Customization group containing the domain name input.</param>
        /// <param name="errorMessage">The error message, if any.</param>
        /// <returns>A value indicating whether or not, the domain name is valid.</returns>
        private bool ValidateDomainName(CustomizationGroup activeDirectoryCustomizationGroup, out HttpResponseMessage errorMessage)
        {
            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Validating domain name.");
            string domainName = null;
            string domainNetbiosName = null;

            // Only one of these two groups will be selected.
            Group useNewAd = activeDirectoryCustomizationGroup.Groups.FirstOrDefault(group => String.Equals(group.Name, CommonCustomizationNames.NewDomain, StringComparison.OrdinalIgnoreCase) && group.Selected);
            Group useExistingAd = activeDirectoryCustomizationGroup.Groups.FirstOrDefault(group => String.Equals(group.Name, CommonCustomizationNames.UseExistingDomain, StringComparison.OrdinalIgnoreCase) && group.Selected);

            if (useNewAd != null)
            {
                Customization domainCustomization = useNewAd.Customizations.FirstOrDefault(c => String.Equals(c.FieldName, CommonCustomizationNames.DomainName, StringComparison.OrdinalIgnoreCase));
                if (domainCustomization != null)
                {
                    domainName = domainCustomization.SelectedValue;
                }

                Customization domainNetbiosCustomization = useNewAd.Customizations.FirstOrDefault(c => String.Equals(c.FieldName, CommonCustomizationNames.DomainNetBIOSName, StringComparison.OrdinalIgnoreCase));
                if (domainNetbiosCustomization != null)
                {
                    domainNetbiosName = domainNetbiosCustomization.SelectedValue;
                }

                // New AD Validations
                if (!String.IsNullOrWhiteSpace(domainName))
                {
                    // Check domain is FQDN
                    if (!domainName.Contains('.'))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Detected invalid domain name: [{0}]", domainName);
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidDomainName);
                        return false;
                    }

                    // If there is no domain Net BIOS name input, validate that it can be safely derived from the domain name.
                    if (String.IsNullOrWhiteSpace(domainNetbiosName))
                    {
                        domainNetbiosName = domainName.Split('.')[0];
                        if (!VmDeploymentController.IsValidNetbiosName(domainNetbiosName))
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Detected invalid implicit domain Net BIOS name [{0}] as implied by domain name [{1}]", domainNetbiosName, domainName);
                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidImplicitDomainNetbiosName);
                            return false;
                        }
                    }
                }

                if (!String.IsNullOrWhiteSpace(domainNetbiosName) && !VmDeploymentController.IsValidNetbiosName(domainNetbiosName))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Detected invalid domain Net BIOS name [{0}]", domainNetbiosName);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidExplicitDomainNetbiosName);
                    return false;
                }
            }

            if (useExistingAd != null)
            {
                var domainCustomization = useExistingAd.Customizations.FirstOrDefault(c => String.Equals(c.FieldName, CommonCustomizationNames.DomainName, StringComparison.OrdinalIgnoreCase));
                if (domainCustomization != null)
                {
                    domainName = domainCustomization.SelectedValue;
                }

                if (String.IsNullOrWhiteSpace(domainName))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Detected empty domain name for Existing Active Directory flow.");
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidDomainName);
                    return false;
                }

                Customization domainNetbiosCustomization = useExistingAd.Customizations.FirstOrDefault(c => String.Equals(c.FieldName, CommonCustomizationNames.DomainNetBIOSName, StringComparison.OrdinalIgnoreCase));
                if (domainNetbiosCustomization != null)
                {
                    domainNetbiosName = domainNetbiosCustomization.SelectedValue;
                }

                // Existing AD Validations
                if (!String.IsNullOrWhiteSpace(domainName))
                {
                    // Check domain is FQDN
                    if (!domainName.Contains('.'))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Detected invalid domain name: [{0}]", domainName);
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidDomainName);
                        return false;
                    }
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates the application gateway.
        /// </summary>
        /// <param name="azureSubscriptionId">The azure subscription identifier.</param>
        /// <param name="entity">The entity.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <param name="azureProxy">The azure proxy.</param>
        /// <returns>A value indicating whether or not, the application gateway is valid.</returns>
        private bool ValidateApplicationGateway(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, IServiceManagement azureProxy)
        {
            Contract.Requires(entity != null);

            var applicationGatewayDeploymentItems = entity.DeploymentItems.Where(d => d.IsItemType(DeploymentItemType.ApplicationGateway));
            foreach (var applicationGatewayDeploymentItem in applicationGatewayDeploymentItems)
            {
                if (!this.ValidateApplicationGatewayDeploymentItem(azureSubscriptionId, entity, applicationGatewayDeploymentItem, out errorMessage, azureProxy))
                {
                    return false;
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates the DNS record set.
        /// </summary>
        /// <param name="azureSubscriptionId">The azure subscription identifier.</param>
        /// <param name="entity">The entity.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>A value indicating whether or not, the DNS record set is valid.</returns>
        private bool ValidateDnsRecordSet(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            Contract.Requires(entity != null);

            if (entity.DnsRecordSets == null || !entity.DnsRecordSets.Any())
            {
                errorMessage = null;
                return true;
            }

            bool enableDnsRecordCreation;
            if (!entity.TryGetCustomizationValue<bool>(CommonCustomizationNames.EnableDNSRecordCreationCustomization, out enableDnsRecordCreation) || !enableDnsRecordCreation)
            {
                Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Enable DNS record creation customization is not set to true for topology '{0}' Id '{1}'. Skipping validate DNS record set.",
                        entity.TopologyName,
                        entity.InstanceId);
                errorMessage = null;
                return true;
            }

            DnsZone dnsZone;
            if (!this.TryGetDnsZone(entity, out dnsZone, out errorMessage))
            {
                return false;
            }

            if (!dnsZone.IsAzDnsZone)
            {
                string dnsManagerApplicationId = ARMConfig.DefaultApplicationId;
                X509Certificate2 dnsManagerCertificate = SecureCertificateManager.GetCertificateByThumbprint(ARMConfig.DefaultApplicationCertificateThumbprint);
                using (AzureResourceManager manager = new AzureResourceManager(dnsZone.TenantId, dnsZone.AzureSubscriptionId.ToString(), dnsZone.ResourceGroupName, dnsManagerApplicationId, dnsManagerCertificate))
                {
                    IEnumerable<DnsRecordSet> dnsRecords = entity.DnsRecordSets.Where(d => !string.Equals(d.RecordType, DnsRecordSet.VirtualIPRecordType, StringComparison.OrdinalIgnoreCase));
                    foreach (var dnsRecord in dnsRecords)
                    {
                        // check if the lookup entry is acquired by this topology
                        bool dnslookupAcquired;
                        if (dnsRecord.TryGetCustomizationValue(CommonCustomizationNames.DNSLookupEntryAcquired, out dnslookupAcquired) && dnslookupAcquired)
                        {
                            if (!this.ValidateDnsRecordSetAvailability(manager, dnsRecord, entity, out errorMessage))
                            {
                                return false;
                            }
                            else
                            {
                                Tracer.WriteExecutionEvent(
                                            TraceComponent.DeploymentServiceApi,
                                            "Validated DNS available for azure DNS record [{0}] in topology [{1}] Id [{2}].",
                                            dnsRecord,
                                            entity.TopologyName,
                                            entity.InstanceId);
                            }
                        }
                        else
                        {
                            Tracer.WriteExecutionEvent(
                                        TraceComponent.DeploymentServiceApi,
                                        "DNS Lookup entry not acquired, skipping DNS validation for record [{0}] in topology [{1}] Id [{2}].",
                                        dnsRecord,
                                        entity.TopologyName,
                                        entity.InstanceId);
                        }
                    }
                }
            }
            else
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Operation is not supported when Azure Dns is set to true in Dns zone. Current Dns Zone: [{0}].", dnsZone);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotSupported_WaiDnsEnabled);
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates the DNS record set availability.
        /// </summary>
        /// <param name="manager">The manager.</param>
        /// <param name="dnsRecord">The DNS record.</param>
        /// <param name="entity">The entity.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>A value indicating whether or not, the DNS record set is valid.</returns>
        private bool ValidateDnsRecordSetAvailability(AzureResourceManager manager, DnsRecordSet dnsRecord, TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            RecordType recordType;
            if (!CommonUtilities.TryParseEnum<RecordType>(dnsRecord.RecordType, out recordType))
            {
                Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                "DNS record type is invalid for dns record [{0}] in topology [{1}] Id [{2}].",
                dnsRecord,
                entity.TopologyName,
                entity.InstanceId);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_MissingDnsZoneInformation);
                return false;
            }

            RecordSet recordSet;
            if (manager.DNS.Value.TryGetRecordSet(dnsRecord.ZoneName, dnsRecord.Name, recordType, out recordSet))
            {
                Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                "DNS name already exists for DNS record [{0}] in topology [{1}] Id [{2}].",
                dnsRecord,
                entity.TopologyName,
                entity.InstanceId);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.DnsNameAlreadyExists);
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates the application gateway deployment item.
        /// </summary>
        /// <param name="azureSubscriptionId">The azure subscription identifier.</param>
        /// <param name="entity">The entity.</param>
        /// <param name="item">The item.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <param name="azureProxy">The azure proxy.</param>
        /// <returns>A value indicating whether or not, the application gateway is valid.</returns>
        private bool ValidateApplicationGatewayDeploymentItem(Guid azureSubscriptionId, TopologyInstance entity, DeploymentItem item, out HttpResponseMessage errorMessage, IServiceManagement azureProxy)
        {
            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Validating application gateway deployment item '{0}' in topology '{1}'.", item.ItemName, entity.InstanceId);
            int instanceCount;
            if (!item.TryGetCustomizationValue<int>(CommonCustomizationNames.InstanceCount, out instanceCount))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Could not find customization value for '{0}' in Application gateway deployment item '{1}'.", CommonCustomizationNames.InstanceCount, item.ItemName);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ApplicationGatewayMalformed);
                return false;
            }

            string roleSize;
            if (!item.TryGetCustomizationValue(CommonCustomizationNames.RoleSize, out roleSize))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Could not find customization value for '{0}' in Application gateway deployment item '{1}'.", CommonCustomizationNames.RoleSize, item.ItemName);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ApplicationGatewayMalformed);
                return false;
            }

            string cookieBaseAffinity;
            if (!item.TryGetCustomizationValue(CommonCustomizationNames.ApplicationGatewayCookieBaseAffinity, out cookieBaseAffinity))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Could not find customization value for '{0}' in Application gateway deployment item '{1}'.", CommonCustomizationNames.ApplicationGatewayCookieBaseAffinity, item.ItemName);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ApplicationGatewayMalformed);
                return false;
            }

            // get the Back End deployment item
            DeploymentItem backendDeploymentItem;
            if (!entity.DeploymentItems.TryGetFirst(item.ParentItemName, out backendDeploymentItem) || backendDeploymentItem == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Application gateway deployment item '{0}' have invalid parent item name.", item.ItemName);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ApplicationGatewayMalformed);
                return false;
            }

            string httpLoadbalancingRuleType;
            if (!item.TryGetCustomizationValue(CommonCustomizationNames.ApplicationGatewayHttpLoadBalancingRuleType, out httpLoadbalancingRuleType))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Could not find customization value for '{0}' in Application gateway deployment item '{1}'.", CommonCustomizationNames.ApplicationGatewayHttpLoadBalancingRuleType, item.ItemName);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ApplicationGatewayMalformed);
                return false;
            }

            if (!backendDeploymentItem.IsVmBased())
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Application gateway deployment item '{0}' has invalid parent item. The parent item must be a VM based deployment.", item.ItemName);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ApplicationGatewayMalformed);
                return false;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Validated application gateway deployment item '{0}' in topology '{1}'.", item.ItemName, entity.InstanceId);

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates if the network configuration provided by the user is valid.
        /// </summary>
        /// <param name="tenantRegistration">The TenantRegistration for the subscription.</param>
        /// <param name="entity">The topology instance.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True or false.</returns>
        private bool ValidateNetworkConfiguration(TenantRegistration tenantRegistration, TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            Contract.Requires(entity != null);

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Validating if the Network customization met the required prerequisites.");

            DeploymentItem networkItem = entity.GetPrimaryNetworkDeploymentItem();

            // if user has provided a VNET name validate if it can be used in the subscription
            if (networkItem != null && networkItem.CustomizationGroups != null)
            {
                CustomizationGroup vnetCustomizationGroup = networkItem.CustomizationGroups.SingleOrDefault(cg => cg.Name.Equals(CommonCustomizationNames.VnetName, StringComparison.OrdinalIgnoreCase));

                if (vnetCustomizationGroup != null &&
                    vnetCustomizationGroup.Groups != null)
                {
                    Group selectedGroup = vnetCustomizationGroup.Groups.FirstOrDefault(group => group.Selected);

                    if (selectedGroup != null)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "User customized the virtual network.");

                        if (selectedGroup.Name.Equals(CommonCustomizationNames.NewVnet, StringComparison.OrdinalIgnoreCase))
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "User chose to deploy a new VNET.");
                            Customization newVnetCustomization = selectedGroup.Customizations.FirstOrDefault(c => c.FieldName.Equals(CommonCustomizationNames.VnetName, StringComparison.OrdinalIgnoreCase));
                            if (newVnetCustomization != null &&
                                !string.IsNullOrEmpty(newVnetCustomization.SelectedValue))
                            {
                                string newVnetName = newVnetCustomization.SelectedValue;

                                int minVNetNameLength = 3;
                                if (newVnetName.Length < minVNetNameLength || newVnetName.Length > VirtualNetworkNameMaxLength)
                                {
                                    Tracer.WriteExecutionEvent(
                                        TraceComponent.DeploymentServiceApi,
                                        "Topology instance virtual network name '{0}' of length '{1}' is not valid. It must have at least '{2}' characters and at most '{3}' characters.",
                                        newVnetName,
                                        newVnetName.Length,
                                        minVNetNameLength,
                                        VirtualNetworkNameMaxLength);
                                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_VnetNameIsNotOfValidLength, minVNetNameLength, VirtualNetworkNameMaxLength);
                                    return false;
                                }

                                if (!char.IsLetter(newVnetName[0]))
                                {
                                    Tracer.WriteExecutionEvent(
                                        TraceComponent.DeploymentServiceApi,
                                        "Topology instance virtual network name '{0}' did not start with a letter.",
                                        newVnetName);
                                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_VnetNameContainsInvalidCharacters);
                                    return false;
                                }

                                // From Azure: the virtual network name must begin with a letter or number, end with a letter, number or underscore, and may contain
                                // only letters, numbers, underscores, periods, or hyphens.
                                const string ValidVNETNameRegex = "^[a-zA-Z0-9]+[a-zA-Z0-9_.-]*[a-zA-Z0-9_]$";

                                if (!RE.Regex.IsMatch(newVnetName, ValidVNETNameRegex))
                                {
                                    Tracer.WriteExecutionEvent(
                                        TraceComponent.DeploymentServiceApi,
                                        "Topology instance virtual network name '{0}' must start with a letter and can only contain AlphaNumeric characters, '_', '.', and '-'. It must end with an AlphaNumeric character or '_'.",
                                        newVnetName);
                                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_VnetNameContainsInvalidCharacters);
                                    return false;
                                }

                                if (!entity.ShouldUseAzureResourceManager())
                                {
                                    IServiceManagement azureProxy = tenantRegistration.CreateAzureServiceManagement();

                                    // validate that the new VNET doesn't exist
                                    string customVnetName = newVnetCustomization.SelectedValue;
                                    NetworkConfiguration vnetConfiguration = null;
                                    if (!azureProxy.TryGetNetworkConfiguration(tenantRegistration.AzureSubscriptionId, out vnetConfiguration))
                                    {
                                        // no virtual network exists; OK to proceed
                                        errorMessage = null;
                                        return true;
                                    }

                                    if (vnetConfiguration != null &&
                                        vnetConfiguration.VirtualNetworkConfiguration != null &&
                                        vnetConfiguration.VirtualNetworkConfiguration.VirtualNetworkSites != null &&
                                        vnetConfiguration.VirtualNetworkConfiguration.VirtualNetworkSites.Any(vnet => vnet.name.Equals(customVnetName, StringComparison.OrdinalIgnoreCase)))
                                    {
                                        string message = Tracer.FormatMessage(
                                              "Custom VNET name '{0}' is already in use in the subscription '{1}'. Provide a different VNET name.",
                                              customVnetName,
                                              tenantRegistration.AzureSubscriptionId);

                                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);

                                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_DuplicateVnetName);
                                        return false;
                                    }
                                }
                            }
                            else
                            {
                                // user chose to customize the virtual network name but did not provide a custom name
                                // ignore this and proceed as if the customer wanted to deploy a VNET with an auto-generated name
                                errorMessage = null;
                                return true;
                            }
                        }
                        else if (selectedGroup.Name.Equals(CommonCustomizationNames.UseExistingVnet, StringComparison.OrdinalIgnoreCase))
                        {
                            return this.ValidateExistingNetworkConfiguration(tenantRegistration, entity, selectedGroup, out errorMessage);
                        }
                    }
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates if the existing network configuration provided by the user is valid.
        /// </summary>
        /// <param name="tenantRegistration">The TenantRegistration of subscription.</param>
        /// <param name="entity">The topology instance.</param>
        /// <param name="selectedGroup">Group containing existing network configuration information.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True or false.</returns>
        [SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmantainableCode", Justification = "Breaking into more function will increase code complexity.")]
        private bool ValidateExistingNetworkConfiguration(TenantRegistration tenantRegistration, TopologyInstance entity, Group selectedGroup, out HttpResponseMessage errorMessage)
        {
            Guid azureSubscriptionId = tenantRegistration.AzureSubscriptionId;

            // regex to match the address prefix of the form IPAddress/CIDR
            RE.Regex ipaddressRegex = new RE.Regex(IPRangeRegEx);

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "User chose to deploy to an existing VNET.");

            // validate existing VNET properties
            Customization vnetNameCustomization = selectedGroup.Customizations.FirstOrDefault(c => c.FieldName.Equals(CommonCustomizationNames.VnetName, StringComparison.OrdinalIgnoreCase));
            Customization addressSpaceCustomization = selectedGroup.Customizations.FirstOrDefault(c => c.FieldName.Equals(CommonCustomizationNames.AddressSpace, StringComparison.OrdinalIgnoreCase));
            Customization applicationSubnetNameCustomization = selectedGroup.Customizations.FirstOrDefault(c => c.FieldName.Equals(CommonCustomizationNames.ApplicationSubnetName, StringComparison.OrdinalIgnoreCase));
            Customization activeDirectorySubnetCustomization = selectedGroup.Customizations.FirstOrDefault(c => c.FieldName.Equals(CommonCustomizationNames.ADSubnet, StringComparison.OrdinalIgnoreCase));
            Customization sqlHASubnetNameCustomization = selectedGroup.Customizations.FirstOrDefault(c => c.FieldName.Equals(CommonCustomizationNames.SqlHASubnetName, StringComparison.OrdinalIgnoreCase));

            string vnetResourceGroup = null;
            string vnetName = null;

            // validate the customization selectedvalues
            if (vnetNameCustomization != null)
            {
                if (string.IsNullOrEmpty(vnetNameCustomization.SelectedValue))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Topology instance is missing the custom virtual network name.");
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_CustomVnetNameMissing);
                    return false;
                }

                if (char.IsDigit(vnetNameCustomization.SelectedValue[0]))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Topology instance virtual network name starts with a digit.");
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_VnetNameStartsWithDigit);
                    return false;
                }

                if (entity.ShouldUseAzureResourceManager())
                {
                    string[] resourceGroupVnetNameSplit = vnetNameCustomization.SelectedValue.Split(':');

                    if (resourceGroupVnetNameSplit.Length < 2)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, string.Format(CultureInfo.CurrentCulture, "Should be in this form: 'ResourceGroupName:VNETName'. Value passed '{0}'", vnetNameCustomization.SelectedValue));
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ResourceGroupVNETMissing);
                        return false;
                    }

                    vnetResourceGroup = resourceGroupVnetNameSplit[0];
                    vnetName = resourceGroupVnetNameSplit[1];
                }
            }

            if (addressSpaceCustomization != null &&
                (string.IsNullOrEmpty(addressSpaceCustomization.SelectedValue) ||
                !ipaddressRegex.IsMatch(addressSpaceCustomization.SelectedValue)))
            {
                string message = Tracer.FormatMessage(
                       "Topology instance is missing the application subnet address space or contains an invalid address space. The supplied value is '{0}'", addressSpaceCustomization.SelectedValue);

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_AddressSpaceMissingOrInvalid);
                return false;
            }

            if (applicationSubnetNameCustomization != null &&
                string.IsNullOrEmpty(applicationSubnetNameCustomization.SelectedValue))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Topology instance is missing the application subnet name.");
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ApplicationSubnetMissingOrInvalid);
                return false;
            }

            // check ADSubnet customization only if we have an ActiveDirectory item (any) for this topology
            if (activeDirectorySubnetCustomization != null && entity.DeploymentItems.Any(i => i.IsItemType(DeploymentItemType.ActiveDirectory) && i.GetInstanceCount() > 0) &&
                !entity.UseExistingInfrastructure(CommonCustomizationNames.DomainName, CommonCustomizationNames.UseExistingDomain) &&
                (string.IsNullOrEmpty(activeDirectorySubnetCustomization.SelectedValue) ||
                !ipaddressRegex.IsMatch(activeDirectorySubnetCustomization.SelectedValue) ||
                !this.IsValidCidr(activeDirectorySubnetCustomization.SelectedValue)))
            {
                string message = Tracer.FormatMessage(
                       "Topology instance is missing the Active Directory subnet address prefix or contains an invalid address prefix. The supplied value is '{0}'", activeDirectorySubnetCustomization.SelectedValue);

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ADSubnetMissingOrInvalid);
                return false;
            }

            if (sqlHASubnetNameCustomization != null &&
                string.IsNullOrEmpty(sqlHASubnetNameCustomization.SelectedValue))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Topology instance is missing the Sql HA subnet name.");
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_SQLHASubnetMissingOrInvalid);
                return false;
            }

            if (entity.ShouldUseAzureResourceManager())
            {
                VirtualNetwork virtualNetwork = null;
                using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager(vnetResourceGroup))
                {
                    try
                    {
                        manager.Resource.Value.GetResourceGroup();
                    }
                    catch (CloudException ce)
                    {
                        string message = Tracer.FormatMessage(
                             "Could not retrieve '{0}' in the subscription with ID '{1}'. Cannot proceed further as the customer chose to use an existing Resource Group that does not exist. Exception: '{2}'",
                             vnetResourceGroup,
                             azureSubscriptionId,
                             ce.ToString());

                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);

                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ResourceGroupDoesNotExist);
                        return false;
                    }

                    try
                    {
                        virtualNetwork = manager.Network.Value.GetVirtualNetwork(vnetName);
                    }
                    catch (CloudException ce)
                    {
                        string message = Tracer.FormatMessage(
                             "No virtual network with the name '{0}' exists in the resource group '{1}'. Cannot proceed further as the customer chose to use an existing VNET but as no virtual network exists. Exception: '{1}'",
                             vnetName,
                             vnetResourceGroup,
                             ce.ToString());

                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, ce.Message);

                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_CustomVnetNotExists);
                        return false;
                    }
                }

                string cloudServiceLocation = TopologyInstanceExtensions.MapRDFEtoARMLocation(entity.CloudServiceLocation);

                // validate if the location of the custom VNET matches the location of the Resource Group.
                if (!string.Equals(virtualNetwork.Location, cloudServiceLocation, StringComparison.OrdinalIgnoreCase))
                {
                    string message = Tracer.FormatMessage("The location '{0}' of the user selected virtual network does not match the Topology location '{1}'.", virtualNetwork.Location, cloudServiceLocation);

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_IncorrectVirtualNetworkLocation);
                    return false;
                }

                // validate that the AD subnet doesn't exists only if the user chose the option to create a new AD infrastructure
                // else we assume that the AD infrastructure exists and there is a DNS entry in the VNET pointing to their AD infrastructure
                if (!entity.UseExistingInfrastructure(CommonCustomizationNames.DomainName, CommonCustomizationNames.UseExistingDomain) &&
                    activeDirectorySubnetCustomization != null)
                {
                    if (!virtualNetwork.AddressSpace.AddressPrefixes.Any(addressspace => string.Equals(addressspace, addressSpaceCustomization.SelectedValue, StringComparison.OrdinalIgnoreCase)))
                    {
                        string message = Tracer.FormatMessage(
                         "The supplied address space '{0}' does not exist in the virtual network '{1}'", addressSpaceCustomization.SelectedValue, vnetNameCustomization);

                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_AddressSpaceMissingOrInvalid);
                        return false;
                    }

                    // validate that the AD subnet doesn't exist in the virtual network specified by the user
                    if (virtualNetwork.Subnets != null)
                    {
                        string activeDirectorySubnetIpAddress = string.Empty;

                        // get the IPAddress from the address prefix and the AD subnet provided by the user
                        // eg: addressprefix = 10.0.1.0/16
                        RE.Match match = ipaddressRegex.Match(activeDirectorySubnetCustomization.SelectedValue);
                        activeDirectorySubnetIpAddress = match.Groups[1].Value;
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Checking if the user supplied active directory subnet IP address value '{0}' exist in the VNET.", activeDirectorySubnetIpAddress);

                        foreach (Microsoft.Azure.Management.Network.Models.Subnet subnet in virtualNetwork.Subnets)
                        {
                            string subnetIpAddress = string.Empty;

                            match = ipaddressRegex.Match(subnet.AddressPrefix);
                            if (match.Success)
                            {
                                subnetIpAddress = match.Groups[1].Value;
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Checking the subnet IP address '{0}' against active directory subnet IP address '{1}'.", subnetIpAddress, activeDirectorySubnetIpAddress);
                            }

                            if (subnetIpAddress.Equals(activeDirectorySubnetIpAddress, StringComparison.OrdinalIgnoreCase))
                            {
                                string message = Tracer.FormatMessage(
                                    "The AD subnet address prefix '{0}' exist in the virtual network '{1}' in subscription '{2}' which is not allowed. Specify a subnet IP address/CIDR value that doesn't exist and does not clash with the existing subnets.",
                                    activeDirectorySubnetCustomization.SelectedValue,
                                    vnetNameCustomization.SelectedValue,
                                    tenantRegistration.AzureSubscriptionId);

                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ADSubnetAddressPrefixExists);
                                return false;
                            }
                        }

                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The user supplied active directory subnet '{0}' is valid and does not exist in the VNET {1}.", activeDirectorySubnetCustomization.SelectedValue, vnetNameCustomization.SelectedValue);
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "There are no subnets in the custom VNET {0}.", vnetNameCustomization.SelectedValue);
                    }
                }

                // validate that the target subnet has enough available IP addresses
                if (!this.ValidateARMAvailableIPs(entity.GetVirtualMachineCount(), virtualNetwork, applicationSubnetNameCustomization.SelectedValue, out errorMessage))
                {
                    return false;
                }
            }
            else
            {
                IServiceManagement azureProxy = tenantRegistration.CreateAzureServiceManagement();

                NetworkConfiguration networkConfig;
                if (!azureProxy.TryGetNetworkConfiguration(azureSubscriptionId, out networkConfig))
                {
                    string message = Tracer.FormatMessage(
                             "No virtual network exists in the subscription '{0}. Cannot proceed further as the customer chose to use an existing VNET but as no virtual network exists.'",
                          azureSubscriptionId);

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_CustomVnetNotExists);
                    return false;
                }

                // check if the custom VNET exists
                VirtualNetworkSite selectedVnet = networkConfig.VirtualNetworkConfiguration.VirtualNetworkSites.FirstOrDefault(vnet => string.Equals(vnet.name, vnetNameCustomization.SelectedValue, StringComparison.OrdinalIgnoreCase));

                if (selectedVnet == null)
                {
                    string message = Tracer.FormatMessage(
                      "User selected virtual network '{0}' does not exist in subscription '{1}'.",
                      vnetNameCustomization.SelectedValue,
                      azureSubscriptionId);

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_CustomVnetNotExists);
                    return false;
                }

                // validate if the location of the custom VNET matches the cloud service location
                if (!string.Equals(selectedVnet.Location, entity.CloudServiceLocation, StringComparison.OrdinalIgnoreCase))
                {
                    string message = Tracer.FormatMessage("The location '{0}' of the user selected virtual network does not match the cloud service location '{1}'.", selectedVnet.Location, entity.CloudServiceLocation);

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_IncorrectVirtualNetworkLocation);
                    return false;
                }

                // validate that the AD subnet doesn't exists only if the user chose the option to create a new AD infrastructure
                // else we assume that the AD infrastructure exists and there is a DNS entry in the VNET pointing to their AD infrastructure
                if (!entity.UseExistingInfrastructure(CommonCustomizationNames.DomainName, CommonCustomizationNames.UseExistingDomain) &&
                    activeDirectorySubnetCustomization != null)
                {
                    if (!selectedVnet.AddressSpace.Any(addressspace => string.Equals(addressspace.value, addressSpaceCustomization.SelectedValue, StringComparison.OrdinalIgnoreCase)))
                    {
                        string message = Tracer.FormatMessage(
                         "The supplied address space '{0}' does not exist in the virtual network '{1}'", addressSpaceCustomization.SelectedValue, vnetNameCustomization);

                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_AddressSpaceMissingOrInvalid);
                        return false;
                    }

                    // validate that the AD subnet doesn't exist in the virtual network specified by the user
                    if (selectedVnet.Subnets != null)
                    {
                        string activeDirectorySubnetIpAddress = string.Empty;

                        // get the IPAddress from the address prefix and the AD subnet provided by the user
                        // eg: addressprefix = 10.0.1.0/16
                        RE.Match match = ipaddressRegex.Match(activeDirectorySubnetCustomization.SelectedValue);
                        activeDirectorySubnetIpAddress = match.Groups[1].Value;
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Checking if the user supplied active directory subnet IP address value '{0}' exist in the VNET.", activeDirectorySubnetIpAddress);

                        foreach (Microsoft.DynamicsOnline.Deployment.WindowsAzure.ServiceManagement.Subnet subnet in selectedVnet.Subnets)
                        {
                            string subnetIpAddress = string.Empty;

                            match = ipaddressRegex.Match(subnet.AddressPrefix);
                            if (match.Success)
                            {
                                subnetIpAddress = match.Groups[1].Value;
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Checking the subnet IP address '{0}' against active directory subnet IP address '{1}'.", subnetIpAddress, activeDirectorySubnetIpAddress);
                            }

                            if (subnetIpAddress.Equals(activeDirectorySubnetIpAddress, StringComparison.OrdinalIgnoreCase))
                            {
                                string message = Tracer.FormatMessage(
                                    "The AD subnet address prefix '{0}' exist in the virtual network '{1}' in subscription '{2}' which is not allowed. Specify a subnet IP address/CIDR value that doesn't exist and does not clash with the existing subnets.",
                                    activeDirectorySubnetCustomization.SelectedValue,
                                    vnetNameCustomization.SelectedValue,
                                    azureSubscriptionId);

                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, message);
                                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ADSubnetAddressPrefixExists);
                                return false;
                            }
                        }

                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The user supplied active directory subnet '{0}' is valid and does not exist in the VNET {1}.", activeDirectorySubnetCustomization.SelectedValue, vnetNameCustomization.SelectedValue);
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "There are no subnets in the custom VNET {0}.", vnetNameCustomization.SelectedValue);
                    }
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates if the virtual machine name provided by the user is valid.
        /// </summary>
        /// <param name="entity">The topology instance.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True or false.</returns>
        private bool ValidateVMName(TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            Contract.Requires(entity != null);
            errorMessage = null;
            bool result = true;
            HashSet<string> nameCustomizations = new HashSet<string>();

            foreach (var deploymentItem in entity.DeploymentItems)
            {
                List<Customization> customizations;
                var machineNameCustomizationExists = entity.TryGetCustomizationsFromCustomizationGroup(CommonCustomizationNames.MachineNameCustomization, deploymentItem.ItemName, out customizations);
                if (!machineNameCustomizationExists)
                {
                    continue;
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Validating if the VM name met the required prerequisites for deployment item {0}.", deploymentItem.ItemName);

                var nameCustomization = customizations.Where(c => String.Equals(c.FieldName, CommonCustomizationNames.VMName)).FirstOrDefault();
                var indexCustomization = customizations.Where(c => String.Equals(c.FieldName, CommonCustomizationNames.VMNameStartIndex)).FirstOrDefault();
                if (nameCustomization == null || string.IsNullOrEmpty(nameCustomization.SelectedValue))
                {
                    continue;
                }

                if (string.IsNullOrWhiteSpace(nameCustomization.SelectedValue))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The VM name '{0}' provided in machine customization with length '{2}' has only white spaces for deployment item '{1}'", nameCustomization.SelectedValue, deploymentItem.ItemName, nameCustomization.SelectedValue.Length);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.CustomizationsForVMNameIsInvalid);
                    result = false;
                    break;
                }

                int indexLength = indexCustomization != null ? indexCustomization.SelectedValue.Length : 0;
                int maxLength = VmDeploymentController.VmNameMaxLength - VmDeploymentController.VmNameSuffixLength - indexLength;
                if (nameCustomization.SelectedValue.Length > maxLength)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The VM name '{0}' provided in machine customization with length '{2}' exceeds the maximum length '{3}' for deployment item '{1}'", nameCustomization.SelectedValue, deploymentItem.ItemName, nameCustomization.SelectedValue.Length, maxLength);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.CustomizationsForVMNameIsInvalid);
                    result = false;
                    break;
                }

                if (!this.IsValidVmName(nameCustomization.SelectedValue))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The VM name '{0}' provided in machine customization is not a valid VM name for deployment item '{1}' as per azure requirements.", nameCustomization.SelectedValue, deploymentItem.ItemName, nameCustomization.SelectedValue.Length, maxLength);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.CustomizationsForVMNameIsInvalid);
                    result = false;
                    break;
                }

                if (nameCustomizations.Contains(nameCustomization.SelectedValue))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The VM name '{0}' provided in machine customization is duplicated for deployment item '{1}'", nameCustomization.SelectedValue, deploymentItem.ItemName);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.CustomizationsForVMNameIsDuplicated, nameCustomization.SelectedValue);
                    result = false;
                    break;
                }
                else
                {
                    nameCustomizations.Add(nameCustomization.SelectedValue);
                }

                if (indexCustomization == null || string.IsNullOrEmpty(indexCustomization.SelectedValue))
                {
                    continue;
                }

                int startIndex;
                if (!int.TryParse(indexCustomization.SelectedValue, out startIndex) || startIndex < 1)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The VM start index '{0}' provided in machine customization is invalid for deployment item '{1}'", indexCustomization.SelectedValue, deploymentItem.ItemName);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.CustomizationsForVMNameIsInvalid);
                    result = false;
                    break;
                }
            }

            return result;
        }

        /// <summary>
        /// Determines whether the given string is valid VM name.
        /// </summary>
        /// <param name="name">Name of the VM.</param>
        /// <returns>True of false.</returns>
        private bool IsValidVmName(string name)
        {
            bool containsNonNumericCharacters = false;
            foreach (char nameCharacter in name)
            {
                if (!char.IsNumber(nameCharacter))
                {
                    containsNonNumericCharacters = true;
                }

                if (invalidVmCharacters.Contains(nameCharacter))
                {
                    return false;
                }
            }

            return containsNonNumericCharacters;
        }

        /// <summary>
        /// Validates if the CIDR value in an address prefix is valid and is within the acceptable range.
        /// </summary>
        /// <param name="addressPrefix">The address prefix to validate.</param>
        /// <returns>True of false.</returns>
        private bool IsValidCidr(string addressPrefix)
        {
            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Validating if address prefix '{0}' has a valid CIDR value.", addressPrefix);

            IPAddressPrefix ipAddressPrefix;

            if (!IPAddressPrefix.TryParse(addressPrefix, out ipAddressPrefix))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to parse address prefix '{0}'.", addressPrefix);
                return false;
            }

            // Azure CIDR should be in the range 8 through 29
            if (ipAddressPrefix.Cidr < 8 ||
                ipAddressPrefix.Cidr > 29)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "CIDR value '{0}' is not in the acceptable range", ipAddressPrefix.Cidr);
                return false;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "CIDR value '{0}' is valid", ipAddressPrefix.Cidr);
            return true;
        }

        /// <summary>
        /// Validates the storage account.
        /// </summary>
        /// <param name="tenantRegistration">The tenant.</param>
        /// <param name="entity">The entity.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns><c>True</c>If the validation is successful for storage account.</returns>
        private bool ValidateStorageAccount(TenantRegistration tenantRegistration, TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            bool hasStorageAccount = entity.StorageAccounts.Any();

            // backwards compatibility
            hasStorageAccount |= entity.Customizations.Any(c => c.IsValueType(CustomizationValueType.StorageAccount))
                || entity.DeploymentItems.Any(di => di.Customizations.Any(c => c.IsValueType(CustomizationValueType.StorageAccount)));

            bool success = true;
            if (hasStorageAccount)
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Validating the name prefix for storage account customization for subscription '{0}'",
                    tenantRegistration.AzureSubscriptionId.ToString());

                string storageAccountName;
                if (entity.ShouldUseAzureResourceManager())
                {
                    using (var manager = tenantRegistration.CreateAzureResourceManager())
                    {
                        if (!this.GetValidARMStorageAccountName(manager, entity.CloudServiceName, out storageAccountName))
                        {
                            success = false;
                        }
                    }
                }
                else
                {
                    var azureProxy = tenantRegistration.CreateAzureServiceManagement();
                    if (!StorageAccountDeploymentController.GetValidAzureStorageAccountName(entity.CloudServiceName, tenantRegistration.AzureSubscriptionId, azureProxy, out storageAccountName))
                    {
                        success = false;
                    }
                }
            }

            if (!success)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The name prefix chosen for deployment has invalid storage account name prefix. Prefix '{0}'", entity.CloudServiceName);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopologyName);
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates the storage account availability, based on the type regular or XIO.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="tenantRegistration">Registration that corresponds to this tenant.</param>
        /// <param name="storageAccountType">Storage account type that we should check.</param>
        /// <param name="subscription">Azure subscription containing resourcing information.</param>
        /// <param name="azureProxy">Azure proxy.</param>
        /// <param name="isDisasterRecovery">A flag indicating whether or not the storage account being validated is a disaster recovery account.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        private bool ValidateRDFEStorageAccount(Guid azureSubscriptionId, TopologyInstance entity, TenantRegistration tenantRegistration, StorageAccountType storageAccountType, AzureSubcription subscription, IServiceManagement azureProxy, bool isDisasterRecovery, out HttpResponseMessage errorMessage)
        {
            Contract.Requires(storageAccountType != StorageAccountType.Undefined);

            bool isEndpointFound = false;
            bool isForbidden = false;
            string tenantStorageAccount = tenantRegistration.GetStorageAccountName(storageAccountType, entity.CloudStorageLocation, AzureManagementAPIType.RDFE, isDisasterRecovery);
            string tenantStorageAccountCreationOperationId = tenantRegistration.GetStorageAccountCreationOperationId(storageAccountType, AzureManagementAPIType.RDFE, entity.CloudStorageLocation, isDisasterRecovery);
            ServiceErrorCode errorCode = (storageAccountType == StorageAccountType.PremiumXIO) ? ServiceErrorCode.PremiumStorageCreationInProgress : ServiceErrorCode.StorageAccountCreationInProgress;

            errorMessage = null;

            if (!string.IsNullOrEmpty(tenantStorageAccount))
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Validating that subscription '{0}' has storage account '{1}' of type {2} and its keys accessible.",
                    azureSubscriptionId.ToString(),
                    tenantStorageAccount,
                    storageAccountType.ToString());

                RetryManager.ExecuteWithRetry(
                    RetryPolicy.DefaultPolicy,
                    () =>
                    {
                        string primaryStorageKey;
                        try
                        {
                            StorageService service = azureProxy.GetStorageService(azureSubscriptionId.ToString(), tenantStorageAccount);
                            StorageService serviceWithKeys = azureProxy.GetStorageKeys(azureSubscriptionId.ToString(), tenantStorageAccount);
                            Tracer.WriteExecutionEvent(
                                TraceComponent.DeploymentServiceApi,
                                "Validated that subscription '{0}' has storage account '{1}', type {2} and its keys accessible at '{3}'.",
                                azureSubscriptionId.ToString(),
                                tenantStorageAccount,
                                storageAccountType.ToString(),
                                service.Url);

                            primaryStorageKey = serviceWithKeys.StorageServiceKeys.Primary;
                        }
                        catch (EndpointNotFoundException ex)
                        {
                            Tracer.WriteExecutionEvent(
                                TraceComponent.DeploymentServiceApi,
                                "Could not access subscription '{0}', storage account '{1}' of type {2}. Exception: {3}",
                                azureSubscriptionId.ToString(),
                                tenantStorageAccount,
                                storageAccountType.ToString(),
                                ex.ToString());

                            return true;
                        }

                        Contract.Assert(primaryStorageKey != null);
                        isEndpointFound = true;

                        return ValidateStorageAccountConnection(tenantStorageAccount, primaryStorageKey, azureSubscriptionId, storageAccountType, out isForbidden);
                    });
            }

            if (isEndpointFound)
            {
                if (isForbidden)
                {
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.StorageAccountForbiddenPermissions, azureSubscriptionId.ToString());
                    return false;
                }
                else
                {
                    // validated, we can return.
                    return true;
                }
            }

            // If we cannot find the storage account, it may be that it is still being created.
            // Check the operation ID. Report to user if it's still in progress, and attempt to recreate if not.
            ServiceManagement.Operation azureOperation;
            if (string.IsNullOrWhiteSpace(tenantStorageAccountCreationOperationId))
            {
                Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                "The tenant {0} with subscription '{1}'  does not have an operation ID for the creation of the storage account '{2}' of type {3}.",
                tenantRegistration.TenantId.ToString(),
                azureSubscriptionId.ToString(),
                tenantStorageAccount,
                storageAccountType.ToString());

                azureOperation = null;
            }
            else
            {
                try
                {
                    azureOperation = azureProxy.GetOperationStatus(azureSubscriptionId.ToString(), tenantStorageAccountCreationOperationId);
                }
                catch (EndpointNotFoundException ex)
                {
                    azureOperation = null;

                    var msg = string.Format(
                        CultureInfo.InvariantCulture,
                        "No endpoint found for the storage account {0} for the tenant {1} with subscription {2}",
                        tenantStorageAccount,
                        tenantRegistration.TenantId.ToString(),
                        azureSubscriptionId.ToString());
                    Tracer.WriteWarningEvent(TraceComponent.DeploymentServiceApi, ex, msg);
                }
            }

            if (azureOperation != null && azureOperation.InProgress())
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "The tenant {0} with subscription '{1}' still has an ongoing operation for storage account '{2}' of type {3}. Operation Id: {4}",
                    tenantRegistration.TenantId.ToString(),
                    azureSubscriptionId.ToString(),
                    tenantStorageAccount,
                    storageAccountType.ToString(),
                    tenantStorageAccountCreationOperationId);

                errorMessage = this.CreateErrorResponse(errorCode, tenantStorageAccount, tenantStorageAccountCreationOperationId);
                return false;
            }
            else
            {
                if (azureOperation == null)
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "The tenant {0} with subscription '{1}' did not have storage account creation operation on storage account '{2}' of type {3}. Since we cannot find the storage account, we will re-create it nevertheless.",
                        tenantRegistration.TenantId.ToString(),
                        azureSubscriptionId.ToString(),
                        tenantStorageAccount,
                        storageAccountType.ToString());
                }
                else
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "The tenant {0} with subscription '{1}' had an operation on storage account '{2}' of type {3} with status {4} and operation ID: {5}. Since we cannot find the storage account, we will re-create it nevertheless.",
                        tenantRegistration.TenantId.ToString(),
                        azureSubscriptionId.ToString(),
                        tenantStorageAccount,
                        storageAccountType.ToString(),
                        azureOperation.Status,
                        tenantStorageAccountCreationOperationId);
                }

                string azureOperationId;
                string storageAccountName;
                string storageAccountTypeString = (storageAccountType == StorageAccountType.PremiumXIO) ? Microsoft.DynamicsOnline.Deployment.Constants.XIOStorageAccountType : Microsoft.DynamicsOnline.Deployment.Constants.DefaultStorageAccountType;
                string primaryLocation = entity.CloudStorageLocation;
                string disasterRecoveryLocation = isDisasterRecovery ? entity.DisasterRecoveryLocation : null;
                string targetLocation = disasterRecoveryLocation ?? primaryLocation;

                HttpResponseMessage errorResponse;
                if (this.CreateStorageAccount(
                    subscription,
                    targetLocation,
                    azureProxy,
                    storageAccountTypeString,
                    out azureOperationId,
                    out storageAccountName,
                    out errorResponse))
                {
                    tenantRegistration.SetStorageAccount(storageAccountType, AzureManagementAPIType.RDFE, primaryLocation, storageAccountName, azureOperationId, disasterRecoveryLocation);

                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Requested for tenant {0} with subscription '{1}' the creation of storage account '{2}'  of type {3} with operation ID: {4}. ",
                        tenantRegistration.TenantId.ToString(),
                        azureSubscriptionId.ToString(),
                        storageAccountName,
                        storageAccountType.ToString(),
                        azureOperationId);

                    TenantRegistrationDAC.UpsertTenantRegistration(tenantRegistration, decryptAfterUpsert: false);

                    errorMessage = this.CreateErrorResponse(errorCode, storageAccountName, azureOperationId);
                    return false;
                }
                else
                {
                    errorMessage = errorResponse;
                    return false;
                }
            }
        }

        /// <summary>
        /// Tries to validate that the ARM Storage Account exist in the Subscription.
        /// </summary>
        /// <param name="entity">The deployment request.</param>
        /// <param name="tenantRegistration">Registration that corresponds to this tenant.</param>
        /// <param name="storageAccountType">Storage account type that we should check.</param>
        /// <param name="isDisasterRecovery">A flag indicating whether we should check the disaster recovery account.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>Returns a boolean value if the Subscription was found.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Must be robust.")]
        private bool ValidateARMStorageAccount(TopologyInstance entity, TenantRegistration tenantRegistration, StorageAccountType storageAccountType, bool isDisasterRecovery, out HttpResponseMessage errorMessage)
        {
            ServiceErrorCode errorCode = (storageAccountType == StorageAccountType.PremiumXIO) ? ServiceErrorCode.PremiumStorageCreationInProgress : ServiceErrorCode.StorageAccountCreationInProgress;
            string skuName = (storageAccountType == StorageAccountType.PremiumXIO) ? Storage.SkuName.PremiumLRS : Storage.SkuName.StandardLRS;

            string primaryLocation = entity.GetARMLocation();
            string disasteryRecoveryLocation = isDisasterRecovery ? entity.GetARMLocation(isDisasterRecovery: true) : null;
            string targetLocation = disasteryRecoveryLocation ?? primaryLocation;
            string resourceGroup = TenantRegistration.GetDefaultResourceGroup(targetLocation);

            using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager(resourceGroup))
            {
                bool isEndpointFound = false;
                bool isForbidden = false;

                Guid azureSubscriptionId = tenantRegistration.AzureSubscriptionId;

                string tenantStorageAccount = tenantRegistration.GetStorageAccountName(storageAccountType, primaryLocation, AzureManagementAPIType.ARM, isDisasterRecovery);
                string tenantStorageAccountCreationOperationId = string.Empty; // this may be removed as recent update of Microsoft.Azure.Management.Storage doesnt have it.

                errorMessage = null;

                if (!string.IsNullOrEmpty(tenantStorageAccount))
                {
                    Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Validating that subscription '{0}' has a ARM storage account '{1}' of type {2} and its keys accessible.",
                    azureSubscriptionId.ToString(),
                    tenantStorageAccount,
                    storageAccountType.ToString());

                    RetryManager.ExecuteWithRetry(
                        RetryPolicy.DefaultPolicy,
                        () =>
                        {
                            string primaryStorageKey;
                            try
                            {
                                Storage.StorageAccount storageAccount = manager.Storage.Value.GetStorageAccount(tenantStorageAccount);
                                Storage.StorageAccountKey primaryStorageKeyObj = manager.Storage.Value.GetStorageAccountKey(tenantStorageAccount);
                                Tracer.WriteExecutionEvent(
                                    TraceComponent.DeploymentServiceApi,
                                    "Validated that subscription '{0}' has a ARM storage account '{1}', type {2} and its keys accessible at '{3}'.",
                                    azureSubscriptionId.ToString(),
                                    tenantStorageAccount,
                                    storageAccountType.ToString(),
                                    storageAccount.PrimaryEndpoints.Blob);

                                primaryStorageKey = primaryStorageKeyObj.Value;
                            }
                            catch (Exception e)
                            {
                                bool isResourceNotFound = e.IsResourceNotFound();

                                Tracer.WriteExecutionEvent(
                                    TraceComponent.DeploymentServiceApi,
                                    "Could not access subscription '{0}', ARM storage account '{1}' of type {2}. NotFound: {3} Exception: {4}",
                                    azureSubscriptionId.ToString(),
                                    tenantStorageAccount,
                                    storageAccountType.ToString(),
                                    isResourceNotFound,
                                    e.ToString());

                                if (isResourceNotFound)
                                {
                                    // Exception is of type not found. Treat as success and allow rest of code to handle re-creation of storage account.
                                    return true;
                                }
                                else
                                {
                                    // Unexpected exception. Abort and fail validation.
                                    throw;
                                }
                            }

                            Contract.Assert(primaryStorageKey != null);
                            isEndpointFound = true;

                            return ValidateStorageAccountConnection(tenantStorageAccount, primaryStorageKey, azureSubscriptionId, storageAccountType, out isForbidden);
                        });
                }

                if (isEndpointFound)
                {
                    if (isForbidden)
                    {
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.StorageAccountForbiddenPermissions, azureSubscriptionId.ToString());
                        return false;
                    }
                    else
                    {
                        // validated, we can return.
                        return true;
                    }
                }

                // If we cannot find the storage account, it may be that it is still being created.
                // Check the current provisioning state. Report to user if it's still in progress, and attempt to recreate if not.
                Storage.ProvisioningState? azureOperation;
                try
                {
                    azureOperation = manager.Storage.Value.GetCreateOperationStatus(tenantStorageAccount);
                }
                catch (Exception ex)
                {
                    azureOperation = null;

                    var msg = string.Format(
                        CultureInfo.InvariantCulture,
                        "Unable to validate the operation status for the storage account {0} for the tenant {1} with subscription {2}",
                        tenantStorageAccount,
                        tenantRegistration.TenantId.ToString(),
                        azureSubscriptionId.ToString());
                    Tracer.WriteWarningEvent(TraceComponent.DeploymentServiceApi, ex, msg);
                }

                if (azureOperation != null && !string.Equals(azureOperation, Storage.ProvisioningState.Succeeded))
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "The tenant {0} with subscription '{1}' still has an ongoing operation for storage account '{2}' of type {3}. Current provisioning state: {4}",
                        tenantRegistration.TenantId.ToString(),
                        azureSubscriptionId.ToString(),
                        tenantStorageAccount,
                        storageAccountType.ToString(),
                        azureOperation.ToString());

                    errorMessage = this.CreateErrorResponse(errorCode);
                    return false;
                }
                else
                {
                    if (azureOperation == null)
                    {
                        Tracer.WriteExecutionEvent(
                            TraceComponent.DeploymentServiceApi,
                            "The tenant {0} with subscription '{1}' did not have storage account creation operation on storage account '{2}' of type {3}. Since we cannot find the storage account, we will re-create it nevertheless.",
                            tenantRegistration.TenantId.ToString(),
                            azureSubscriptionId.ToString(),
                            tenantStorageAccount,
                            storageAccountType.ToString());
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(
                            TraceComponent.DeploymentServiceApi,
                            "The tenant {0} with subscription '{1}' had an operation on storage account '{2}' of type {3} with current provisioning state: {4}. Since we cannot find the storage account, we will re-create it nevertheless.",
                            tenantRegistration.TenantId.ToString(),
                            azureSubscriptionId.ToString(),
                            tenantStorageAccount,
                            storageAccountType.ToString(),
                            azureOperation.ToString());
                    }

                    string azureOperationId;
                    string storageAccountName;

                    HttpResponseMessage errorResponse;

                    // Create resource group if it doesn't exist
                    manager.Resource.Value.Proxy.ResourceGroups.CreateOrUpdate(resourceGroup, new Azure.Management.ResourceManager.Models.ResourceGroup() { Location = targetLocation });

                    // Create storage account
                    if (this.CreateStorageAccount(
                        manager,
                        targetLocation,
                        tenantRegistration,
                        skuName,
                        out azureOperationId,
                        out storageAccountName,
                        out errorResponse))
                    {
                        tenantRegistration.SetStorageAccount(storageAccountType, AzureManagementAPIType.ARM, primaryLocation, storageAccountName, azureOperationId, disasteryRecoveryLocation);

                        Tracer.WriteExecutionEvent(
                            TraceComponent.DeploymentServiceApi,
                            "Requested for tenant {0} with subscription '{1}' the creation of a ARM storage account '{2}' of type {3} with operation ID: {4}. ",
                            tenantRegistration.TenantId.ToString(),
                            azureSubscriptionId.ToString(),
                            storageAccountName,
                            storageAccountType.ToString(),
                            azureOperationId);

                        TenantRegistrationDAC.UpsertTenantRegistration(tenantRegistration, decryptAfterUpsert: false);
                        errorMessage = this.CreateErrorResponse(errorCode);
                        return false;
                    }
                    else
                    {
                        errorMessage = errorResponse;
                        return false;
                    }
                }
            }
        }

        /// <summary>
        /// Helper function to validate the Storage Account is connectible.
        /// </summary>
        /// <param name="tenantStorageAccount">The name of the tenant storage account.</param>
        /// <param name="primaryStorageKey">The Primary Storage Account Key.</param>
        /// <param name="azureSubscriptionId">The Azure Subscription ID.</param>
        /// <param name="storageAccountType">The type of storage account.</param>
        /// <param name="isForbidden">Out variable to specify if there was a forbidden exception thrown.</param>
        /// <returns>Returns a bool of whether we could successfully connect to the storage account.</returns>
        private bool ValidateStorageAccountConnection(string tenantStorageAccount, string primaryStorageKey, Guid azureSubscriptionId, StorageAccountType storageAccountType, out bool isForbidden)
        {
            isForbidden = false;
            try
            {
                string connectionString = ConnectionStringManager.CreateStorageConnection(tenantStorageAccount, primaryStorageKey, AzureEnvironmentConfig.StorageEndpointSuffix).ToString();
                CloudStorageAccount account = CloudStorageAccount.Parse(connectionString);
                CloudBlobClient client = account.CreateCloudBlobClient();
                client.ListContainers().ToList();

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Validated that subscription '{0}' has storage account '{1}', type {2} and the storage account is accessible using the keys on file.",
                    azureSubscriptionId.ToString(),
                    tenantStorageAccount,
                    storageAccountType.ToString());
            }
            catch (StorageException ex)
            {
                if (ex.RequestInformation != null && ex.RequestInformation.HttpStatusCode == (int)HttpStatusCode.Forbidden)
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Could not access subscription '{0}', storage account '{1}' of type {2}. Exception: {3}",
                        azureSubscriptionId.ToString(),
                        tenantStorageAccount,
                        storageAccountType.ToString(),
                        ex.ToString());

                    isForbidden = true;
                }
                else
                {
                    throw;
                }
            }

            return true;
        }

        /// <summary>
        /// Validates if the data center (location) supports SQL Azure.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <returns>A value indicating whether or not deployment location supports SQL Azure.</returns>
        private bool ValidateSQLAzureAvailability(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            DeploymentItem sqlazureItem = entity.DeploymentItems.FirstOrDefault(di => di.IsItemType(DeploymentItemType.AzureSQLServer));
            if (sqlazureItem == null)
            {
                return true;
            }

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                "Validating the data center '{0}' supports SQL Azure",
                entity.CloudServiceLocation);

            // check the internal mappings allows for this data center.
            if (AzureSQLLocations.LookupLocation(entity.CloudServiceLocation) == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "SQL Azure is not supported in the data center '{0}'.", entity.CloudServiceLocation);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.AzureSQLLocationNotSupported, entity.CloudServiceLocation);
                return false;
            }

            return true;
        }

        /// <summary>
        /// Validates the DNS availability of the given topology.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="subscription">Azure subscription containing resourcing information.</param>
        /// <param name="azureProxy">Azure proxy.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        private bool ValidateDNSAvailability(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, AzureSubcription subscription, IServiceManagement azureProxy)
        {
            errorMessage = null;

            int neededDNS = entity.GetDNSCount();
            if (neededDNS == 0)
            {
                return true;
            }

            NetworkConfiguration networkConfiguration;
            if (!azureProxy.TryGetNetworkConfiguration(azureSubscriptionId, out networkConfiguration))
            {
                return true;
            }

            int currentDNSCount = 0;
            if (networkConfiguration != null &&
                networkConfiguration.VirtualNetworkConfiguration != null &&
                networkConfiguration.VirtualNetworkConfiguration.Dns != null &&
                networkConfiguration.VirtualNetworkConfiguration.Dns.DnsServers != null)
            {
                currentDNSCount = networkConfiguration.VirtualNetworkConfiguration.Dns.DnsServers.Count;
            }

            int remainingDNS = subscription.MaxDnsServers - currentDNSCount;

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                "Validating that subscription '{0}' has enough DNS. Current in use: '{1}' Max: '{2}' Needed: '{3}'",
                azureSubscriptionId,
                currentDNSCount,
                subscription.MaxDnsServers,
                neededDNS);
            if (remainingDNS < neededDNS)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough DNS.", azureSubscriptionId);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.LimitDNSServers, currentDNSCount, subscription.MaxDnsServers);
                return false;
            }

            return true;
        }

        /// <summary>
        /// Validates the location availability.
        /// </summary>
        /// <param name="tenantRegistration">The tenant registration.</param>
        /// <param name="entity">The entity.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>A boolean indicating if the location is available for the instances.</returns>
        private bool ValidateLocationAvailability(TenantRegistration tenantRegistration, TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            // Validate Power BI location availability. Set a customization value indicating the location, if available.
            // Do not fail the deployment for this.
            this.ValidatePowerBILocationAvailability(tenantRegistration, entity);

            errorMessage = null;

            return true;
        }

        /// <summary>
        /// Prepare the worklist for deployment.
        /// Sets Power BI Embedded location.
        /// </summary>
        /// <param name="tenantRegistration">The tenant registration.</param>
        /// <param name="entity">The entity.</param>
        private void ValidatePowerBILocationAvailability(TenantRegistration tenantRegistration, TopologyInstance entity)
        {
            string deploymentLocation = entity.CloudStorageLocation;

            string mappedLocation = AzureSQLLocations.GetMappedPowerBIEmbeddedLocation(deploymentLocation);

            if (!String.IsNullOrEmpty(mappedLocation))
            {
                Tracer.WriteExecutionEvent(TraceComponent.PowerBIEmbeddedProvisioning, "Deployment Location is {0}. Mapped Power BI Embedded Location is {1}", deploymentLocation, mappedLocation);
                foreach (DeploymentItem deploymentItem in entity.DeploymentItems.Where(di => di.IsItemType(DeploymentItemType.PowerBIEmbedded)))
                {
                    deploymentItem.SetCustomizationValue(CommonCustomizationNames.PowerBIEmbeddedLocation, mappedLocation, CustomizationValueType.String);
                }
            }
            else
            {
                Tracer.WriteErrorEvent(TraceComponent.PowerBIEmbeddedProvisioning, null, "Could not find a Mapped Power BI Embedded Location for Deployment Location {0}", deploymentLocation);
            }
        }

        /// <summary>
        /// Checks that the resource group doesn't exist in the subscription..
        /// </summary>
        /// <param name="tenantRegistration">Registration that corresponds to this tenant.</param>
        /// <param name="entity">The deployment request.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>Returns whether or not the resource group exists.</returns>
        private bool ValidateResourceGroupAvailability(TenantRegistration tenantRegistration, TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager(entity.ARM.ResourceGroupName))
            {
                ResourceGroup resourceGroup;

                if (manager.Resource.Value.TryGetResourceGroup(out resourceGroup))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription [{0}] already contains a resource group with name [{1}].", tenantRegistration.AzureSubscriptionId, resourceGroup.Name);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_DuplicateResourceGroupName, resourceGroup.Name);
                    return false;
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates the resource availability of the given topology.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="subscription">Azure subscription containing resourcing information.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="azureProxy">The azure proxy.</param>
        /// <returns>
        /// A value indicating whether or not there are sufficient resources to support the topology.
        /// </returns>
        private bool ValidateTopologyRDFEResourceAvailability(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, AzureSubcription subscription, List<TopologyInstance> ongoingTopologyInstances, IServiceManagement azureProxy)
        {
            errorMessage = null;

            if (!this.ValidateTopologyRDFEVirtualNetworkAvailability(azureSubscriptionId, entity, out errorMessage, subscription, ongoingTopologyInstances, azureProxy, entity.GetPendingNetworkCount()) ||
                !this.ValidateTopologyRDFEHostedServiceAvailability(azureSubscriptionId, entity, out errorMessage, subscription, ongoingTopologyInstances, azureProxy, entity.GetPendingCloudServiceCount()) ||
                !this.ValidateTopologyRDFEApplicationGatewayAvailability(azureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, azureProxy, entity.GetApplicationGatewayCount()))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Validates the resource availability of the given topology.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="subscription">Azure subscription containing resourcing information.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="azureProxy">The azure proxy.</param>
        /// <param name="newHostedServices">The number of new hosted services to deploy.</param>
        /// <returns>
        /// A value indicating whether or not there are sufficient resources to support the topology.
        /// </returns>
        private bool ValidateTopologyRDFEHostedServiceAvailability(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, AzureSubcription subscription, List<TopologyInstance> ongoingTopologyInstances, IServiceManagement azureProxy, int newHostedServices)
        {
            int ongoingHostedServices = ongoingTopologyInstances.Sum(i => i.GetPendingCloudServiceCount());
            int remainingHostedServices = subscription.MaxHostedServices - subscription.CurrentHostedServices - ongoingHostedServices;

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                    "Validating that subscription '{0}' has enough hosted services. Current in use: '{1}'. Ongoing deployments hosted service count: '{2}'.  Max: '{3}'. Needed: '{4}'",
                    azureSubscriptionId,
                    subscription.CurrentHostedServices,
                    ongoingHostedServices,
                    subscription.MaxHostedServices,
                    newHostedServices);

            if (remainingHostedServices < newHostedServices)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough hosted services.", azureSubscriptionId);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.LimitHostedServices, subscription.CurrentHostedServices, ongoingHostedServices, subscription.MaxHostedServices);
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates the resource availability of the given topology.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="subscription">Azure subscription containing resourcing information.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="azureProxy">The azure proxy.</param>
        /// <param name="newNetworkResources">The number of new VNETs to deploy.</param>
        /// <returns>
        /// A value indicating whether or not there are sufficient resources to support the topology.
        /// </returns>
        private bool ValidateTopologyRDFEVirtualNetworkAvailability(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, AzureSubcription subscription, List<TopologyInstance> ongoingTopologyInstances, IServiceManagement azureProxy, int newNetworkResources)
        {
            if (newNetworkResources > 0)
            {
                int ongoingNetworkResources = ongoingTopologyInstances.Sum(i => i.GetPendingNetworkCount());
                int remainingNetworkResources = subscription.MaxVirtualNetworkSites - subscription.CurrentVirtualNetworkSites - ongoingNetworkResources;

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Validating that subscription '{0}' has enough network sites. Current in use: '{1}' Ongoing deployments networks: '{2}' Max: '{3}'. Needed: '{4}'",
                    azureSubscriptionId,
                    subscription.CurrentVirtualNetworkSites,
                    ongoingNetworkResources,
                    subscription.MaxVirtualNetworkSites,
                    newNetworkResources);
                if (remainingNetworkResources < newNetworkResources)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough network sites.", azureSubscriptionId);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.LimitNetworkAccount, subscription.CurrentVirtualNetworkSites, ongoingNetworkResources, subscription.MaxVirtualNetworkSites);
                    return false;
                }
            }
            else
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Skipping network validation as topology doesn't require new network resources.");
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Returns Whether or not the subscription in combination with the region
        /// has sufficient space to host the topology.
        /// </summary>
        /// <param name="tenantRegistration">Registration that corresponds to this tenant.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="errorMessage">The error message for the request.</param>
        /// <returns>
        /// A value indicating whether or not there are sufficient resources to support the topology.
        /// </returns>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "The method is can throw a variety of exceptions from here which makes being precise difficult.")]
        private bool ValidateTopologyARMResourceAvailability(TenantRegistration tenantRegistration, TopologyInstance entity, List<TopologyInstance> ongoingTopologyInstances, out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager())
            {
                string region = TopologyInstanceExtensions.MapRDFEtoARMLocation(entity.CloudServiceLocation);

                IEnumerable<Microsoft.Azure.Management.Network.Models.Usage> networkUsage = null;

                try
                {
                    // This can thrown an Exception if the subscription has not deployed any ARM Elements.
                    networkUsage = manager.Network.Value.NetworkingUsage(region);
                }
                catch (CloudException ce)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' has thrown an CloudException while validating networking resources. Exception '{1}'", tenantRegistration.AzureSubscriptionId, ce);
                    return true;
                }
                catch (Exception e)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' has thrown an Exception while validating networking resources. Exception '{1}'", tenantRegistration.AzureSubscriptionId, e);
                    return false;
                }

                // Check Networking Quotas.
                if (!this.ValidateTopologyARMVirtualNetworkAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage, entity.GetPendingNetworkCount()) ||
                    !this.ValidateTopologyARMApplicationGatewayAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage, entity.GetApplicationGatewayCount()) ||
                    !this.ValidateTopologyARMNetworkInterfaceAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage, entity.GetNetworkInterfaceCount()) ||
                    !this.ValidateTopologyARMNetworkSecurityGroupAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage, entity.GetNetworkSecurityGroupCount()) ||
                    !this.ValidateTopologyARMDynamicPublicIPAddressAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage) ||
                    !this.ValidateTopologyARMStaticPublicIPAddressAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage) ||
                    !this.ValidateTopologyARMLoadBalancerAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage, entity.GetLoadBalancers()) ||
                    !this.ValidateTopologyARMStorageAccountAvailability(manager, entity, out errorMessage))
                {
                    return false;
                }

                return true;
            }
        }

        /// <summary>
        /// Validates the topology application gateway availability.
        /// </summary>
        /// <param name="azureSubscriptionId">The azure subscription identifier.</param>
        /// <param name="entity">The entity.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <param name="ongoingTopologyInstances">The ongoing topology instances.</param>
        /// <param name="azureProxy">The azure proxy.</param>
        /// <param name="neededAGs">The number of application gateways needed for this deployment.</param>
        /// <returns>
        /// A value indicating whether or not there are sufficient resources to support the topology.
        /// </returns>
        private bool ValidateTopologyRDFEApplicationGatewayAvailability(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, List<TopologyInstance> ongoingTopologyInstances, IServiceManagement azureProxy, int neededAGs)
        {
            int ongoingCount = ongoingTopologyInstances.Sum(d => d.GetApplicationGatewayCount());
            if (neededAGs <= 0)
            {
                errorMessage = null;
                return true;
            }

            int currentInUse = azureProxy.ListApplicationGateway(azureSubscriptionId.ToString()).Count;
            var remaining = DeploymentServiceConfig.MaxApplicationGatewayCountPerSubscription - currentInUse - ongoingCount;

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                     "Validating that subscription '{0}' has enough application gateway. Current in use: {1} Ongoing deployments count: {2}  Max: {3}. Needed: {4}",
                    azureSubscriptionId,
                    currentInUse,
                    ongoingCount,
                    DeploymentServiceConfig.MaxApplicationGatewayCountPerSubscription,
                    neededAGs);
            if (remaining < neededAGs)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' has reached maximum application gateway resources.", azureSubscriptionId);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ApplicationGatewayMaxLimitReached, currentInUse, ongoingCount, DeploymentServiceConfig.MaxApplicationGatewayCountPerSubscription, neededAGs);
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates the cores availability by VM family.
        /// </summary>
        /// <param name="tenantRegistration">TenantRegistration object that contains info to interact with Azure.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="computeUsage">Current subscription/region list of compute usage.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <returns>Returns a boolean of whether the Subscription has enough CPU Cores.</returns>
        private bool ValidateTopologyCoresAvailabilityByFamily(TenantRegistration tenantRegistration, TopologyInstance entity, List<TopologyInstance> ongoingTopologyInstances, IEnumerable<ComputeUsage> computeUsage, out HttpResponseMessage errorMessage)
        {
            // Get usage by VM SKU family, for the current topology
            List<ComputeUsage> coresRequiredByFamily = new List<ComputeUsage>();
            entity.GetRequiredCoresByFamily(computeUsage, coresRequiredByFamily);

            // Get usage by VM SKU family for ongoing topologies.
            // ongoingTopologyInstances is already filtered for the targeted data center
            List<ComputeUsage> coresOngoingByFamily = new List<ComputeUsage>();
            foreach (TopologyInstance topology in ongoingTopologyInstances)
            {
                // coresOngoingByFamily is updated with the consumption for each topology
                topology.GetRequiredCoresByFamily(computeUsage, coresOngoingByFamily);
            }

            // validate we have available cores for all VM SKUs utilized by the current topology
            foreach (ComputeUsage usageFamily in coresRequiredByFamily)
            {
                ComputeUsage ongoingCores = coresOngoingByFamily.FirstOrDefault(cu => cu.Name != null && usageFamily.Name != null && string.Equals(cu.Name.Value, usageFamily.Name.Value, StringComparison.OrdinalIgnoreCase));
                ComputeUsage subscriptionCores = computeUsage.FirstOrDefault(cu => cu.Name != null && usageFamily.Name != null && string.Equals(cu.Name.Value, usageFamily.Name.Value, StringComparison.OrdinalIgnoreCase));
                if (subscriptionCores == null)
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Cannot validate cores usage by family in subscription id [{0}], the subscription usage for VM Family [{1}] does not exist.",
                        tenantRegistration.AzureSubscriptionId,
                        usageFamily.Name.LocalizedValue);

                    continue;
                }

                long totalcoresNeededByFamily = usageFamily.CurrentValue + (ongoingCores != null ? ongoingCores.CurrentValue : 0);
                Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Validating that subscription [{0}] has enough cores for VM family [{1}]. Ongoing deployments cores [{2}], current deployment cores needed [{3}]. Subscription current use [{4}], limit [{5}]. Total cores consumed by deployments [{6}]",
                        tenantRegistration.AzureSubscriptionId,
                        usageFamily.Name.LocalizedValue,
                        ongoingCores != null ? ongoingCores.CurrentValue : 0,
                        usageFamily.CurrentValue,
                        subscriptionCores.CurrentValue,
                        subscriptionCores.Limit,
                        totalcoresNeededByFamily);

                if (subscriptionCores.Limit < totalcoresNeededByFamily + subscriptionCores.CurrentValue)
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Subscription [{0}] does not have enough cores for VM family [{1}], additional cores needed [{2}] (double counting might apply).",
                        tenantRegistration.AzureSubscriptionId,
                        usageFamily.Name.LocalizedValue,
                        totalcoresNeededByFamily + subscriptionCores.CurrentValue - subscriptionCores.Limit);

                    // if we have negative core count, it is because we double-counted above. normalize to 0 for customer experience.
                    long remainingCores = subscriptionCores.Limit - subscriptionCores.CurrentValue - (ongoingCores != null ? ongoingCores.CurrentValue : 0);
                    remainingCores = (remainingCores < 0) ? 0 : remainingCores;

                    errorMessage = this.CreateErrorResponse(
                        ServiceErrorCode.ARMLimitCoresByFamily,
                        usageFamily.Name.LocalizedValue,
                        subscriptionCores.Limit,
                        remainingCores,
                        usageFamily.CurrentValue,
                        usageFamily.CurrentValue - remainingCores);
                    return false;
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates the cores availability of the given topology.
        /// </summary>
        /// <param name="tenantRegistration">TenantRegistration object that contains info to interact with Azure.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="neededCores">The number of cores needed for this deployment.</param>
        /// <param name="action">Optional action from where being called.</param>
        /// <returns>Returns a boolean of whether the Subscription has enough CPU Cores.</returns>
        private bool ValidateTopologyCoresAvailability(TenantRegistration tenantRegistration, TopologyInstance entity, List<TopologyInstance> ongoingTopologyInstances, out HttpResponseMessage errorMessage, int neededCores, DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.Undefined)
        {
            if (entity.ShouldUseAzureResourceManager())
            {
                using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager())
                {
                    // before going into core size calculations, verify if deploying the selected sizes is possible in the current subscription.
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                            "Validating VM SKUs are available in subscription [{0}] for topology instance [{1}]",
                            tenantRegistration.AzureSubscriptionId,
                            entity.InstanceId);

                    IEnumerable<ResourceSku> vmresourceSKUsUnavailable = entity.ValidateVMResourceSKUAvailability(manager);
                    if (vmresourceSKUsUnavailable != null && vmresourceSKUsUnavailable.Count() > 0)
                    {
                        string restrictedSKUs = string.Join(";", vmresourceSKUsUnavailable.Where(sku => sku != null && sku.Name != null).Select(sku => sku.Name));
                        string restrictedCodes = string.Join(";", vmresourceSKUsUnavailable.Where(sku => sku != null && sku.Restrictions != null && sku.Restrictions.Count > 0).SelectMany(sku => sku.Restrictions.Where(r => r.ReasonCode != null).Select(r => r.ReasonCode.ToString())));

                        Tracer.WriteExecutionEvent(
                            TraceComponent.DeploymentServiceApi,
                                "Subscription [{0}] restricts deployments of VM SKUs [{1}], due to codes [{2}], in topology instance [{3}].",
                                tenantRegistration.AzureSubscriptionId,
                                restrictedSKUs,
                                restrictedCodes,
                                entity.InstanceId);

                        errorMessage = this.CreateErrorResponse(
                            ServiceErrorCode.VMSkuNotAvailable,
                            tenantRegistration.AzureSubscriptionId.ToString(),
                            restrictedSKUs,
                            restrictedCodes);

                        return false;
                    }

                    IEnumerable<ComputeUsage> computeUsage = manager.Compute.Value.ComputeUsage(TopologyInstanceExtensions.MapRDFEtoARMLocation(entity.CloudServiceLocation));
                    ComputeUsage coreUsage = computeUsage.FirstOrDefault(c => string.Equals(c.Name.Value, CoreUsageName, StringComparison.OrdinalIgnoreCase));

                    // If the Subscription has not ever been used to deploy ARM elements the coreUsage field
                    // does not exist. We will assume the resources exist for the first deployment.
                    if (coreUsage == null)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to query the Subscription '{0}' for the Core quota.", tenantRegistration.AzureSubscriptionId);
                        errorMessage = null;
                        return true;
                    }

                    // restrict to ARM deployments in the same region
                    ongoingTopologyInstances = ongoingTopologyInstances.Where(d => d.ShouldUseAzureResourceManager() && string.Equals(d.CloudServiceLocation, entity.CloudServiceLocation, StringComparison.OrdinalIgnoreCase)).ToList();
                    int ongoingCoreCount = ongoingTopologyInstances.Sum(d => d.GetCoreCount());
                    long remainingCores = coreUsage.Limit - coreUsage.CurrentValue - ongoingCoreCount;

                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                            "Validating that subscription '{0}' has enough cores. Current in use: {1} Ongoing deployments core count: {2}  Max: {3}. Needed: {4}",
                            tenantRegistration.AzureSubscriptionId,
                            coreUsage.CurrentValue,
                            ongoingCoreCount,
                            coreUsage.Limit,
                            neededCores);

                    var coresBufferValidationAmountPercent = DeploymentServiceConfig.QuotaValidationBuffer;
                    if (action == DeploymentRequest.DeploymentAction.Deploy && entity.IsMSManaged() && coresBufferValidationAmountPercent > 0)
                    {
                        var neededCoresWithAddedBufferCores = Math.Round(neededCores + (neededCores * coresBufferValidationAmountPercent / 100));
                        if (remainingCores <= neededCoresWithAddedBufferCores)
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough cores.", tenantRegistration.AzureSubscriptionId);

                            // if we have negative core count, it is because we double-counted above. normalize to 0 for customer experience.
                            remainingCores = (remainingCores < 0) ? 0 : remainingCores;

                            errorMessage = this.CreateErrorResponse(
                                ServiceErrorCode.ARMLimitCores,
                                coreUsage.Limit,
                                remainingCores,
                                neededCores,
                                neededCoresWithAddedBufferCores - remainingCores);
                            return false;
                        }
                    }
                    else if (remainingCores < neededCores)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough cores.", tenantRegistration.AzureSubscriptionId);

                        // if we have negative core count, it is because we double-counted above. normalize to 0 for customer experience.
                        remainingCores = (remainingCores < 0) ? 0 : remainingCores;

                        errorMessage = this.CreateErrorResponse(
                            ServiceErrorCode.ARMLimitCores,
                            coreUsage.Limit,
                            remainingCores,
                            neededCores,
                            neededCores - remainingCores);
                        return false;
                    }

                    // Validate usage by VM SKU family, for the current topology
                    if (!this.ValidateTopologyCoresAvailabilityByFamily(tenantRegistration, entity, ongoingTopologyInstances, computeUsage, out errorMessage))
                    {
                        return false;
                    }
                }
            }
            else
            {
                var proxy = tenantRegistration.CreateAzureServiceManagement();
                var subscription = proxy.GetAzureSubscription(tenantRegistration.AzureSubscriptionId);

                int ongoingCoreCount = ongoingTopologyInstances.Where(d => !d.ShouldUseAzureResourceManager()).Sum(d => d.GetCoreCount());
                var remainingCores = subscription.MaxCoreCount - subscription.CurrentCoreCount - ongoingCoreCount;
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                        "Validating that subscription '{0}' has enough cores. Current in use: {1} Ongoing deployments core count: {2}  Max: {3}. Needed: {4}",
                        tenantRegistration.AzureSubscriptionId,
                        subscription.CurrentCoreCount,
                        ongoingCoreCount,
                        subscription.MaxCoreCount,
                        neededCores);
                if (remainingCores < neededCores)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough cores.", tenantRegistration.AzureSubscriptionId);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.LimitCores, subscription.CurrentCoreCount, ongoingCoreCount, subscription.MaxCoreCount, neededCores);
                    return false;
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates the ARM Virtual Network availability of the given topology.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="networkUsage">The IEnumerable object that contains the Network Usage information for the subscription.</param>
        /// <param name="neededVnets">The amount of VNETs needed for this deployment.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        private bool ValidateTopologyARMVirtualNetworkAvailability(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, List<TopologyInstance> ongoingTopologyInstances, IEnumerable<Microsoft.Azure.Management.Network.Models.Usage> networkUsage, int neededVnets)
        {
            var virtualNetworks = networkUsage.FirstOrDefault(n => string.Equals(n.Name.Value, VNETUsageName, StringComparison.OrdinalIgnoreCase));

            // If the Subscription has not ever been used to deploy ARM elements the VNETUsageName field
            // does not exist. We will assume the resources exist for the first deployment.
            if (virtualNetworks == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to query the Subscription '{0}' for the Virtual Networking quota.", azureSubscriptionId);
                errorMessage = null;
                return true;
            }

            int ongoingVnetCount = ongoingTopologyInstances.Where(d => string.Equals(d.CloudServiceLocation, entity.CloudServiceLocation, StringComparison.OrdinalIgnoreCase)).Sum(d => d.GetPendingNetworkCount());
            long vnetLimit = 0;
            long vnetCurrentCount = 0;
            if (virtualNetworks != null)
            {
                vnetLimit = virtualNetworks.Limit;
                vnetCurrentCount = virtualNetworks.CurrentValue;
            }

            long remainingVnets = vnetLimit - vnetCurrentCount - ongoingVnetCount;

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                    "Validating that subscription '{0}' has enough Virtual Networks. Current in use: {1} Ongoing deployments VNET count: {2}  Max: {3}. Needed: {4}",
                    azureSubscriptionId,
                    vnetCurrentCount,
                    ongoingVnetCount,
                    vnetLimit,
                    neededVnets);
            if (remainingVnets < neededVnets)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough Virtual Networks.", azureSubscriptionId);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ARMLimitNetworkAccount, vnetCurrentCount, ongoingVnetCount, vnetLimit, neededVnets);
                return false;
            }

            errorMessage = null;

            return true;
        }

        /// <summary>
        /// Validates the ARM Application Gateway availability of the given topology.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="networkUsage">The IEnumerable object that contains the Network Usage information for the subscription.</param>
        /// <param name="neededAppGates">The number of needed application gateways.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        private bool ValidateTopologyARMApplicationGatewayAvailability(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, List<TopologyInstance> ongoingTopologyInstances, IEnumerable<Microsoft.Azure.Management.Network.Models.Usage> networkUsage, int neededAppGates)
        {
            var appGateway = networkUsage.FirstOrDefault(n => string.Equals(n.Name.Value, AppGateUsageName, StringComparison.OrdinalIgnoreCase));

            // If the Subscription has not ever been used to deploy ARM elements the AppGateUsageName field
            // does not exist. We will assume the resources exist for the first deployment.
            if (appGateway == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to query the Subscription '{0}' for the Application Gateway quota.", azureSubscriptionId);
                errorMessage = null;
                return true;
            }

            int ongoingAGCount = ongoingTopologyInstances.Where(d => string.Equals(d.CloudServiceLocation, entity.CloudServiceLocation, StringComparison.OrdinalIgnoreCase)).Sum(d => d.GetApplicationGatewayCount());
            long appGateLimit = 0;
            long appGateCurrentCount = 0;
            if (appGateway != null)
            {
                appGateLimit = appGateway.Limit;
                appGateCurrentCount = appGateway.CurrentValue;
            }

            long remainingAppGateways = appGateLimit - appGateCurrentCount - ongoingAGCount;

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                    "Validating that subscription '{0}' has enough Application Gateways. Current in use: {1} Ongoing deployments Application Gateway count: {2}  Max: {3}. Needed: {4}",
                    azureSubscriptionId,
                    appGateCurrentCount,
                    ongoingAGCount,
                    appGateLimit,
                    neededAppGates);
            if (remainingAppGateways < neededAppGates)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough space for an Application Gateway.", azureSubscriptionId);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ARMApplicationGatewayMaxLimitReached, appGateCurrentCount, ongoingAGCount, appGateLimit, neededAppGates);
                return false;
            }

            errorMessage = null;

            return true;
        }

        /// <summary>
        /// Validates the ARM Network Interfaces availability of the given topology.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="networkUsage">The IEnumerable object that contains the Network Usage information for the subscription.</param>
        /// <param name="neededNics">The number of NICs to be deployed.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        private bool ValidateTopologyARMNetworkInterfaceAvailability(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, List<TopologyInstance> ongoingTopologyInstances, IEnumerable<Microsoft.Azure.Management.Network.Models.Usage> networkUsage, int neededNics)
        {
            var nicUsage = networkUsage.FirstOrDefault(n => string.Equals(n.Name.Value, NICUsageName, StringComparison.OrdinalIgnoreCase));

            // If the Subscription has not ever been used to deploy ARM elements the NICUsageName field
            // does not exist. We will assume the resources exist for the first deployment.
            if (nicUsage == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to query the Subscription '{0}' for the Network Interface quota.", azureSubscriptionId);
                errorMessage = null;
                return true;
            }

            int ongoingNICCount = ongoingTopologyInstances.Where(d => string.Equals(d.CloudServiceLocation, entity.CloudServiceLocation, StringComparison.OrdinalIgnoreCase)).Sum(d => d.GetNetworkInterfaceCount());
            long nicLimit = 0;
            long nicCurrentCount = 0;
            if (nicUsage != null)
            {
                nicLimit = nicUsage.Limit;
                nicCurrentCount = nicUsage.CurrentValue;
            }

            long remainingNICs = nicLimit - nicCurrentCount - ongoingNICCount;

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                    "Validating that subscription '{0}' has enough room for {4} Network Interfaces. Currently in use: {1} Ongoing deployments Network Interfaces count: {2}  Max: {3}.",
                    azureSubscriptionId,
                    nicCurrentCount,
                    ongoingNICCount,
                    nicLimit,
                    neededNics);
            if (remainingNICs < neededNics)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough space for {1} Network Interfaces.", azureSubscriptionId, neededNics);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ARMNetworkInterfaceMaxLimitReached, nicCurrentCount, ongoingNICCount, nicLimit, neededNics);
                return false;
            }

            errorMessage = null;

            return true;
        }

        /// <summary>
        /// Validates the ARM Network Security Group availability of the given topology.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="networkUsage">The IEnumerable object that contains the Network Usage information for the subscription.</param>
        /// <param name="neededNSGs">The number of needed network security groups for this deployment.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        private bool ValidateTopologyARMNetworkSecurityGroupAvailability(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, List<TopologyInstance> ongoingTopologyInstances, IEnumerable<Microsoft.Azure.Management.Network.Models.Usage> networkUsage, int neededNSGs)
        {
            var nsgUsage = networkUsage.FirstOrDefault(n => string.Equals(n.Name.Value, NSGUsageName, StringComparison.OrdinalIgnoreCase));

            // If the Subscription has not ever been used to deploy ARM elements the NSGUsageName field
            // does not exist. We will assume the resources exist for the first deployment.
            if (nsgUsage == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to query the Subscription '{0}' for the Network Security Group quota.", azureSubscriptionId);
                errorMessage = null;
                return true;
            }

            int ongoingNSGCount = ongoingTopologyInstances.Where(d => string.Equals(d.CloudServiceLocation, entity.CloudServiceLocation, StringComparison.OrdinalIgnoreCase)).Sum(d => d.GetNetworkSecurityGroupCount());
            long nsgLimit = 0;
            long nsgCurrentCount = 0;
            if (nsgUsage != null)
            {
                nsgLimit = nsgUsage.Limit;
                nsgCurrentCount = nsgUsage.CurrentValue;
            }

            long remainingNSGs = nsgLimit - nsgCurrentCount - ongoingNSGCount;

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                    "Validating that subscription '{0}' has enough room for {4} Network Security Groups. Currently in use: {1} Ongoing deployments Network Security Groups count: {2}  Max: {3}.",
                    azureSubscriptionId,
                    nsgCurrentCount,
                    ongoingNSGCount,
                    nsgLimit,
                    neededNSGs);
            if (remainingNSGs < neededNSGs)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough space for {1} Network Security Groups.", azureSubscriptionId, neededNSGs);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ARMNetworkSecurityGroupMaxLimitReached, nsgCurrentCount, ongoingNSGCount, nsgLimit, neededNSGs);
                return false;
            }

            errorMessage = null;

            return true;
        }

        /// <summary>
        /// Validates the ARM Static Public IP Address availability of the given topology.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="networkUsage">The IEnumerable object that contains the Network Usage information for the subscription.</param>
        /// <param name="isDisasterRecovery">Whether the calculation is for a disaster recovery environment.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        private bool ValidateTopologyARMDynamicPublicIPAddressAvailability(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, List<TopologyInstance> ongoingTopologyInstances, IEnumerable<Microsoft.Azure.Management.Network.Models.Usage> networkUsage, bool isDisasterRecovery = false)
        {
            int neededDynamicPublicIPs = entity.GetNeededDynamicPublicIPAddresses(isDisasterRecovery: isDisasterRecovery);
            var publicIPUsage = networkUsage.FirstOrDefault(n => string.Equals(n.Name.Value, DynamicPublicIPUsageName, StringComparison.OrdinalIgnoreCase));

            // If the Subscription has not ever been used to deploy ARM elements the PublicIPUsageName field
            // does not exist. We will assume the resources exist for the first deployment.
            if (publicIPUsage == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to query the Subscription '{0}' for the Dynamic Public IP quota.", azureSubscriptionId);
                errorMessage = null;
                return true;
            }

            int ongoingPublicIPCount = ongoingTopologyInstances.Where(d => string.Equals(d.CloudServiceLocation, entity.CloudServiceLocation, StringComparison.OrdinalIgnoreCase)).Sum(d => d.GetNeededDynamicPublicIPAddresses());
            long publicIPLimit = 0;
            long publicIPCurrentCount = 0;
            if (publicIPUsage != null)
            {
                publicIPLimit = publicIPUsage.Limit;
                publicIPCurrentCount = publicIPUsage.CurrentValue;
            }

            long remainingPublicIPs = publicIPLimit - publicIPCurrentCount - ongoingPublicIPCount;

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                    "Validating that subscription '{0}' has enough room for {4} Dynamic Public IP Addresses. Currently in use: {1} Ongoing deployments Dynamic Public IP Addresses count: {2}  Max: {3}.",
                    azureSubscriptionId,
                    publicIPCurrentCount,
                    ongoingPublicIPCount,
                    publicIPLimit,
                    neededDynamicPublicIPs);
            if (remainingPublicIPs < neededDynamicPublicIPs)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough space for {1} Dynamic Public IP Addresses.", azureSubscriptionId, neededDynamicPublicIPs);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ARMDynamicPublicIPMaxLimitReached, publicIPCurrentCount, ongoingPublicIPCount, publicIPLimit, neededDynamicPublicIPs);
                return false;
            }

            errorMessage = null;

            return true;
        }

        /// <summary>
        /// Validates the ARM Static Public IP Address availability of the given topology.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="networkUsage">The IEnumerable object that contains the Network Usage information for the subscription.</param>
        /// <param name="isFailover">Whether the calculation is for a failover operation.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        private bool ValidateTopologyARMStaticPublicIPAddressAvailability(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, List<TopologyInstance> ongoingTopologyInstances, IEnumerable<Microsoft.Azure.Management.Network.Models.Usage> networkUsage, bool isFailover = false)
        {
            int neededStaticPublicIPs = entity.GetTotalStaticPublicIPAddresses(isFailover);

            var staticPublicIPUsage = networkUsage.FirstOrDefault(n => string.Equals(n.Name.Value, StaticPublicIPUsageName, StringComparison.OrdinalIgnoreCase));

            // If the Subscription has not ever been used to deploy ARM elements the PublicIPUsageName field
            // does not exist. We will assume the resources exist for the first deployment.
            if (staticPublicIPUsage == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to query the Subscription '{0}' for the Static Public IP quota.", azureSubscriptionId);
                errorMessage = null;
                return true;
            }

            // Cannot tell if ongoing deployments are a normal deploy or a failover. Assume most common and worst case scenario, which is normal deployment.
            int ongoingStaticPublicIPCount = ongoingTopologyInstances.Where(d => string.Equals(d.CloudServiceLocation, entity.CloudServiceLocation, StringComparison.OrdinalIgnoreCase)).Sum(d => d.GetTotalStaticPublicIPAddresses(isFailover: false));
            long staticPublicIPLimit = 0;
            long staticPublicIPCurrentCount = 0;
            if (staticPublicIPUsage != null)
            {
                staticPublicIPLimit = staticPublicIPUsage.Limit;
                staticPublicIPCurrentCount = staticPublicIPUsage.CurrentValue;
            }

            long remainingStaticPublicIPs = staticPublicIPLimit - staticPublicIPCurrentCount - ongoingStaticPublicIPCount;

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                    "Validating that subscription '{0}' has enough room for {4} Static Public IP Addresses. Currently in use: {1} Ongoing deployments Static Public IP Addresses count: {2}  Max: {3}.",
                    azureSubscriptionId,
                    staticPublicIPCurrentCount,
                    ongoingStaticPublicIPCount,
                    staticPublicIPLimit,
                    neededStaticPublicIPs);
            if (remainingStaticPublicIPs < neededStaticPublicIPs)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough space for {1} Static Public IP Addresses.", azureSubscriptionId, neededStaticPublicIPs);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ARMPublicIPMaxLimitReached, staticPublicIPCurrentCount, ongoingStaticPublicIPCount, staticPublicIPLimit, neededStaticPublicIPs);
                return false;
            }

            errorMessage = null;

            return true;
        }

        /// <summary>
        /// Validates the ARM Load Balancer availability of the given topology.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="networkUsage">The IEnumerable object that contains the Network Usage information for the subscription.</param>
        /// <param name="neededLoadBalancers">The number of load balancers to deploy.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        private bool ValidateTopologyARMLoadBalancerAvailability(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, List<TopologyInstance> ongoingTopologyInstances, IEnumerable<Microsoft.Azure.Management.Network.Models.Usage> networkUsage, int neededLoadBalancers)
        {
            var loadBalancerUsage = networkUsage.FirstOrDefault(n => string.Equals(n.Name.Value, LBUsageName, StringComparison.OrdinalIgnoreCase));

            // If the Subscription has not ever been used to deploy ARM elements the LBUsageName field
            // does not exist. We will assume the resources exist for the first deployment.
            if (loadBalancerUsage == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to query the Subscription '{0}' for the Load Balancer quota.", azureSubscriptionId);
                errorMessage = null;
                return true;
            }

            int ongoingLoadBalancerCount = ongoingTopologyInstances.Where(d => string.Equals(d.CloudServiceLocation, entity.CloudServiceLocation, StringComparison.OrdinalIgnoreCase)).Sum(d => d.GetLoadBalancers());
            long loadBalancerLimit = 0;
            long loadBalancerCurrentCount = 0;
            if (loadBalancerUsage != null)
            {
                loadBalancerLimit = loadBalancerUsage.Limit;
                loadBalancerCurrentCount = loadBalancerUsage.CurrentValue;
            }

            long remainingLoadBalancers = loadBalancerLimit - loadBalancerCurrentCount - ongoingLoadBalancerCount;

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                    "Validating that subscription '{0}' has enough room for {4} Load Balancers. Currently in use: {1} Ongoing deployments Load Balancers count: {2}  Max: {3}.",
                    azureSubscriptionId,
                    loadBalancerCurrentCount,
                    ongoingLoadBalancerCount,
                    loadBalancerLimit,
                    neededLoadBalancers);
            if (remainingLoadBalancers < neededLoadBalancers)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough space for {1} Load Balancers.", azureSubscriptionId, neededLoadBalancers);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ARMLoadBalancerMaxLimitReached, loadBalancerCurrentCount, ongoingLoadBalancerCount, loadBalancerLimit, neededLoadBalancers);
                return false;
            }

            errorMessage = null;

            return true;
        }

        /// <summary>
        /// Validates the ARM Storage Accounts availability of the given topology.
        /// </summary>
        /// <param name="manager">The Azure resource manager for the subscription.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        private bool ValidateTopologyARMStorageAccountAvailability(AzureResourceManager manager, TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            var neededStorageAccounts = 0;

            //// Note: There are currently no storage accounts needed after Cortana Analytics removal. Keeping the code for future usage.

            if (neededStorageAccounts > 0)
            {
                var usage = manager.Storage.Value.GetUsage(TopologyInstanceExtensions.MapRDFEtoARMLocation(entity.CloudServiceLocation));

                var availableStorageAccounts = usage.Limit - usage.CurrentValue;
                if (neededStorageAccounts > availableStorageAccounts)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough space for {1} Storage Accounts.", manager.AzureSubscriptionId, neededStorageAccounts);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.StorageAccountLimit);
                    return false;
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates if sufficient cores are available to add and delete instances.
        /// </summary>
        /// <param name="azureSubscriptionId">The azure subscription id.</param>
        /// <param name="entity">The TopologyInstance.</param>
        /// <param name="errorMessage">Error messages, if any.</param>
        /// <param name="subscription">The Azure subscription.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        private bool ValidateTopologyRDFECoresAvailabilityForUpdate(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, AzureSubcription subscription, List<TopologyInstance> ongoingTopologyInstances)
        {
            int ongoingCoreCount = ongoingTopologyInstances.Sum(d => d.GetCoreCount());
            var remainingCores = subscription.MaxCoreCount - subscription.CurrentCoreCount - ongoingCoreCount;
            var coresNeededForNewInstances = this.GetCoreCountForUpdate(entity);
            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Cores required for new instances is {0}", coresNeededForNewInstances);
            var coresAvailableFromDeletedInstances = this.GetCoreCountFromDeletedInstances(entity);
            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Cores available from deleted instances is {0}", coresAvailableFromDeletedInstances);

            // update operation was requested by no new instances were added or no instances were marked for deletion.
            if (coresNeededForNewInstances == 0 &&
                coresAvailableFromDeletedInstances == 0)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "No update needed for current topology instance with id {0} as there are no new instances added and no instances are marked for deletion.", entity.InstanceId);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.UpdateNotRequired);
                return false;
            }

            var netNewCores = coresNeededForNewInstances - coresAvailableFromDeletedInstances;

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                    "Validating that subscription '{0}' has enough cores. Current in use: {1}. Ongoing deployments core count: {2}.  Max: {3}. Needed: {4}",
                    azureSubscriptionId,
                    subscription.CurrentCoreCount,
                    ongoingCoreCount,
                    subscription.MaxCoreCount,
                    netNewCores);

            if (remainingCores < netNewCores)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough cores.", azureSubscriptionId);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.LimitCores, subscription.CurrentCoreCount, ongoingCoreCount, subscription.MaxCoreCount, netNewCores);
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates the ARM cores availability of the given topology for an update.
        /// </summary>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology is deployed.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="manager">Resource manager.</param>
        /// <param name="coresNeededForNewInstances">The number of cores needed for this deployment.</param>
        /// <returns>A value indicating whether or not there are sufficient resources to support the topology.</returns>
        private bool ValidateTopologyARMCoresAvailabilityForUpdate(Guid azureSubscriptionId, TopologyInstance entity, out HttpResponseMessage errorMessage, List<TopologyInstance> ongoingTopologyInstances, AzureResourceManager manager, int coresNeededForNewInstances)
        {
            errorMessage = null;

            IEnumerable<ComputeUsage> computeUsage = manager.Compute.Value.ComputeUsage(TopologyInstanceExtensions.MapRDFEtoARMLocation(entity.CloudServiceLocation));
            ComputeUsage coreUsage = computeUsage.FirstOrDefault(c => string.Equals(c.Name.Value, CoreUsageName, StringComparison.OrdinalIgnoreCase));

            int ongoingCoreCount = ongoingTopologyInstances.Sum(d => d.GetCoreCount());
            var remainingCores = coreUsage.Limit - coreUsage.CurrentValue - ongoingCoreCount;

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                    "Validating that subscription '{0}' has enough cores. Current in use: {1}. Ongoing deployments core count: {2}.  Max: {3}. Needed: {4}",
                    azureSubscriptionId,
                    coreUsage.CurrentValue,
                    ongoingCoreCount,
                    coreUsage.Limit,
                    coresNeededForNewInstances);

            if (remainingCores < coresNeededForNewInstances)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' does not have enough cores.", azureSubscriptionId);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.LimitCores, coreUsage.CurrentValue, ongoingCoreCount, coreUsage.Limit, coresNeededForNewInstances);
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Calculates the number of cores required by new instances to be deployed during Update operation.
        /// </summary>
        /// <param name="entity">The topology instance that has information about the new instances to be deployed.</param>
        /// <returns>Count of cores that are required to deploy new instances.</returns>
        private int GetCoreCountForUpdate(TopologyInstance entity)
        {
            int retVal = 0;

            foreach (DeploymentItem di in entity.DeploymentItems)
            {
                // DR instances are added during Fail-over, exclude them when calculating necessary cores for update
                if (di.IsPrimary())
                {
                    int selectedValue = di.GetInstanceCount();
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Existing instances:{0}.Total instances(including new):{1} for deployment item {2}.", di.Instances.Count, selectedValue, di.ItemName);
                    int newInstances = selectedValue - di.Instances.Count;
                    retVal += di.RoleSizeToCoreCount() * newInstances;
                }
            }

            return retVal > 0 ? retVal : 0;
        }

        /// <summary>
        /// Calculates the cores that will be available from deleted instances.
        /// </summary>
        /// <param name="entity">The topology instance that has information about instances that should be deleted.</param>
        /// <returns>Count of cores that will be available from deleted instances.</returns>
        private int GetCoreCountFromDeletedInstances(TopologyInstance entity)
        {
            int retVal = 0;

            foreach (DeploymentItem di in entity.DeploymentItems)
            {
                // DR instances are deleted during DR cleanup flow
                if (di.IsPrimary())
                {
                    int deletedInstances = di.Instances.Count(instance => instance.Delete);
                    retVal += deletedInstances * di.RoleSizeToCoreCount();
                }
            }

            return retVal;
        }

        /// <summary>
        /// Get the time to perform the diagnostics data collection on an environment based on its region off-hours.
        /// </summary>
        /// <param name="entity">The topology instance that has information about the environment.</param>
        /// <returns>
        /// Data Collection Time in UTC.
        /// </returns>
        private DateTime GetDiagnosticsDataCollectionTime(TopologyInstance entity)
        {
            // Default trigger time to 00:00 UTC.
            DateTime triggerTime = DateTime.UtcNow.Date;

            RegionOffHoursInfo offHours = null;

            // Get the regional off-hours information for the environment location.
            if (!string.IsNullOrEmpty(entity.CloudServiceLocation))
            {
                offHours = GetRegionOffHours(entity.CloudServiceLocation);

                if (offHours.Name.Equals("Default", StringComparison.OrdinalIgnoreCase))
                {
                    // No off-hours defined for environment region.
                    Tracer.WriteWarningEvent(TraceComponent.DeploymentServiceApi, null, "No off-hours defined for environment region" + entity.CloudServiceLocation + ", using default off-hours.");
                }
            }
            else
            {
                offHours = GetDefaultRegionOffHours();

                // No environment region specified.
                Tracer.WriteWarningEvent(TraceComponent.DeploymentServiceApi, null, "No environment region specified for environment, using default off-hours.");
            }

            // Adjust trigger time by off-hours start time.
            triggerTime = triggerTime.Add(offHours.From);

            // Adjust trigger time by off-hours middle.
            TimeSpan offHoursDuration = offHours.To.Subtract(offHours.From);
            int offHoursMiddleOffsetMinutes = (int)Math.Floor(offHoursDuration.TotalMinutes / 2);
            triggerTime = triggerTime.AddMinutes(offHoursMiddleOffsetMinutes);

            // Get a random number seeded from environment name in upper case which is between zero and half the number of the off-hours minutes.
            int environmentHashCode = entity.TopologyId.ToUpperInvariant().GetHashCode();
            Random rand = new Random(environmentHashCode);
            int offsetMinutes = rand.Next(0, offHoursMiddleOffsetMinutes);

            // Collection runs on HA/PROD environments in the later half of the off-hour window whereas it runs in the first half on other environment types.
            string topologySkuType = null;
            if (entity.TryGetCustomizationValue(CommonCustomizationNames.LcsEnvironmentTag, out topologySkuType))
            {
                if (!string.IsNullOrEmpty(topologySkuType) && topologySkuType.Equals(OfferSKUType.prod.ToString(), StringComparison.OrdinalIgnoreCase))
                {
                    triggerTime = triggerTime.AddMinutes(offsetMinutes);
                }
                else
                {
                    triggerTime = triggerTime.AddMinutes(-1 * offsetMinutes);
                }
            }

            return triggerTime;
        }

        /// <summary>
        /// Processes all customizations in the object.
        /// </summary>
        /// <param name="entity">Target object.</param>
        /// <param name="action">Action of this deployment.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>
        /// Whether or not the customizations were processed successfully.
        /// </returns>
        private bool TryProcessCustomizations(TopologyInstance entity, DeploymentRequest.DeploymentAction action, out HttpResponseMessage errorMessage)
        {
            switch (action)
            {
                case DeploymentRequest.DeploymentAction.Undefined:
                case DeploymentRequest.DeploymentAction.Deploy:
                    Dictionary<string, List<Customization>> customizationDictionary = new Dictionary<string, List<Customization>>();
                    Dictionary<string, List<Credential>> credentialDictionary = new Dictionary<string, List<Credential>>();

                    DeploymentComponent lcsDiagnostics = entity.DeploymentComponents.FirstOrDefault(dc => string.Equals(dc.Identifier, DeploymentConstants.LCSDiagnosticsComponentName, StringComparison.OrdinalIgnoreCase));
                    if (lcsDiagnostics != null)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Adding trigger time value to the customization for diagnostics deployment component");
                        DateTime triggertime = this.GetDiagnosticsDataCollectionTime(entity);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The Calculated Trigger Time is [{0}]", triggertime.ToString());
                        foreach (Customization customization1 in entity.Customizations)
                        {
                            if (string.Equals(customization1.FieldName, CommonCustomizationNames.LcsTriggerTime))
                            {
                                customization1.SelectedValue = triggertime.ToString("HH:mm", CultureInfo.InvariantCulture);
                                break;
                            }
                        }
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "No component found with symbolic name [{0}] for LCS diagnostics.", DeploymentConstants.LCSDiagnosticsComponentName);
                    }

                    // Add the customizations and credentials to a dictionary for later processing
                    this.PopulateCustomizationAndCredentialDictionaries(entity, customizationDictionary, credentialDictionary);

                    // process the entity level customization groups
                    if (entity.CustomizationGroups != null)
                    {
                        foreach (CustomizationGroup customizationGroup in entity.CustomizationGroups)
                        {
                            if (!this.TryProcessEntityCustomizationGroups(customizationGroup, customizationDictionary, credentialDictionary, out errorMessage))
                            {
                                return false;
                            }
                        }
                    }

                    foreach (DeploymentItem di in entity.DeploymentItems)
                    {
                        // process the deployment item level customization groups
                        if (di.CustomizationGroups != null)
                        {
                            foreach (CustomizationGroup customizationGroup in di.CustomizationGroups)
                            {
                                this.ProcessDeploymentItemCustomizationGroups(di, customizationGroup);
                            }
                        }
                    }

                    this.SetCustomizationValues(entity);
                    if (!this.TryProcessTargetItemCustomizations(entity, out errorMessage))
                    {
                        return false;
                    }

                    if (!this.ProcessSQLDatabaseCollation(entity, out errorMessage))
                    {
                        return false;
                    }

                    if (!this.ProcessSQLDatabaseShortTermBackupRetention(entity, out errorMessage))
                    {
                        return false;
                    }

                    if (!this.TrySetCdsEnvironmentDefaultValues(entity, out errorMessage))
                    {
                        return false;
                    }

                    break;

                case DeploymentRequest.DeploymentAction.Update:
                    // Do not mess with load balancing on update scenarios.
                    // Set the VM count we currently have deployed, before the update.
                    foreach (DeploymentItem di in entity.DeploymentItems)
                    {
                        bool value;
                        if (di.TryGetCustomizationValue(CommonCustomizationNames.LoadBalancerEnabled, out value))
                        {
                            di.SetCustomizationValue(CommonCustomizationNames.LoadBalancerEnabled, false);
                        }

                        if (di.IsVmBased())
                        {
                            di.SetCustomizationValue(CommonCustomizationNames.PreviousInstanceCount, di.Instances == null ? 0 : di.Instances.Count);
                        }
                    }

                    break;
            }

            errorMessage = null;

            return true;
        }

        /// <summary>
        /// Tries the process target item customizations.
        /// </summary>
        /// <param name="entity">The topology entity.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>
        /// True if the process is completed successfully.
        /// </returns>
        private bool TryProcessTargetItemCustomizations(TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            if (entity.CustomizationGroups == null)
            {
                errorMessage = null;
                return true;
            }

            foreach (CustomizationGroup customizationGroup in entity.CustomizationGroups)
            {
                var targetItemGroups = customizationGroup.Groups.Where(g => g.Selected && !string.IsNullOrWhiteSpace(g.TargetItem));
                foreach (var group in targetItemGroups)
                {
                    var deploymentItem = entity.DeploymentItems.SingleOrDefault(i => String.Equals(group.TargetItem, i.ItemName));
                    if (deploymentItem == null)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "There is no deployment item {0} found in topology. The selected group with specified target item is invalid.", group.TargetItem);

                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_MissingDeploymentItem, group.TargetItem);
                        return false;
                    }

                    var selectedCustomizations = group.Customizations.Where(c => !string.IsNullOrWhiteSpace(c.SelectedValue));
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Setting the selected value of customizations [{0}] for target deployment item [{1}] as inherited from customization groups.", String.Join(";", selectedCustomizations.Select(c => c.FieldName)), deploymentItem.ItemName);
                    foreach (var selectedCustomization in selectedCustomizations)
                    {
                        deploymentItem.SetCustomizationValue(selectedCustomization.FieldName, selectedCustomization.SelectedValue);
                    }
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Adds the customizations and credentials in the topology instance to respective dictionaries.
        /// </summary>
        /// <param name="entity">The topology instance.</param>
        /// <param name="customizationDictionary">A dictionary that contains the customizations.</param>
        /// <param name="credentialDictionary">A dictionary that contains the credentials.</param>
        private void PopulateCustomizationAndCredentialDictionaries(TopologyInstance entity, Dictionary<string, List<Customization>> customizationDictionary, Dictionary<string, List<Credential>> credentialDictionary)
        {
            // process the deployment item customizations and credentials and add it to the dictionary
            foreach (DeploymentItem di in entity.DeploymentItems)
            {
                foreach (Customization c in di.Customizations)
                {
                    if (customizationDictionary.ContainsKey(c.FieldName))
                    {
                        customizationDictionary[c.FieldName].Add(c);
                    }
                    else
                    {
                        customizationDictionary.Add(c.FieldName, new List<Customization> { c });
                    }
                }

                foreach (Credential cred in di.Credentials)
                {
                    if (credentialDictionary.ContainsKey(cred.SymbolicName))
                    {
                        credentialDictionary[cred.SymbolicName].Add(cred);
                    }
                    else
                    {
                        credentialDictionary.Add(cred.SymbolicName, new List<Credential> { cred });
                    }
                }
            }

            foreach (Customization c in entity.Customizations)
            {
                if (customizationDictionary.ContainsKey(c.FieldName))
                {
                    customizationDictionary[c.FieldName].Add(c);
                }
                else
                {
                    customizationDictionary.Add(c.FieldName, new List<Customization> { c });
                }
            }
        }

        /// <summary>
        /// Copies over the selected value from the customization in the deployment item customization group to the corresponding customization in the deployment item.
        /// </summary>
        /// <param name="item">The deployment item which has the customization group.</param>
        /// <param name="customizationGroup">The customization group.</param>
        private void ProcessDeploymentItemCustomizationGroups(DeploymentItem item, CustomizationGroup customizationGroup)
        {
            Contract.Requires(item != null);
            Contract.Requires(customizationGroup != null);

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Processing the customization group '{0}' in the deployment item '{1}'", customizationGroup.Name, item.ItemName);

            if (item.Customizations == null)
            {
                item.Customizations = new List<Customization>();
            }

            foreach (Group selectedGroup in customizationGroup.Groups)
            {
                if (selectedGroup != null && selectedGroup.Selected)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Processing customizations in the selected group '{0}'", selectedGroup.Name);
                    foreach (Customization c in selectedGroup.Customizations)
                    {
                        if (!c.IsValueType(CustomizationValueType.Password))
                        {
                            Customization customization = item.Customizations.FirstOrDefault(itemCustomization => itemCustomization.FieldName.Equals(c.FieldName, StringComparison.OrdinalIgnoreCase));
                            if (customization != null)
                            {
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Setting selected value of customization '{0}' to '{1}'", customization.FieldName, c.SelectedValue);
                                customization.SelectedValue = c.GetSafeUserSelectedValue();
                            }
                            else
                            {
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Adding customization '{0}' to deployment item '{1}'", c.FieldName, item.ItemName);
                                item.Customizations.Add(new Customization()
                                {
                                    FieldName = c.FieldName,
                                    SelectedValue = c.GetSafeUserSelectedValue(),
                                    DefaultValue = c.DefaultValue,
                                    ValueType = c.ValueType
                                });
                            }
                        }
                        else if (c.IsValueType(CustomizationValueType.Password))
                        {
                            Credential credential = item.Credentials.FirstOrDefault(cred => cred.SymbolicName.Equals(c.FieldName, StringComparison.OrdinalIgnoreCase));
                            if (credential != null)
                            {
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Setting password of credential '{0}'", credential.SymbolicName);
                                credential.KeyVaultablePassword.Value = c.SelectedValue;
                            }
                            else
                            {
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Adding credential '{0}' to deployment item '{1}'", credential.SymbolicName, item.ItemName);
                                item.Credentials.Add(new Credential()
                                {
                                    SymbolicName = c.FieldName,
                                    UserName = c.FieldName,
                                    KeyVaultablePassword = new KeyVaultable<string>(c.SelectedValue),
                                });
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Sets the selected value of customizations and credentials in the topology instance to the selected value of corresponding customizations in the entity level customization groups.
        /// </summary>
        /// <param name="customizationGroup">The entity level customization group.</param>
        /// <param name="customizationDictionary">A dictionary that contains all the customizations in the topology instance.</param>
        /// <param name="credentialDictionary">A dictionary of credential entries in the topology instance.</param>
        /// <param name="error">The error, if any.</param>
        /// <returns>Whether the customization groups were successfully processed.</returns>
        private bool TryProcessEntityCustomizationGroups(CustomizationGroup customizationGroup, Dictionary<string, List<Customization>> customizationDictionary, Dictionary<string, List<Credential>> credentialDictionary, out HttpResponseMessage error)
        {
            Contract.Requires(customizationGroup != null);
            Contract.Requires(customizationDictionary != null);
            Contract.Requires(credentialDictionary != null);

            RE.Regex accountNameRegex = new RE.Regex(AccountNameRegEx);

            var selectedGroups = customizationGroup.Groups.Where(group => group.Selected && string.IsNullOrWhiteSpace(group.TargetItem)).ToList();

            foreach (var selectedGroup in selectedGroups)
            {
                if (selectedGroup.Customizations == null)
                {
                    continue;
                }

                // apply the selected value of the customizations to the respective customizations in the deployment items
                foreach (Customization entityCustomization in selectedGroup.Customizations)
                {
                    if (customizationDictionary.ContainsKey(entityCustomization.FieldName))
                    {
                        foreach (Customization customization in customizationDictionary[entityCustomization.FieldName])
                        {
                            Tracer.WriteExecutionEvent(
                                TraceComponent.DeploymentServiceApi,
                                "Setting the selected value of customization {0} from group {1}.",
                                customization.FieldName,
                                selectedGroup.Name);
                            customization.SelectedValue = entityCustomization.GetSafeUserSelectedValue();

                            if (customization.SelectedValue != null && customization.SelectedValue.Length > DeploymentServiceConfig.CustomizationSelectedValueMaximumLength)
                            {
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Customization with name [{0}] exceeds the maximum selected value length. Actual length: [{1}] Maximum length: [{2}]", customization.FieldName, customization.SelectedValue.Length, DeploymentServiceConfig.CustomizationSelectedValueMaximumLength);
                                error = this.CreateErrorResponse(ServiceErrorCode.CustomizationExceedsMaximumLength, entityCustomization.DisplayName ?? entityCustomization.FieldName);
                                return false;
                            }
                        }
                    }
                    else if (credentialDictionary.ContainsKey(selectedGroup.Name) &&
                            !string.IsNullOrEmpty(entityCustomization.SelectedValue))
                    {
                        foreach (Credential credential in credentialDictionary[selectedGroup.Name])
                        {
                            if (String.Equals(entityCustomization.FieldName, CommonCustomizationNames.UserName))
                            {
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Setting the user name of credential {0} to {1} from group {2}", credential.SymbolicName, Tracer.PIIValue, selectedGroup.Name);

                                string username = entityCustomization.GetSafeUserSelectedValue();
                                if (!accountNameRegex.IsMatch(username))
                                {
                                    Tracer.WriteExecutionEvent(
                                        TraceComponent.DeploymentServiceApi,
                                        "User selected name '{0}' did not match the regex {1}",
                                        Tracer.PIIValue,
                                        AccountNameRegEx);
                                    error = this.CreateErrorResponse(ServiceErrorCode.InvalidServiceAccountUsername, username, credential.SymbolicName);
                                    return false;
                                }

                                credential.UserName = username;
                            }
                            else if (String.Equals(entityCustomization.FieldName, CommonCustomizationNames.Password))
                            {
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Setting the password of credential {0} from group {1}", credential.SymbolicName, selectedGroup.Name);
                                credential.KeyVaultablePassword.Value = entityCustomization.SelectedValue;
                            }
                        }
                    }
                }
            }

            error = null;
            return true;
        }

        /// <summary>
        /// Sets the selected value to the default value for customizations that do not have a selected value set.
        /// </summary>
        /// <param name="entity">The topology instance.</param>
        private void SetCustomizationValues(TopologyInstance entity)
        {
            // Load with default values all customizations that do not have a selected value.
            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Setting default values for customizations.");
            foreach (var deploymentItem in entity.DeploymentItems)
            {
                foreach (var customization in deploymentItem.Customizations)
                {
                    this.SetDefaultValue(entity, customization);
                }
            }

            foreach (var customizationGroup in entity.CustomizationGroups)
            {
                foreach (var group in customizationGroup.Groups)
                {
                    foreach (var customization in group.Customizations)
                    {
                        this.SetDefaultValue(entity, customization);
                    }
                }
            }

            foreach (var customization in entity.Customizations)
            {
                this.SetDefaultValue(entity, customization);
            }
        }

        /// <summary>
        /// Private function referenced by SetCustomizationValues.
        /// </summary>
        /// <param name="entity">Topology Instance.</param>
        /// <param name="customization">Customization .</param>
        private void SetDefaultValue(TopologyInstance entity, Customization customization)
        {
            Customization entityCustomization = null;

            // if there is a matching customization at the deployment topology level apply the selected value if it isn't empty
            if (entity.Customizations != null)
            {
                entityCustomization = entity.Customizations.SingleOrDefault(c => string.Equals(c.FieldName, customization.FieldName, StringComparison.OrdinalIgnoreCase));

                if (entityCustomization != null &&
                    !string.IsNullOrEmpty(entityCustomization.SelectedValue))
                {
                    customization.SelectedValue = entityCustomization.SelectedValue;
                }
            }

            if (string.IsNullOrWhiteSpace(customization.SelectedValue))
            {
                customization.SelectedValue = customization.DefaultValue;

                if (entityCustomization != null &&
                    string.IsNullOrEmpty(entityCustomization.SelectedValue))
                {
                    entityCustomization.SelectedValue = customization.SelectedValue;
                }
            }
        }

        /// <summary>
        /// Adapts the object into its Azure Table equivalent.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier of the azure subscription in where the topology is (to be) deployed.</param>
        /// <param name="topologyInstance">Topology instance to be adapted.</param>
        /// <param name="deploymentAction">The deployment action.</param>
        /// <param name="topologyInstanceRow">The row item.</param>
        /// <returns>
        /// Whether the operation succeeded.
        /// </returns>
        private bool CreateTopologyInstanceTableItem(
            Guid tenantId,
            Guid azureSubscriptionId,
            TopologyInstance topologyInstance,
            DeploymentRequest.DeploymentAction deploymentAction,
            out TopologyInstanceTableItem topologyInstanceRow)
        {
            Contract.Requires(topologyInstance != null);

            Uri topologyBlobUri = this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);

            topologyInstanceRow = new TopologyInstanceTableItem()
            {
                TenantId = tenantId,
                AzureSubscriptionId = azureSubscriptionId,
                TopologyInstanceId = topologyInstance.InstanceId,
                TopologyInstance = topologyBlobUri.ToString(),
                TopologyName = topologyInstance.TopologyName,
                TopologyVersion = topologyInstance.TopologyVersion.ToString(CultureInfo.InvariantCulture),
                LastDeploymentAction = deploymentAction.ToString(),
                CreatedDatetime = DateTime.UtcNow,
                DeleteDatetime = null,
                CurrentActivityId = Tracer.GetCorrelationActivityId(),
                EnvironmentId = topologyInstance.EnvironmentId,
                EnvironmentGroup = topologyInstance.EnvironmentGroup.ToDefaultString(),
                TIClientOverflow = topologyInstance.TIClientOverflowToString()
            };

            Guid? buildComponentId = topologyInstance.GetBuildId();
            if (buildComponentId.HasValue)
            {
                topologyInstanceRow.BuildComponentId = buildComponentId.Value.ToString();
            }

            string buildVersion;
            if (topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.Build, out buildVersion))
            {
                topologyInstanceRow.BuildVersion = buildVersion;
            }

            string topologySkuType;
            if (topologyInstance.TryGetCustomizationValue(DeploymentConstants.TopologySkuTypeAttributeName, out topologySkuType))
            {
                topologyInstanceRow.TopologySkuType = topologySkuType;
            }

            if (!string.IsNullOrWhiteSpace(topologyInstance.TopologyId))
            {
                topologyInstanceRow.TopologyId = Guid.Parse(topologyInstance.TopologyId);
            }

            return true;
        }

        /// <summary>
        /// Gets a topology instance table item.
        /// </summary>
        /// <param name="tenantId">Target tenant identifier.</param>
        /// <param name="azureSubscriptionId">Target Azure Subscription identifier.</param>
        /// <param name="topologyInstanceId">Topology instance identifier.</param>
        /// <param name="environmentGroup">The environment group enum.</param>
        /// <param name="filterOutDeleted">Include deleted environment if false.</param>
        /// <returns>A topology instance table item.</returns>
        private TopologyInstanceTableItem GetTopologyInstanceTableItem(Guid tenantId, Guid azureSubscriptionId, string topologyInstanceId, EnvironmentGroup environmentGroup, bool filterOutDeleted = true)
        {
            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                "Retrieving topology instance table item that belong to tenant [{0}] in azure subscription [{1}] with instance ID [{2}]",
                tenantId.ToString(),
                azureSubscriptionId.ToString(),
                topologyInstanceId);

            IEnumerable<TopologyInstanceTableItem> tableRows = TopologyInstanceDAC.GetTableItems(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, filterOutDeleted);

            return tableRows.FirstOrDefault();
        }

        /// <summary>
        /// Gets a list of topology instances in a given Azure Subscription whose corresponding deployment instances are deploying.
        /// </summary>
        /// <param name="tenantId">Target tenant identifier.</param>
        /// <param name="deployingTopologyInstancesInSubscription">Returns a list of topology instances in the given Azure Subscription whose corresponding deployment instances are deploying.</param>
        private void GetDeployingTopologyInstances(Guid tenantId, out List<TopologyInstance> deployingTopologyInstancesInSubscription)
        {
            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Retrieving instances that belong to tenant [{0}]", tenantId.ToString());

            deployingTopologyInstancesInSubscription = new List<TopologyInstance>();

            AzureTable<TopologyInstanceTableItem> table = TopologyInstanceDAC.GetTopologyInstanceTable();

            var subscriptionTableRows = table.Query.Where(i => i.PartitionKey == tenantId.ToString() &&
                (String.Equals(i.LastDeploymentState, DeploymentState.Active.ToString()) ||
                String.Equals(i.LastDeploymentState, DeploymentState.Starting.ToString())));
            var tableRows = subscriptionTableRows.AsEnumerable().Where(i => i.DeleteDatetime == null);

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                "Retrieved deploying instances that belong to tenant [{0}]. Total topologies in subscription: [{1}] Topologies: [{2}]",
                tenantId.ToString(),
                tableRows.Count(),
                String.Join(";", tableRows.Select(tr => tr.TopologyInstanceId)));

            foreach (var tableRow in tableRows)
            {
                if (string.IsNullOrWhiteSpace(tableRow.TopologyInstance))
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Table row [{0}] has an empty topology instance.",
                        tableRow.ToString());
                    continue;
                }

                string topologyInstanceString = BlobHelper.ReadBlob(new Uri(tableRow.TopologyInstance), WellKnownStorageAccounts.DeploymentServiceStorage);
                if (string.IsNullOrWhiteSpace(topologyInstanceString))
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Table row [{0}]and Topology Instance blob [{1}] has null blob contents.",
                        tableRow.ToString(),
                        tableRow.TopologyInstance);
                    continue;
                }

                var topologyInstance = Serialization.DeserializeFromString<TopologyInstance>(topologyInstanceString);
                topologyInstance.DecryptData();

                deployingTopologyInstancesInSubscription.Add(topologyInstance);
            }
        }

        /// <summary>
        /// Returns a deployment item from a topology instance by filtering on the item name.
        /// </summary>
        /// <param name="entity">The topology instance.</param>
        /// <param name="itemtoFind">The deployment item to look for.</param>
        /// <returns>A DeploymentItem object.</returns>
        private DeploymentItem GetDeploymentItem(TopologyInstance entity, DeploymentItem itemtoFind)
        {
            return entity.DeploymentItems.ToList().Single(di => string.Equals(di.ItemName, itemtoFind.ItemName, StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        /// Validates if a VM instance exists in a deployment item.
        /// </summary>
        /// <param name="item">The deployment item to search the instance for.</param>
        /// <param name="instance">The instance to search for.</param>
        /// <returns>True or false.</returns>
        private bool InstanceExists(DeploymentItem item, Instance instance)
        {
            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Checking if instance {0} exists in topologyinstance.deploymentitem {1}", instance.MachineName, item.ItemName);
            return item.Instances.Any(i => i.MachineName.Equals(instance.MachineName, StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        /// Calls OnValidationFailed for each module.
        /// </summary>
        /// <param name="entity">The entity.</param>
        /// <param name="tenantRegistration">The tenant registration.</param>
        /// <param name="action">The deployment action.</param>
        /// <param name="initialTopologyInstance">The initial topology instance.</param>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "The method is called in exception handling and it should not throw further exception from here.")]
        private void OnValidationFailed(TopologyInstance entity, TenantRegistration tenantRegistration, DeploymentRequest.DeploymentAction action, TopologyInstance initialTopologyInstance)
        {
            Contract.Requires(entity != null);
            try
            {
                switch (action)
                {
                    case DeploymentRequest.DeploymentAction.Deploy:
                        this.DeleteDnsLookupEntries(entity);
                        this.DeleteCloudServiceLookupEntries(entity);
                        break;
                }

                if (entity.Modules != null)
                {
                    foreach (DeploymentModule module in entity.Modules)
                    {
                        module.OnValidationFailed(entity, tenantRegistration, action, initialTopologyInstance);
                    }
                }
            }
            catch (Exception exception)
            {
                Tracer.WriteErrorEvent(
                                TraceComponent.DeploymentServiceApi,
                                exception,
                                "Unable to roll back modules in {0} topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'",
                                action,
                                entity.InstanceId,
                                tenantRegistration.AzureSubscriptionId,
                                tenantRegistration.TenantId);
            }
        }

        /// <summary>
        /// Deletes the DNS lookup entries for the given topology instance.
        /// </summary>
        /// <param name="entity">The topology instance entity.</param>
        private void DeleteDnsLookupEntries(TopologyInstance entity)
        {
            if (entity.DnsRecordSets == null || !entity.DnsRecordSets.Any())
            {
                return;
            }

            HttpResponseMessage errorMessage;
            DnsZone dnsZone;
            if (this.TryGetDnsZone(entity, out dnsZone, out errorMessage))
            {
                LookupManager lookupManager = new LookupManager(dnsZone.ZoneName);
                foreach (var dnsrecord in entity.DnsRecordSets.Where(d => !string.IsNullOrWhiteSpace(d.Name)))
                {
                    // check if we acquired the lookup entry for this record, and only delete if true
                    // older deployments do not have this customization, we assume it as acquired initially
                    bool dnslookupAcquired = false;
                    Customization lookupEntryAcquiredCustomization = null;

                    // if customization doesn't exist, this is an older deployment and we force deleting
                    if (!dnsrecord.TryGetCustomization(CommonCustomizationNames.DNSLookupEntryAcquired, out lookupEntryAcquiredCustomization))
                    {
                        lookupEntryAcquiredCustomization = null;
                    }

                    // if customization exists, check if this topology acquired it and only then delete it
                    if (lookupEntryAcquiredCustomization == null ||
                        (dnsrecord.TryGetCustomizationValue(CommonCustomizationNames.DNSLookupEntryAcquired, out dnslookupAcquired) && dnslookupAcquired))
                    {
                        lookupManager.DeleteEntityIfExists(dnsrecord.Name);
                        dnsrecord.SetCustomizationValue(CommonCustomizationNames.DNSLookupEntryAcquired, Boolean.FalseString);
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Skipping delete for lookup entry [{0}] because it was not acquired here.", dnsrecord.Name);
                    }
                }
            }
        }

        /// <summary>
        /// Deletes the cloud service lookup entries for the given topology instance.
        /// </summary>
        /// <param name="entity">The topology instance entity.</param>
        private void DeleteCloudServiceLookupEntries(TopologyInstance entity)
        {
            if (entity.CloudServices == null)
            {
                return;
            }

            var cloudServiceInstances = entity.CloudServices.SelectMany(c => c.CloudServiceInstances.Where(csi => !string.IsNullOrWhiteSpace(csi.Name)));
            LookupManager lookupManager = new LookupManager(AzureEnvironmentConfig.AzureBaseHost);
            foreach (var cloudServiceInstance in cloudServiceInstances)
            {
                lookupManager.DeleteEntityIfExists(cloudServiceInstance.Name);
            }
        }

        /// <summary>
        /// Calls OnDeploymentScheduling for each module.
        /// </summary>
        /// <param name="entity">The entity.</param>
        /// <param name="tenantRegistration">The tenant registration.</param>
        private void OnDeploymentScheduling(TopologyInstance entity, TenantRegistration tenantRegistration)
        {
            Contract.Requires(entity != null);

            if (entity.Modules != null)
            {
                foreach (DeploymentModule module in entity.Modules)
                {
                    module.OnDeploymentScheduling(entity, tenantRegistration);
                }
            }
        }

        /// <summary>
        /// Stops a deployment instance.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <param name="deploymentState">State of the deployment.</param>
        /// <returns>
        /// An HTTPResponseMessage.
        /// </returns>
        private HttpResponseMessage StopTopologyInstance(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters,
            DeploymentState deploymentState)
        {

            Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Stopping topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. State = '{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    deploymentState);

            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.Stop;
            TopologyInstance topologyInstance;
            DeploymentInstance deploymentInstance;
            Uri deploymentInstanceBlobUri;
            HttpResponseMessage errorMessage;
            TopologyInstanceTableItem topologyInstanceRow;
            EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
            DeploymentRequest request = null;

            try
            {
                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (deploymentInstance.DeploymentState != DeploymentState.Stopped &&
                    deploymentInstance.DeploymentState != DeploymentState.Finished &&
                    deploymentInstance.DeploymentState != DeploymentState.SafeMode &&
                    deploymentInstance.DeploymentState != DeploymentState.MigratingToSF &&
                    deploymentInstance.DeploymentState != DeploymentState.MigratedToSF &&
                    deploymentInstance.DeploymentStatus != Microsoft.DynamicsOnline.Deployment.Service.DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete &&
                    deploymentInstance.DeploymentStatus != Model.DeploymentStatus.StateTransitionIncompleteInDR)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }

                if (topologyInstance.HasCustomizationValue(CommonCustomizationNames.IsSwapped, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment is currently Swapped. Rollback or Commit is expected.", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNotSwapped, action);
                }
                else if (topologyInstance.HasCustomizationValue(CommonCustomizationNames.RollbackInProgress, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] topology [{1}] but the environment did not complete Rollback. Rollback or Commit is expected.", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNotRollback, action);
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                string taskDefinitionName;
                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                    taskDefinitionName = DeploymentManagementPipedMasterWorkflow.TaskNameConstant;
                }
                else
                {
                    taskDefinitionName = DeploymentManagementMasterWorkflow.TaskNameConstant;
                }

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, taskDefinitionName, out errorMessage, deploymentState))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (Exception error)
            {
                if (deploymentState == DeploymentState.Deallocating)
                {
                    // Set the status to Succeeded regardless if failed as this does not affect topology state.
                    this.UpdateTopologyAndDeploymentInstance(
                        tenantId,
                        azureSubscriptionId,
                        topologyInstanceId,
                        environmentGroup,
                        (cloudDeploymentInstance) =>
                        {
                            cloudDeploymentInstance.DeploymentState = DeploymentState.Finished;
                            cloudDeploymentInstance.DeploymentStatus = Model.DeploymentStatus.StateTransitionIncomplete;

                            cloudDeploymentInstance.DeploymentErrors = request.Deployment.DeploymentErrors;
                            cloudDeploymentInstance.DeploymentWarnings = request.Deployment.DeploymentWarnings;
                        },
                        (cloudTopologyInstance) =>
                        {
                            cloudTopologyInstance.DeploymentState = DeploymentState.Finished;
                            cloudTopologyInstance.DeploymentStatus = Model.DeploymentStatus.StateTransitionIncomplete;
                        },
                        out errorMessage);
                }

                var serviceException = error as ServiceException;
                if (serviceException != null)
                {
                    Tracer.WriteErrorEvent(
                         TraceComponent.DeploymentServiceApi,
                         serviceException,
                         "Failed to stop topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                         topologyInstanceId,
                         azureSubscriptionId,
                         tenantId,
                         serviceException.ErrorCode);

                    Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());
                    return this.CreateErrorResponse(serviceException);
                }
                else
                {
                    Tracer.WriteErrorEvent(
                       TraceComponent.DeploymentServiceApi,
                       error,
                       "Failed to stop topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                       topologyInstanceId,
                       azureSubscriptionId,
                       tenantId);

                    Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                    throw;
                }
            }
        }

        /// <summary>
        /// Moves a VM from one Back End pool to another.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <param name="action">The deployment action for the management workflow.</param>
        /// <returns>
        /// An HTTPResponseMessage.
        /// </returns>
        private HttpResponseMessage MoveToPool(
            [FromODataUri] Guid tenantId,
            [FromODataUri] Guid azureSubscriptionId,
            [FromODataUri] string topologyInstanceId,
            ODataActionParameters parameters,
            DeploymentRequest.DeploymentAction action)
        {
            try
            {
                string instance = parameters.ContainsKey(TopologyInstancesController.InstanceNameParameter) ? (string)parameters[TopologyInstancesController.InstanceNameParameter] : null;
                if (String.IsNullOrWhiteSpace(instance))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "MoveToPool call is missing input parameter VM instance name.");
                    return this.CreateErrorResponse(ServiceErrorCode.MoveToPool_InvalidInstanceName);
                }

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Moving topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}' VmName = '{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    instance);

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                HttpResponseMessage errorMessage;
                TopologyInstanceTableItem topologyInstanceRow;
                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                System.Uri deploymentInstanceBlobUri;

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                if (deploymentInstance.DeploymentState != DeploymentState.Finished)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, action);
                }

                deploymentInstance.DeploymentActionParameters.Add(DeploymentConstants.MoveVMInstanceIdentifierParameter, instance);

                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (request.Topology.ShouldUseAzureResourceManager())
                {
                    this.EnsureDeploymentApplicationRole(request.TenantRegistration);
                }

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentManagementMasterWorkflow.TaskNameConstant, out errorMessage))
                {
                    this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to move VM to/from maintenance mode topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to move VM to/from maintenance mode topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Previous method of deletion which does not delete any Azure artifacts.
        /// </summary>
        /// <param name="tenantId">The tenant identifier.</param>
        /// <param name="azureSubscriptionId">The azure subscription identifier.</param>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="topologyInstanceRow">The topology instance row.</param>
        /// <param name="deploymentInstance">The deployment instance.</param>
        /// <param name="deploymentInstanceBlobUri">The deployment instance BLOB URI.</param>
        /// <returns>An empty response.</returns>
        private HttpResponseMessage LegacyDelete(Guid tenantId, Guid azureSubscriptionId, TopologyInstance topologyInstance, TopologyInstanceTableItem topologyInstanceRow, DeploymentInstance deploymentInstance, Uri deploymentInstanceBlobUri)
        {
            if (deploymentInstance.DeploymentState != DeploymentState.Deallocated)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", DeploymentRequest.DeploymentAction.Delete, topologyInstance, deploymentInstance.DeploymentState);
                return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresDeallocatedState, DeploymentRequest.DeploymentAction.Delete);
            }

            if (topologyInstanceRow != null)
            {
                AzureTable<TopologyInstanceTableItem> table = TopologyInstanceDAC.GetTopologyInstanceTable();
                topologyInstanceRow.CurrentActivityId = Tracer.GetCorrelationActivityId();
                topologyInstanceRow.DeleteDatetime = DateTime.UtcNow;
                topologyInstanceRow.LastDeploymentAction = DeploymentRequest.DeploymentAction.Delete.ToString();
                table.Upsert(topologyInstanceRow);
            }

            if (topologyInstance != null && topologyInstance.Modules != null)
            {
                foreach (DeploymentModule module in topologyInstance.Modules.Reverse<DeploymentModule>())
                {
                    module.OnDeploymentDeleted(topologyInstance);
                }
            }

            return Request.CreateResponse(HttpStatusCode.NoContent);
        }

        /// <summary>
        /// Tries to get the DNS zone for the give topology instance.
        /// </summary>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="dnsZone">The DNS zone.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>The DNS zone for the give topology instance.</returns>
        private bool TryGetDnsZone(TopologyInstance topologyInstance, out DnsZone dnsZone, out HttpResponseMessage errorMessage)
        {
            string dnsZoneIdentifier;
            if (!topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.DNSZoneIdentifierCustomization, out dnsZoneIdentifier) || string.IsNullOrWhiteSpace(dnsZoneIdentifier))
            {
                Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "DNS Zone identifier is not set for topology '{0}' Id '{1}'.",
                        topologyInstance.TopologyName,
                        topologyInstance.InstanceId);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_MissingDnsZoneInformation);
                dnsZone = null;
                return false;
            }

            DnsZoneManager zoneManager = new DnsZoneManager();
            dnsZone = zoneManager.GetDnsZone(dnsZoneIdentifier);

            if (dnsZone == null)
            {
                Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "DNS Zone is not found for topology '{0}' Id '{1}' with DNS Zone identifier '{2}'.",
                        topologyInstance.TopologyName,
                        topologyInstance.InstanceId,
                        dnsZoneIdentifier);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_MissingDnsZoneInformation);
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Checks DNS Server already has existing entry for the dnsname.
        /// </summary>
        /// <param name="dnsZoneObj">DNSZone object with necessary information to access the DNS records from Azure DNS.</param>
        /// <param name="dnsName">DNSName that needs to be checked.</param>
        /// <returns>Whether DNSName already exist under the given DNSZone.</returns>
        private bool IsExistingDNSRecord(DnsZone dnsZoneObj, string dnsName)
        {
            string dnsManagerApplicationId = ARMConfig.DefaultApplicationId;
            X509Certificate2 dnsManagerCertificate = SecureCertificateManager.GetCertificateByThumbprint(ARMConfig.DefaultApplicationCertificateThumbprint);
            using (AzureResourceManager manager = new AzureResourceManager(dnsZoneObj.TenantId, dnsZoneObj.AzureSubscriptionId.ToString(), dnsZoneObj.ResourceGroupName, dnsManagerApplicationId, dnsManagerCertificate))
            {
                RecordSet recordSet;
                if (manager.DNS.Value.TryGetRecordSet(dnsZoneObj.ZoneName, dnsName, RecordType.CNAME, out recordSet))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNSRecordSet already exists for DNS name {0} under DNSZone {1}.", dnsName, dnsZoneObj.ZoneName);
                    return true;
                }
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNSRecordSet not found for DNS name {0} under DNSZone {1}.", dnsName, dnsZoneObj.ZoneName);
            return false;
        }

        /// <summary>
        /// Add DNS record to the DNS Server.
        /// </summary>
        /// <param name="dnsZoneObj">DNSZone object with necessary information to access the DNS records from Azure DNS.</param>
        /// <param name="dnsName">DNSName for which the record should be added.</param>
        /// <param name="address">Address to be added to the DNS record.</param>
        /// <returns>Whether DNSName already exist under the given DNSZone.</returns>
        private bool AddDNSRecord(DnsZone dnsZoneObj, string dnsName, string address)
        {
            string dnsManagerApplicationId = ARMConfig.DefaultApplicationId;
            X509Certificate2 dnsManagerCertificate = SecureCertificateManager.GetCertificateByThumbprint(ARMConfig.DefaultApplicationCertificateThumbprint);
            using (AzureResourceManager manager = new AzureResourceManager(dnsZoneObj.TenantId, dnsZoneObj.AzureSubscriptionId.ToString(), dnsZoneObj.ResourceGroupName, dnsManagerApplicationId, dnsManagerCertificate))
            {
                RecordSet recordSet = manager.DNS.Value.CreateRecordSetTypeCNAME(dnsZoneObj.ZoneName, dnsName, address);
                if (recordSet != null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNSRecordSet created with DNSName:{0} Address:{1} under DNSZone {2}.", dnsName, address, dnsZoneObj.ZoneName);
                    return true;
                }
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Failed to add DNSRecordSet with DNSName:{0} Address:{1} under DNSZone {2}.", dnsName, address, dnsZoneObj.ZoneName);
            return false;
        }

        /// <summary>
        /// Update DNS record set to the DNS Server.
        /// </summary>
        /// <param name="dnsZoneObj">DNSZone object with necessary information to access the DNS records from Azure DNS.</param>
        /// <param name="dnsName">DNSName for which the record should be added.</param>
        /// <param name="address">Address to be added to the DNS record.</param>
        /// <returns>Whether DNSName already exist under the given DNSZone.</returns>
        private bool UpdateDNSRecord(DnsZone dnsZoneObj, string dnsName, string address)
        {
            string dnsManagerApplicationId = ARMConfig.DefaultApplicationId;
            X509Certificate2 dnsManagerCertificate = SecureCertificateManager.GetCertificateByThumbprint(ARMConfig.DefaultApplicationCertificateThumbprint);
            using (AzureResourceManager manager = new AzureResourceManager(dnsZoneObj.TenantId, dnsZoneObj.AzureSubscriptionId.ToString(), dnsZoneObj.ResourceGroupName, dnsManagerApplicationId, dnsManagerCertificate))
            {
                RecordSet recordSet = manager.DNS.Value.UpdateRecordSetTypeCNAME(dnsZoneObj.ZoneName, dnsName, address);
                if (recordSet != null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNSRecordSet updated with DNSName:{0} Address:{1} under DNSZone {2}.", dnsName, address, dnsZoneObj.ZoneName);
                    return true;
                }
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNSRecordSet updated with DNSName:{0} Address:{1} under DNSZone {2}.", dnsName, address, dnsZoneObj.ZoneName);
            return false;
        }

        /// <summary>
        /// Remove DNS records from the DNS Server.
        /// </summary>
        /// <param name="dnsZoneObj">DNSZone object with necessary information to access the DNS records from Azure DNS.</param>
        /// <param name="dnsName">DNSName that needs to be checked.</param>
        /// <returns>Whether DNSName already exist under the given DNSZone.</returns>
        private bool RemoveDNSRecord(DnsZone dnsZoneObj, string dnsName)
        {
            string dnsManagerApplicationId = ARMConfig.DefaultApplicationId;
            X509Certificate2 dnsManagerCertificate = SecureCertificateManager.GetCertificateByThumbprint(ARMConfig.DefaultApplicationCertificateThumbprint);
            using (AzureResourceManager manager = new AzureResourceManager(dnsZoneObj.TenantId, dnsZoneObj.AzureSubscriptionId.ToString(), dnsZoneObj.ResourceGroupName, dnsManagerApplicationId, dnsManagerCertificate))
            {
                manager.DNS.Value.DeleteRecordSet(dnsZoneObj.ZoneName, dnsName, RecordType.CNAME);
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Deleted DNSRecordSet with DNSName:{0} under DNSZone [{1}].", dnsName, dnsZoneObj.ZoneName);
            }

            return true;
        }

        /// <summary>
        /// Check if a host name is resolved or not.
        /// </summary>
        /// <param name="hostName">hostName to resolve.</param>
        /// <returns>A boolean indicating whether or not the host entry got resolved.</returns>
        private bool IsHostNameResolved(string hostName)
        {
            bool result = false;
            try
            {
                IPHostEntry hostInfo = System.Net.Dns.GetHostEntry(hostName);
                if (hostInfo != null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi,
                        "Resolved DNSName [{0}] with hostname:[{1}] IPAddresses:[{2}].",
                        hostName, hostInfo.HostName, string.Join(",", hostInfo.AddressList.Select(a => a.ToString())));

                    //lets make sure the target resource is not parked on MSFT redirect host otherwise the DNS is still considered valid.
                    if (!hostInfo.AddressList.Contains<IPAddress>(IPAddress.Parse(Library.Constants.MSFTParkedDNS)))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Successfully resolved DNSName [{0}] cannot be removed.", hostName);
                        result = true;
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Resolved DNSName [{0}] but it is parked on MSFT Redirect host: [{1}].",
                            hostName, string.Join(",", hostInfo.AddressList.Select(a => a.ToString())));
                    }
                }
                else
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Failed to resolve DNSName [{0}].", hostName);
                }
            }
            catch (Exception ex)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, ex, "Failed to resolve DNSName [{0}].", hostName);
            }
            return result;
        }

        /// <summary>
        /// Traces a deployment error.
        /// </summary>
        /// <param name="tenantId">The identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">The identifier of the Azure subscription.</param>
        /// <param name="topologyInstanceId">The identifier of the topology instance.</param>
        /// <param name="action">The action that failed.</param>
        /// <param name="errorResponseMessage">The error response to be send to the user.</param>
        private void TraceCustomerActionError(Guid tenantId, Guid azureSubscriptionId, string topologyInstanceId, DeploymentRequest.DeploymentAction action, HttpResponseMessage errorResponseMessage)
        {
            DeploymentError error = null;
            if (errorResponseMessage != null)
            {
                errorResponseMessage.TryGetContentValue<DeploymentError>(out error);
            }

            Dictionary<string, string> payload = new Dictionary<string, string>();
            payload["DeploymentRequestAction"] = action.ToString();
            payload["AzureSubscription"] = azureSubscriptionId.ToString();
            payload["TenantId"] = tenantId.ToString();
            payload["EnvironmentName"] = topologyInstanceId;

            if (error != null)
            {
                TelemetryTraceHelper.GeneratePayloadFromErrors(new[] { error }, payload);
            }

            Tracer.WriteExecutionEvent(new ExecutionEventDescriptor()
            {
                CompanyId = tenantId,
                Component = TraceComponent.DeploymentServiceApi,
                PayloadType = (payload != null && payload.Any()) ? "JSON" : String.Empty,
                Payload = (payload != null && payload.Any()) ? new JavaScriptSerializer().Serialize(payload) : String.Empty,
                EventMessage = Tracer.FormatMessage(
                    "Failed to {0} topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}' because of error code '{4}' reason '{5}'.",
                    action,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    errorResponseMessage != null ? errorResponseMessage.StatusCode.ToString() : "NULL",
                    error != null ? error.ToString() : "NULL"),
            });
        }

        /// <summary>
        /// Creates a string that represents a well-formatted RDP file content.
        /// </summary>
        /// <param name="instance">The VM instance object for which to create RDP file.</param>
        /// <param name="entity">The topology instance for the instance.</param>
        /// <returns>The content of RDP file or null if input object does not have RDP ling populated.</returns>
        private string FormARMRDPFile(Instance instance, TopologyInstance entity)
        {
            if (!String.IsNullOrEmpty(instance.RDPEndpoint))
            {
                UriBuilder rdpFullUri = new UriBuilder(new Uri(instance.RDPEndpoint));
                IPAddress address = null;

                // If RDP endpoint is based on IP then use the DNS name from Reserved IP
                if (IPAddress.TryParse(rdpFullUri.Host, out address))
                {
                    var reservedIP = entity.ReservedIPs.FirstOrDefault(rip => string.Equals(rip.VirtualIP, rdpFullUri.Host, StringComparison.OrdinalIgnoreCase));
                    if (reservedIP == null)
                    {
                        return null;
                    }

                    rdpFullUri.Host = reservedIP.Address;
                }

                string rdpWellFormattedUri = String.Join(":", rdpFullUri.Host, rdpFullUri.Port);
                return String.Format(CultureInfo.InvariantCulture, "full address:s:{0}{1}prompt for credentials:i:1{1}administrative session:i:1", rdpWellFormattedUri, Environment.NewLine);
            }
            else
            {
                return null;
            }
        }

        /// <summary>
        /// Check count of available IPs on the given subnet.
        /// </summary>
        /// <param name="countOfVMs">Count of VMs.</param>
        /// <param name="entity">Topology instance.</param>
        /// <param name="tenantRegistration">Tenant registration.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>A value indicating whether or not there enough available IPs for deploying.</returns>
        private bool ValidateARMAvailableIPs(int countOfVMs, TopologyInstance entity, TenantRegistration tenantRegistration, out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            DeploymentItem networkItem = entity.GetPrimaryNetworkDeploymentItem();
            CustomizationGroup vnetCustomizationGroup = networkItem.CustomizationGroups.SingleOrDefault(cg => cg.Name.Equals(CommonCustomizationNames.VnetName, StringComparison.OrdinalIgnoreCase));

            Customization vnetNameCustomization;
            if (!vnetCustomizationGroup.TryGetCustomization(CommonCustomizationNames.UseExistingVnet, CommonCustomizationNames.VnetName, out vnetNameCustomization))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Can't get customization for VNET name.");
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_CustomVnetNameMissing);
                return false;
            }

            Customization applicationSubnetNameCustomization;
            if (!vnetCustomizationGroup.TryGetCustomization(CommonCustomizationNames.UseExistingVnet, CommonCustomizationNames.ApplicationSubnetName, out applicationSubnetNameCustomization))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Can't get customization for application subnet name.");
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ApplicationSubnetMissingOrInvalid);
                return false;
            }

            string subnetName = applicationSubnetNameCustomization.SelectedValue;

            if (string.IsNullOrEmpty(subnetName))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Can't get selected value for application subnet name.");
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ApplicationSubnetMissingOrInvalid);
                return false;
            }

            string[] resourceGroupVnetNameSplit = vnetNameCustomization.SelectedValue.Split(':');

            if (resourceGroupVnetNameSplit.Length < 2)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, string.Format(CultureInfo.CurrentCulture, "Should be in this form: 'ResourceGroupName:VNETName'. Value passed '{0}'", vnetNameCustomization.SelectedValue));
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ResourceGroupVNETMissing);
                return false;
            }

            string vnetResourceGroup = resourceGroupVnetNameSplit[0];
            string vnetName = resourceGroupVnetNameSplit[1];

            using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager(vnetResourceGroup))
            {
                VirtualNetwork targetNetwork;
                try
                {
                    targetNetwork = manager.Network.Value.GetVirtualNetwork(vnetName);
                }
                catch (CloudException ex)
                {
                    string message = Tracer.FormatMessage(
                         "No virtual network with the name '{0}' exists in the resource group '{1}'. Cannot proceed further as the customer chose to use an existing VNET but as no virtual network exists. Exception: '{1}'",
                         vnetName,
                         vnetResourceGroup,
                         ex.ToString());

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, ex.Message);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_CustomVnetNotExists, message);
                    return false;
                }

                if (targetNetwork == null)
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "No virtual network with the name '{0}' exists in the resource group '{1}'. Cannot proceed further as the customer chose to use an existing VNET but as no virtual network exists.",
                         vnetName,
                         vnetResourceGroup);

                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_CustomVnetNotExists);
                    return false;
                }

                return this.ValidateARMAvailableIPs(countOfVMs, targetNetwork, subnetName, out errorMessage);
            }
        }

        /// <summary>
        /// Check count of available IPs on the given subnet.
        /// </summary>
        /// <param name="countOfVMs">Count of VMs.</param>
        /// <param name="virtualNetwork">Virtual network resource.</param>
        /// <param name="subnetName">Subnet name.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>A value indicating whether or not there enough available IPs for deploying.</returns>
        private bool ValidateARMAvailableIPs(int countOfVMs, VirtualNetwork virtualNetwork, string subnetName, out HttpResponseMessage errorMessage)
        {
            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Start to validate count of available IPs on the given subnet [{0}].", subnetName);

            Azure.Management.Network.Models.Subnet targetSubnet = virtualNetwork.Subnets.FirstOrDefault(s => string.Equals(s.Name, subnetName, StringComparison.OrdinalIgnoreCase));
            if (targetSubnet == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "There is no subnet with name [{0}] in virtual network name [{1}]", subnetName, virtualNetwork.Name);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_ApplicationSubnetMissingOrInvalid);
                return false;
            }

            // If targetSubnet isn't NULL and targetSubnet.IpConfigurations is NULL we skip validation
            // because IpConfigurations is optional property and will equal NULL if subnet doesn't use yet.
            // See https://msdn.microsoft.com/en-us/library/microsoft.azure.management.network.models.subnet.aspx
            if (targetSubnet.IpConfigurations == null)
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Skip validation of available IPs, because can't calculate count of used IPs in the subnet with name [{0}]. Virtual network [{1}].",
                    subnetName,
                    virtualNetwork.Name);

                errorMessage = null;
                return true;
            }

            if (string.IsNullOrEmpty(targetSubnet.AddressPrefix))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "There is no address prefix for the subnet with name [{0}] in virtual network [{1}]", subnetName, virtualNetwork.Name);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidTopology_InvalidSubnetAddressPrefix);
                return false;
            }

            string addressPrefix = targetSubnet.AddressPrefix;
            int netmaskLength = int.Parse(addressPrefix.Substring(addressPrefix.IndexOf("/", StringComparison.OrdinalIgnoreCase) + 1), CultureInfo.InvariantCulture);

            // Azure reserves some IP addresses within each subnet. The first and last IP addresses of the subnets are
            // reserved for protocol conformance, along with 3 more addresses used for Azure services.
            // See https://azure.microsoft.com/en-us/documentation/articles/virtual-networks-faq/
            const int ReservedIPs = 5;

            int countOfAvailableIPs = Convert.ToInt32(Math.Pow(2, 32 - netmaskLength) - ReservedIPs - targetSubnet.IpConfigurations.Count);

            if (countOfVMs <= countOfAvailableIPs)
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Count of available IPs [{0}] on the given subnet [{1}] enough for deploy [{2}] VMs.",
                    countOfAvailableIPs,
                    subnetName,
                    countOfVMs);

                errorMessage = null;
                return true;
            }
            else
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "The count of available IPs [{0}] on the input subnet [{1}] is less than count of IPs needed for deployment [{2}].",
                    countOfAvailableIPs,
                    subnetName,
                    countOfVMs);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.NotEnoughAvailableIPsForDeployment, countOfAvailableIPs, subnetName, countOfVMs);
                return false;
            }
        }

        /// <summary>
        /// Validates and returns deployment details.
        /// </summary>
        /// <param name="tenantId">Identifier of the target tenant owner of the topology.</param>
        /// <param name="azureSubscriptionId">Identifier for the azure subscription Id.</param>
        /// <param name="topologyInstanceId">Identifier of the target topology instance Id.</param>
        /// <param name="environmentGroup">The environment group enum.</param>
        /// <param name="topologyInstance">Identifier of the target topology instance.</param>
        /// <param name="errorMessage">The error message that will be returned if operation fails validation.</param>
        /// <param name="topologyInstanceRow">Identifier of the target topology instance row.</param>
        /// <param name="deploymentInstance">Identifier of the deployment instance.</param>
        /// <param name="deploymentInstanceBlobUri">Identifier of the deployment instance blob Uri.</param>
        /// <param name="action">The DeploymentAction being carried out.</param>
        /// <returns>True if no error occurs, else returns false.</returns>
        private bool ValidateAndFetchDeploymentDetails(
            Guid tenantId,
            Guid azureSubscriptionId,
            string topologyInstanceId,
            EnvironmentGroup environmentGroup,
            out TopologyInstance topologyInstance,
            out HttpResponseMessage errorMessage,
            out TopologyInstanceTableItem topologyInstanceRow,
            out DeploymentInstance deploymentInstance,
            out Uri deploymentInstanceBlobUri,
            DeploymentRequest.DeploymentAction action)
        {
            if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out errorMessage, out topologyInstanceRow))
            {
                deploymentInstance = null;
                deploymentInstanceBlobUri = null;
                return false;
            }

            if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
            {
                return false;
            }

            if (deploymentInstance.DeploymentState != DeploymentState.Stopped &&
             deploymentInstance.DeploymentState != DeploymentState.Finished &&
             deploymentInstance.DeploymentStatus != Microsoft.DynamicsOnline.Deployment.Service.DeploymentApi.Model.DeploymentStatus.StateTransitionIncomplete)
            {
                Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                       "Attempting to [{0}], corresponding to topology [{1}] but it is currently in state [{2}].",
                       action,
                       topologyInstance,
                       deploymentInstance.DeploymentState);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, DeploymentState.Servicing);
                return false;
            }

            return true;
        }

        /// <summary>
        /// Validates the resource availability of the given topology for the DeployDisasterRecovery action.
        /// </summary>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="tenantRegistration">The tenant associated with the deployment.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <returns>
        /// A value indicating whether or not there are sufficient resources to support the topology.
        /// </returns>
        private bool ValidateTopologyForDeployDR(TopologyInstance entity, TenantRegistration tenantRegistration, out HttpResponseMessage errorMessage)
        {
            if (!this.ValidateVMBaseDeploymentItems(entity.InstanceId, entity.GetDisasterRecoveryVirtualMachineItems(), out errorMessage))
            {
                return false;
            }

            List<TopologyInstance> ongoingTopologyInstances;
            this.GetDeployingTopologyInstances(tenantRegistration.TenantId, out ongoingTopologyInstances);
            if (entity.ShouldUseAzureResourceManager())
            {
                var armOngoingTopologies = ongoingTopologyInstances.Where(d => d.ShouldUseAzureResourceManager() && string.Equals(d.CloudServiceLocation, entity.CloudServiceLocation, StringComparison.OrdinalIgnoreCase)).ToList();

                if (!this.ValidateTopologyARMResourceAvailabilityForDeployDR(tenantRegistration, entity, armOngoingTopologies, out errorMessage))
                {
                    return false;
                }

                if (!this.ValidateARMStorageAccounts(entity, tenantRegistration, out errorMessage))
                {
                    return false;
                }
            }
            else
            {
                IServiceManagement azureProxy = null;
                AzureSubcription subscription;
                Func<IServiceManagement, AzureSubcription> getSubscription = (proxy) => proxy.GetAzureSubscription(tenantRegistration.AzureSubscriptionId);

                if (!this.ValidateTenantRegistrationCertificate(tenantRegistration, out errorMessage, out azureProxy, out subscription, getSubscription))
                {
                    return false;
                }

                if (!this.ValidateRDFEStorageAccounts(tenantRegistration.AzureSubscriptionId, entity, tenantRegistration, subscription, azureProxy, out errorMessage))
                {
                    return false;
                }

                var rdfeOngoingTopologies = ongoingTopologyInstances.Where(d => !d.ShouldUseAzureResourceManager()).ToList();
                if (!this.ValidateTopologyRDFEResourceAvailabilityForDeployDR(tenantRegistration, entity, out errorMessage, subscription, rdfeOngoingTopologies, azureProxy))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Validates the resource availability of the given topology for the DeployDisasterRecovery action.
        /// </summary>
        /// <param name="tenantRegistration">The tenant associated with the deployment.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <param name="subscription">Azure subscription containing resourcing information.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="azureProxy">The azure proxy.</param>
        /// <returns>
        /// A value indicating whether or not there are sufficient resources to support the topology.
        /// </returns>
        private bool ValidateTopologyRDFEResourceAvailabilityForDeployDR(TenantRegistration tenantRegistration, TopologyInstance entity, out HttpResponseMessage errorMessage, AzureSubcription subscription, List<TopologyInstance> ongoingTopologyInstances, IServiceManagement azureProxy)
        {
            if (entity.GetDisasterRecoveryNetworkDeploymentItem() == null &&
                !this.ValidateTopologyRDFEVirtualNetworkAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, subscription, ongoingTopologyInstances, azureProxy, newNetworkResources: 1))
            {
                return false;
            }

            int primaryCloudServices = entity.CloudServices.SelectMany(cs => cs.CloudServiceInstances).Where(csi => csi.IsPrimary()).Count();
            int disasterRecoveryCloudServices = entity.CloudServices.SelectMany(cs => cs.CloudServiceInstances).Where(csi => csi.IsDisasterRecovery()).Count();
            int neededCloudServices = primaryCloudServices - disasterRecoveryCloudServices;
            if (!this.ValidateTopologyRDFEHostedServiceAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, subscription, ongoingTopologyInstances, azureProxy, neededCloudServices))
            {
                return false;
            }

            if (entity.GetDisasterRecoveryAppGatewayDeploymentItem() == null)
            {
                var primaryAGitem = entity.GetPrimaryAppGatewayDeploymentItem();
                if (primaryAGitem != null &&
                    (!this.ValidateTopologyRDFEApplicationGatewayAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, azureProxy, primaryAGitem.GetCoreCount()) ||
                     !this.ValidateTopologyCoresAvailability(tenantRegistration, entity, ongoingTopologyInstances, out errorMessage, primaryAGitem.GetCoreCount())))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Validates the resource availability of the given topology for the DeployDisasterRecovery action.
        /// </summary>
        /// <param name="tenantRegistration">The tenant associated with the deployment.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <returns>
        /// A value indicating whether or not there are sufficient resources to support the topology.
        /// </returns>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "The method is can throw a variety of exceptions from here which makes being precise difficult.")]
        private bool ValidateTopologyARMResourceAvailabilityForDeployDR(TenantRegistration tenantRegistration, TopologyInstance entity, List<TopologyInstance> ongoingTopologyInstances, out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            using (var manager = tenantRegistration.CreateAzureResourceManager())
            {
                string region = TopologyInstanceExtensions.MapRDFEtoARMLocation(entity.CloudServiceLocation);

                IEnumerable<Microsoft.Azure.Management.Network.Models.Usage> networkUsage = null;

                try
                {
                    // This can thrown an Exception if the subscription has not deployed any ARM Elements.
                    networkUsage = manager.Network.Value.NetworkingUsage(region);
                }
                catch (CloudException ce)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' has thrown an CloudException while validating networking resources. Exception '{1}'", tenantRegistration.AzureSubscriptionId, ce);
                    return true;
                }
                catch (Exception e)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' has thrown an Exception while validating networking resources. Exception '{1}'", tenantRegistration.AzureSubscriptionId, e);
                    return false;
                }

                if (entity.GetDisasterRecoveryNetworkDeploymentItem() == null &&
                    (!this.ValidateTopologyARMVirtualNetworkAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage, neededVnets: 1) ||
                     !this.ValidateTopologyARMNetworkSecurityGroupAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage, neededNSGs: 1)))
                {
                    return false;
                }

                if (entity.GetDisasterRecoveryAppGatewayDeploymentItem() == null)
                {
                    var primaryAGitem = entity.GetPrimaryAppGatewayDeploymentItem();
                    if (primaryAGitem != null &&
                        (!this.ValidateTopologyARMApplicationGatewayAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage, neededAppGates: 1)))
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Validates whether the topology has the available resources for the fail-over action.
        /// </summary>
        /// <param name="request">The deployment request.</param>
        /// <param name="failoverAction">The current action's fail-over flags.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <returns>Whether the topology was successfully validated.</returns>
        private bool ValidateTopologyForFailover(DeploymentRequest request, FailoverMetadata.Mode failoverAction, out HttpResponseMessage errorMessage)
        {
            List<TopologyInstance> ongoingTopologyInstances;

            this.GetDeployingTopologyInstances(request.TenantRegistration.TenantId, out ongoingTopologyInstances);
            if (request.Topology.ShouldUseAzureResourceManager())
            {
                errorMessage = null;
                return true;
                /*
                var armOngoingTopologies = ongoingTopologyInstances.Where(d => d.ShouldUseAzureResourceManager() && string.Equals(d.CloudServiceLocation, request.Topology.CloudServiceLocation, StringComparison.OrdinalIgnoreCase)).ToList();
                if (!this.ValidateTopologyARMResourceAvailabilityForFailover(request.TenantRegistration, request.Topology, armOngoingTopologies, failoverAction, out errorMessage))
                {
                    return false;
                }
                */
            }
            else
            {
                IServiceManagement azureProxy = null;
                AzureSubcription subscription;
                Func<IServiceManagement, AzureSubcription> getSubscription = (proxy) => proxy.GetAzureSubscription(request.TenantRegistration.AzureSubscriptionId);

                if (!this.ValidateTenantRegistrationCertificate(request.TenantRegistration, out errorMessage, out azureProxy, out subscription, getSubscription))
                {
                    return false;
                }

                var rdfeOngoingTopologies = ongoingTopologyInstances.Where(d => !d.ShouldUseAzureResourceManager()).ToList();
                if (!this.ValidateTopologyRDFEResourceAvailabilityForFailover(request.TenantRegistration, request.Topology, rdfeOngoingTopologies, failoverAction, out errorMessage))
                {
                    return false;
                }
            }

            if (failoverAction.HasFlag(FailoverMetadata.Mode.Compute) &&
                !this.ValidateTopologyDiskExistenceForFailover(request, failoverAction, out errorMessage))
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Validates whether the topology has the available resources for the fail-over action.
        /// </summary>
        /// <param name="tenantRegistration">The tenant associated with the deployment.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="failoverAction">The current action's fail-over flags.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <returns>Whether the topology was successfully validated.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "The method is can throw a variety of exceptions from here which makes being precise difficult.")]
        private bool ValidateTopologyARMResourceAvailabilityForFailover(TenantRegistration tenantRegistration, TopologyInstance entity, List<TopologyInstance> ongoingTopologyInstances, FailoverMetadata.Mode failoverAction, out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            using (var manager = tenantRegistration.CreateAzureResourceManager())
            {
                string region = entity.GetARMLocation(isDisasterRecovery: true);
                if (string.IsNullOrEmpty(region))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Topology insatnce [{0}] is missing the disaster recovery location.", entity.ToString());
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.MissingDisasterRecoveryLocation, entity.ToString());
                    return false;
                }

                IEnumerable<Microsoft.Azure.Management.Network.Models.Usage> networkUsage = null;

                try
                {
                    // This can thrown an Exception if the subscription has not deployed any ARM Elements.
                    networkUsage = manager.Network.Value.NetworkingUsage(region);
                }
                catch (CloudException ce)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' has thrown an CloudException while validating networking resources. Exception '{1}'", tenantRegistration.AzureSubscriptionId, ce);
                    return true;
                }
                catch (Exception e)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Subscription '{0}' has thrown an Exception while validating networking resources. Exception '{1}'", tenantRegistration.AzureSubscriptionId, e);
                    return false;
                }

                if (failoverAction.HasFlag(FailoverMetadata.Mode.Compute))
                {
                    if (!this.ValidateTopologyARMStaticPublicIPAddressAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage, isFailover: true))
                    {
                        return false;
                    }

                    if (!this.ValidateTopologyARMDynamicPublicIPAddressAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage, isDisasterRecovery: true))
                    {
                        return false;
                    }

                    var primaryVMs = entity.GetPrimaryVirtualMachineItems();
                    var secondaryVMs = entity.GetDisasterRecoveryVirtualMachineItems();

                    int vmsToDeploy = primaryVMs.SelectMany(d => d.Instances).Count() - secondaryVMs.SelectMany(d => d.Instances).Count();
                    int coresNeeded = this.GetNeededCoresForFailover(entity, primaryVMs);
                    if (!this.ValidateTopologyARMNetworkInterfaceAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage, vmsToDeploy) ||
                        !this.ValidateTopologyARMLoadBalancerAvailability(tenantRegistration.AzureSubscriptionId, entity, out errorMessage, ongoingTopologyInstances, networkUsage, vmsToDeploy) ||
                        !this.ValidateTopologyCoresAvailability(tenantRegistration, entity, ongoingTopologyInstances, out errorMessage, coresNeeded))
                    {
                        return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Validates the topology has available resources for the fail-over action.
        /// </summary>
        /// <param name="tenantRegistration">The tenant associated with the deployment.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="ongoingTopologyInstances">Ongoing topology instances that actively count against resources.</param>
        /// <param name="failoverAction">The current action's fail-over flags.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <returns>Whether the topology was successfully validated.</returns>
        private bool ValidateTopologyRDFEResourceAvailabilityForFailover(TenantRegistration tenantRegistration, TopologyInstance entity, List<TopologyInstance> ongoingTopologyInstances, FailoverMetadata.Mode failoverAction, out HttpResponseMessage errorMessage)
        {
            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Gets the number of needed cores for fail-over of compute layer.
        /// </summary>
        /// <param name="instance">The instance we are failing over.</param>
        /// <param name="primaryVirtualMachines">The primary virtual machines in the instance.</param>
        /// <returns>The number of cores needed.</returns>
        private int GetNeededCoresForFailover(TopologyInstance instance, IEnumerable<DeploymentItem> primaryVirtualMachines)
        {
            int coresNeeded = 0;
            foreach (var primaryVirtualMachine in primaryVirtualMachines)
            {
                string disasterRecoveryItemName;
                DeploymentItem disasterRecoveryVirtualMachine;
                if (primaryVirtualMachine.TryGetCustomizationValue(CommonCustomizationNames.DisasterRecoveryItemName, out disasterRecoveryItemName) &&
                    instance.DeploymentItems.TryGetFirst(disasterRecoveryItemName, out disasterRecoveryVirtualMachine))
                {
                    int disasterRecoveryCoresDeployed = disasterRecoveryVirtualMachine.Instances.Count * disasterRecoveryVirtualMachine.RoleSizeToCoreCount();
                    coresNeeded += primaryVirtualMachine.GetCoreCount() - disasterRecoveryCoresDeployed;
                }
            }

            return coresNeeded;
        }

        /// <summary>
        /// Validates whether the topology has the available resources for the fail-over action.
        /// </summary>
        /// <param name="request">The deployment request.</param>
        /// <param name="failoverAction">The current action's failover flags.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <returns>Whether the topology was successfully validated.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "The method is can throw a variety of exceptions from here which makes being precise difficult.")]
        private bool ValidateTopologyDiskExistenceForFailover(DeploymentRequest request, FailoverMetadata.Mode failoverAction, out HttpResponseMessage errorMessage)
        {
            List<Catalog.Model.Disk> disasterRecoveryDisks = new List<Catalog.Model.Disk>();

            List<DeploymentItem> virtualMachineDeploymentInstances = request.Topology.GetPrimaryVirtualMachineItems().ToList();
            foreach (var virtualMachineDeploymentInstance in virtualMachineDeploymentInstances)
            {
                List<Catalog.Model.Disk> disks = virtualMachineDeploymentInstance.Instances.SelectMany(i => i.Disks).ToList();

                string managedDiskType;
                if (virtualMachineDeploymentInstance.TryGetCustomizationValue<string>(CommonCustomizationNames.ManagedDiskType, out managedDiskType) &&
                    !String.IsNullOrWhiteSpace(managedDiskType) &&
                    !managedDiskType.Equals("None", StringComparison.OrdinalIgnoreCase))
                {
                    string vhdStorageAccountName = virtualMachineDeploymentInstance.GetCustomizationValue(CommonCustomizationNames.VHDStorageAccountName);
                    disasterRecoveryDisks.AddRange(disks.Select(d => d.CreateDisasterRecoveryManagedDisk(request.TenantRegistration, vhdStorageAccountName, request.Topology.ARM.ResourceGroupName, Library.Constants.DisasterRecoveryFailoverVHDStorageContainer)));
                }
                else
                {
                    disasterRecoveryDisks.AddRange(disks.Select(d => d.CreateDisasterRecoveryDisk(request.TenantRegistration, Library.Constants.DisasterRecoveryFailoverVHDStorageContainer)));
                }
            }

            foreach (var storageAccountGroup in disasterRecoveryDisks.GroupBy(d => BlobHelper.GetBlobStorageAccountName(new Uri(d.SourceVhdUri))))
            {
                string storageAccountName = storageAccountGroup.Key;
                var storageAccount = request.Topology.ShouldUseAzureResourceManager()
                    ? request.GetARMStorageAccount(storageAccountName, isDisasterRecovery: true)
                    : TenantRegistrationExtensions.GetStorageAccount(request.TenantRegistration.AzureSubscriptionId, request.TenantRegistration.GetManagementCertificate(), storageAccountName);

                var client = storageAccount.CreateCloudBlobClient();
                var container = client.GetContainerReference(Library.Constants.DisasterRecoveryFailoverVHDStorageContainer);
                if (!container.Exists())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Container [{0}] does not exist in storage account [{1}].", container.Name, storageAccountName);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.FailoverBackupVHDContainerDoesNotExist, container.Name, storageAccountName);
                    return false;
                }

                foreach (var disk in storageAccountGroup.AsEnumerable())
                {
                    string diskName = BlobHelper.GetBlobName(new Uri(disk.SourceVhdUri));
                    var blob = container.GetPageBlobReference(diskName);
                    if (!blob.Exists())
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Did not find blob [{0}] in container [{1}] in storage account [{2}].", diskName, container.Name, storageAccountName);
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.FailoverBackupVHDDoesNotExist, diskName, container.Name, storageAccountName);
                        return false;
                    }
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validate availability of reserved IP DNS names.
        /// </summary>
        /// <param name="tenantRegistration">The tenant associated with the deployment.</param>
        /// <param name="entity">The incoming topology instance to be considered.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be effected, if any.</param>
        /// <returns>Whether the topology was successfully validated.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "The method is can throw a variety of exceptions from here which makes being precise difficult.")]
        [SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "Using lowercase to normalize Azure case-sensitivity, not globalization purposes.")]
        private bool ValidateAvailabilityOfReservedIPDNSNames(TenantRegistration tenantRegistration, TopologyInstance entity, out HttpResponseMessage errorMessage)
        {
            errorMessage = null;
            string location = entity.GetARMLocation();
            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Start to validate availability of reserved IP DNS names in the location [{0}]. Topology [{1}] Id [{2}].", location, entity.TopologyName, entity.InstanceId);

            List<string> reservedIPIdentifiers = entity.ReservedIPs.Select(rip => rip.Identifier).ToList();

            if (!reservedIPIdentifiers.Any())
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "There are not any reserved IP identifiers in topology [{0}] Id [{1}] for validation. Skipping validation.", entity.TopologyName, entity.InstanceId);
                return true;
            }

            List<string> reservedIpDnsNames = new List<string>();
            foreach (var identifier in reservedIPIdentifiers)
            {
                reservedIpDnsNames.Add(String.Format(CultureInfo.InvariantCulture, "{0}{1}", entity.ARM.ResourceGroupName, identifier).ToLowerInvariant());
            }

            using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager())
            {
                foreach (var reservedIpDnsName in reservedIpDnsNames)
                {
                    var dnsNameAvailabilityTask = manager.Network.Value.Proxy.CheckDnsNameAvailabilityWithHttpMessagesAsync(location, reservedIpDnsName);

                    try
                    {
                        dnsNameAvailabilityTask.Wait(TimeSpan.FromSeconds(60));

                        if (dnsNameAvailabilityTask.Result.Response.StatusCode != HttpStatusCode.OK)
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Could not check availability of DNS name [{0}]. Server response: [{1}].", reservedIpDnsName, dnsNameAvailabilityTask.Result.Response);
                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.CheckingDNSNameAvailabilityFailed, reservedIpDnsName);
                            return false;
                        }

                        if (dnsNameAvailabilityTask.Result.Body.Available.HasValue && !dnsNameAvailabilityTask.Result.Body.Available.Value)
                        {
                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.DnsNameAlreadyExists);
                            return false;
                        }

                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "DNS name [{0}] is available in the location [{1}].", reservedIpDnsName, location);
                    }
                    catch (Exception ex)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Exception is occurred during validation availability of reserved IP DNS names. Exception [{0}].", ex);
                        errorMessage = this.CreateErrorResponse(ServiceErrorCode.CheckingDNSNameAvailabilityFailed, reservedIpDnsName);
                        return false;
                    }
                }
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "All reserved IP DNS names are available in the location [{0}]. Topology [{1}] Id [{2}].", location, entity.TopologyName, entity.InstanceId);
            return true;
        }

        /// <summary>
        /// Process topology for staging deployment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription where the topology will be deployed.</param>
        /// <param name="topologyInstance">The incoming topology instance to be considered.</param>
        /// <param name="tenantRegistration">The tenant registration.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be processed, if any.</param>
        /// <returns>Whether the topology processing was successful.</returns>
        [SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase", Justification = "Using lowercase to normalize Azure case-sensitivity, not globalization purposes.")]
        private bool ProcessStagingDeployment(Guid tenantId, Guid azureSubscriptionId, TopologyInstance topologyInstance, TenantRegistration tenantRegistration, out HttpResponseMessage errorMessage)
        {
            errorMessage = null;
            if (topologyInstance == null || topologyInstance.EnvironmentGroup != EnvironmentGroup.Staging)
            {
                return true;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Start processing a staging deployment for topology name [{0}], topology Id [{1}].", topologyInstance.TopologyName, topologyInstance.InstanceId);

            // Retrieve the source topology, that is the primary environment for the same instance id.
            TopologyInstanceTableItem primaryTopologyInstanceRow;
            TopologyInstance primaryTopology;
            if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstance.InstanceId, EnvironmentGroup.Primary, out primaryTopology, out errorMessage, out primaryTopologyInstanceRow))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Cannot find the Primary environment for topology instance [{0}].", topologyInstance.InstanceId);
                return false;
            }

            // check the state of the primary deployment - fail the request if primary is not in a completed state.
            DeploymentInstance primaryDeploymentInstance;
            Uri deploymentInstanceBlobUri;
            if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstance.InstanceId, primaryTopologyInstanceRow, EnvironmentGroup.Primary, out primaryDeploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Cannot find the deployment instance, Primary environment for topology instance [{0}].", topologyInstance.InstanceId);
                return false;
            }

            if (primaryDeploymentInstance.DeploymentState != DeploymentState.Finished)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Deployment action on Primary environment for topology instance [{0}] must be completed before attempting a staging deployment.", topologyInstance.InstanceId);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_StagingRequiresFinishedState);
                return false;
            }

            // check also if a staging environment already exists.
            TopologyInstanceTableItem stagingTopologyInstanceRow;
            TopologyInstance stagingTopology;
            if (this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstance.InstanceId, EnvironmentGroup.Staging, out stagingTopology, out errorMessage, out stagingTopologyInstanceRow))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Topology instance [{0}] already has a staging environment.", topologyInstance.InstanceId);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_StagingAlreadyExists, topologyInstance.InstanceId);
                return false;
            }

            // validate upgrade metadata.
            TopologyUpgradeMetadata upgradeMetadata = EnvironmentHelper.GetTopologyUpgradeMetadata();
            if (upgradeMetadata == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Upgrade metadata is missing in this environment.");
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.Staging_UpgradeMetadataNotFound);
                return false;
            }

            // Verify if the upgrade metadata allows staging upgrade for this topology name, and if it matches the name of the topology coming in.
            TopologyUpgradeMetadata.TopologyMapping topologyMapping = upgradeMetadata.TopologyMappings.FirstOrDefault(m => String.Equals(m.TopologyName, primaryTopology.TopologyName, StringComparison.OrdinalIgnoreCase));
            if (topologyMapping == null || !topologyMapping.AllowedUpgrades.Contains(topologyInstance.TopologyName, StringComparer.OrdinalIgnoreCase))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "There is no upgrade metadata from topology name [{0}] to topology name [{1}].", primaryTopology.TopologyName, topologyInstance.TopologyName);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.Staging_UpgradeMetadataTopologyMappingNotFound, primaryTopology.TopologyName, topologyInstance.TopologyName);
                return false;
            }

            if (FeatureConfiguration.ServicingConfiguration.HasDatabaseUpgradeApplicationVersionCheck(tenantRegistration)
                && this.ValidateApplicationVersionExistsForAxDatabaseUpgrade(tenantRegistration, primaryTopology) == false)
            {
                throw new ServiceException(ServiceErrorCode.OperationNotAllowed_ApplicationVersionNotFound);
            }

            // Moved from the PopulateUpgradeTopology() function to here since the TryProcessElasticPoolSettings() require this.
            topologyInstance.CloudServiceLocation = primaryTopology.CloudServiceLocation;
            topologyInstance.CloudStorageLocation = primaryTopology.CloudStorageLocation;
            topologyInstance.DisasterRecoveryLocation = primaryTopology.DisasterRecoveryLocation;

            // Reconcile missing Elastic Pool Customizations.
            this.ReconcileElasticDatabaseCustomization(primaryTopology, topologyInstance);

            // Need to process elastic pool settings here for staging so that the credentials are copied over correctly.
            if (!this.TryProcessElasticPoolSettings(topologyInstance, out errorMessage))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "There was an error processing the elastic pool settings for [{0}] to topology name [{1}].", topologyInstance.TopologyName);
                return false;
            }

            // call helper to copy the necessary data from the primary topology.
            topologyInstance.PopulateUpgradeTopology(primaryTopology, upgradeMetadata, tenantId);

            // set resource group for staging - toggle between instanceId -a and -b.
            if (topologyInstance.ShouldUseAzureResourceManager())
            {
                string stagingResourceGroup = string.Concat(topologyInstance.InstanceId, "-b").ToLowerInvariant();
                if (primaryTopology.ShouldUseAzureResourceManager() && String.Equals(stagingResourceGroup, primaryTopology.ARM.ResourceGroupName, StringComparison.OrdinalIgnoreCase))
                {
                    stagingResourceGroup = string.Concat(topologyInstance.InstanceId, "-a").ToLowerInvariant();
                }

                topologyInstance.ARM.ResourceGroupName = stagingResourceGroup;
            }

            // Skip LCSDiagnostics during deployment, will be reenabled at the end of SwapCommit
            DeploymentComponent lcsDiagnostics = topologyInstance.DeploymentComponents.FirstOrDefault(dc => string.Equals(dc.Identifier, DeploymentConstants.LCSDiagnosticsComponentName, StringComparison.OrdinalIgnoreCase));
            if (lcsDiagnostics == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "No component found with symbolic name [{0}] for LCS diagnostics.", DeploymentConstants.LCSDiagnosticsComponentName);
            }
            else
            {
                SetupScript installLCSDiagnosticsScript = lcsDiagnostics.ScriptReferences.FirstOrDefault(sr => string.Equals(sr.Identifier, DeploymentConstants.LCSDiagnosticsScriptId, StringComparison.OrdinalIgnoreCase));
                if (installLCSDiagnosticsScript == null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Component [{0}] for LCS diagnostics does not contain a script reference [{1}].", DeploymentConstants.LCSDiagnosticsComponentName, DeploymentConstants.LCSDiagnosticsScriptId);
                }
                else
                {
                    installLCSDiagnosticsScript.RunOnDemandOnly = true;
                }
            }

            Tracer.WriteExecutionEvent(
                TraceComponent.DeploymentServiceApi,
                "Successfully applied upgrade rules for topology instance [{0}], upgrading from [{1}] to [{2}].",
                topologyInstance.InstanceId,
                primaryTopology.TopologyName,
                topologyInstance.TopologyName);

            return true;
        }

        /// <summary>
        /// Processes the parameters for rotate secrets and updates the secret rotation information in the topology.
        /// </summary>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="secretTypesToRotate">The secret rotation types.</param>
        /// <param name="errorMessage">The error message, if any.</param>
        /// <returns>Whether processing for secret parameters was successful.</returns>
        private bool ProcessRotateSecretsParameters(TopologyInstance topologyInstance, SecretRotationMetadata.Types secretTypesToRotate, out HttpResponseMessage errorMessage)
        {
            if (secretTypesToRotate.HasFlag(SecretRotationMetadata.Types.AADCertificate) && !secretTypesToRotate.HasFlag(SecretRotationMetadata.Types.Certificates))
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Rotation of secret type [{0}] must be done in conjunction with rotation of secret type [{1}].",
                    SecretRotationMetadata.Types.AADCertificate,
                    SecretRotationMetadata.Types.Certificates);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.RotateSecrets_MissingDependentFlag, SecretRotationMetadata.Types.AADCertificate, SecretRotationMetadata.Types.Certificates);
                return false;
            }

            // process secret metadata
            foreach (var secretType in secretTypesToRotate.GetFlags().Cast<SecretRotationMetadata.Types>())
            {
                var secretMetadata = topologyInstance.SecretRotationsMetadata.FirstOrDefault(m => secretType.StringEquals(m.SecretType));
                if (secretMetadata == null)
                {
                    secretMetadata = new SecretRotationMetadata(secretType);
                    topologyInstance.SecretRotationsMetadata.Add(secretMetadata);
                }

                secretMetadata.Status = SecretRotationMetadata.RotationStatus.Queued.ToString();
                secretMetadata.LastAttemptedRotationStarted = DateTime.UtcNow;
                secretMetadata.LastActivityId = Tracer.GetCorrelationActivityId();
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Processes the parameters for rotate secrets and updates the secret rotation information in the topology.
        /// </summary>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="axServiceToRotate">The service to restart types.</param>
        /// <param name="errorMessage">The error message, if any.</param>
        /// <returns>Whether processing for secret parameters was successful.</returns>
        private bool ProcessRestartParameters(TopologyInstance topologyInstance, RestartServiceMetadata.AXService axServiceToRotate, out HttpResponseMessage errorMessage)
        {
            var restartServiceMetadata = topologyInstance.RestartServiceMetadata.FirstOrDefault(m => axServiceToRotate == m.AXServiceType);
            if (restartServiceMetadata == null)
            {
                restartServiceMetadata = new RestartServiceMetadata(axServiceToRotate);
                topologyInstance.RestartServiceMetadata.Add(restartServiceMetadata);
            }

            restartServiceMetadata.Status = SecretRotationMetadata.RotationStatus.Queued.ToString();
            restartServiceMetadata.LastAttemptedRestartStarted = DateTime.UtcNow;
            restartServiceMetadata.LastActivityId = Tracer.GetCorrelationActivityId();
            restartServiceMetadata.ErrorMessages = null;

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Processes the parameters for creating JIT account.
        /// </summary>
        /// <param name="topologyInstance">The instance to process.</param>
        /// <param name="accountName">The accountname we will be creating a JIT account for.</param>
        /// <param name="errorMessage">The error message, if any.</param>
        /// <returns>Whether processing for secret parameters was successful.</returns>
        private bool ProcessCreateJITAccountParameters(TopologyInstance topologyInstance, string accountName, out HttpResponseMessage errorMessage)
        {
            if (string.IsNullOrWhiteSpace(accountName))
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Parameter 'accountName' is null or whitespace.");
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.MissingJITUserAccountNameParameter);
                return false;
            }

            RE.Regex accountNameRegex = new RE.Regex(AccountNameRegEx);
            if (!accountNameRegex.IsMatch(accountName))
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Account name '{0}' did not match the regex {1}",
                    accountName,
                    AccountNameRegEx);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.InvalidJITUserAccountName, accountName);
                return false;
            }

            foreach (Credential credential in topologyInstance.DeploymentItems.SelectMany(di => di.Credentials))
            {
                if (string.Equals(accountName, credential.UserName, StringComparison.OrdinalIgnoreCase))
                {
                    Tracer.WriteExecutionEvent(
                        TraceComponent.DeploymentServiceApi,
                        "Account name '{0}' is unallowed!",
                        accountName);
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.DisallowedJITUserAccountNameParameter, accountName);
                    return false;
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Resolves the JIT credential in the topology instance.
        /// </summary>
        /// <param name="instance">The instance to resolve.</param>
        /// <param name="accountName">The name of the credential to resolve into the instance.</param>
        /// <param name="operationsInstance">The operations instance possibly holding the credential.</param>
        private void ResolveJITCredential(TopologyInstance instance, string accountName, OperationsInstance operationsInstance)
        {
            Credential jitCredential = operationsInstance.JITCredentials.FirstOrDefault(c => string.Equals(c.UserName, accountName, StringComparison.OrdinalIgnoreCase));
            if (jitCredential == null)
            {
                jitCredential = new Credential()
                {
                    UserName = accountName,
                    Domain = Credential.LocalUserDomain,
                    ExpirationDate = DateTime.UtcNow,
                };
            }
            else if (jitCredential.ExpirationDate.HasValue && jitCredential.ExpirationDate.Value < DateTime.UtcNow)
            {
                // for user experience, blank out expired passwords
                jitCredential.KeyVaultablePassword = new KeyVaultable<string>();
            }
            else
            {
                KeyVaultClient.Instance.GetSecret(jitCredential.KeyVaultablePassword);
                jitCredential.KeyVaultablePassword.SerializeRawValue = true;
            }

            foreach (DeploymentItem virtualMachine in instance.GetVirtualMachines())
            {
                if (DeploymentServiceConfig.JITAccountFlowHideOtherCredentials)
                {
                    foreach (Credential credential in virtualMachine.Credentials)
                    {
                        credential.IsVisible = false;
                    }
                }
                else
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "JITAccountFlowHideOtherCredentials is set to false, preserving the default visibility of other VM accounts.");
                }

                virtualMachine.Credentials.Add(jitCredential);
            }
        }

        /// <summary>
        /// Gets a model NSG object that contains all the customer rules from ARM.
        /// </summary>
        /// <param name="manager">The manager to communicate with Azure.</param>
        /// <param name="topologyInstance">The topology instance that contains the NSG.</param>
        /// <param name="nsgWithCustomerRules">The model NSG object populated with customer rules from Azure.</param>
        /// <param name="error">The error, if any.</param>
        /// <returns>Whether we were able to fetch the rules successfully.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Must be robust.")]
        private bool TryGetCustomerNSGRulesFromAzureARM(AzureResourceManager manager, TopologyInstance topologyInstance, out Library.Model.NetworkSecurityGroup nsgWithCustomerRules, out HttpResponseMessage error)
        {
            if (!this.TryGetNSGRulesFromAzureARM(manager, topologyInstance, out nsgWithCustomerRules, out error))
            {
                nsgWithCustomerRules = null;
                return false;
            }

            nsgWithCustomerRules.Rules = nsgWithCustomerRules.Rules.Where(r => r.IsCustomerRule).ToList();

            error = null;
            return true;
        }

        /// <summary>
        /// Gets a model NSG object that contains all the rules from ARM.
        /// </summary>
        /// <param name="manager">The manager to communicate with Azure.</param>
        /// <param name="topologyInstance">The topology instance that contains the NSG.</param>
        /// <param name="nsg">The model NSG object populated with customer rules from Azure.</param>
        /// <param name="error">The error, if any.</param>
        /// <returns>Whether we were able to fetch the rules successfully.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Must be robust.")]
        private bool TryGetNSGRulesFromAzureARM(AzureResourceManager manager, TopologyInstance topologyInstance, out Library.Model.NetworkSecurityGroup nsg, out HttpResponseMessage error)
        {
            string azureNSGResourceGroup;
            Azure.Management.Network.Models.NetworkSecurityGroup azureNSG;
            if (!ARMHelper.TryGetNetworkSecurityGroup(manager, topologyInstance, out azureNSG, out azureNSGResourceGroup))
            {
                error = this.CreateErrorResponse(ServiceErrorCode.NetworkSecurityGroup_FailedToRetrieveFromAzure);
                nsg = null;
                return false;
            }

            nsg = new Library.Model.NetworkSecurityGroup(topologyInstance.NetworkSecurityGroup.Name);
            foreach (SecurityRule rule in azureNSG.SecurityRules)
            {
                Library.Model.NetworkSecurityGroup.Rule modelEquivalent = rule.ToModelRule();
                nsg.Rules.Add(modelEquivalent);
            }

            error = null;
            return true;
        }

        /// <summary>
        /// Gets a model NSG object containing customer rules from Azure RDFE.
        /// </summary>
        /// <param name="management">The service managment used to call Azure.</param>
        /// <param name="request">The request.</param>
        /// <param name="nsgWithCustomerRules">The model NSG object populated with customer rules.</param>
        /// <param name="error">The error, if any.</param>
        /// <returns>Whether we were able to populate the rules successfully.</returns>
        private bool TryGetCustomerNSGRulesFromAzureRDFE(IServiceManagement management, DeploymentRequest request, out Library.Model.NetworkSecurityGroup nsgWithCustomerRules, out HttpResponseMessage error)
        {
            if (!this.TryGetNSGRulesFromAzureRDFE(management, request, out nsgWithCustomerRules, out error))
            {
                nsgWithCustomerRules = null;
                return false;
            }

            nsgWithCustomerRules.Rules = nsgWithCustomerRules.Rules.Where(r => r.IsCustomerRule).ToList();

            error = null;
            return true;
        }

        /// <summary>
        /// Gets a model NSG object containing rules from Azure RDFE.
        /// </summary>
        /// <param name="management">The service managment used to call Azure.</param>
        /// <param name="request">The request.</param>
        /// <param name="nsgWithAzureRules">The network security group customer rules.</param>
        /// <param name="error">The error, if any.</param>
        /// <returns>Whether we were able to populate the rules successfully.</returns>
        private bool TryGetNSGRulesFromAzureRDFE(IServiceManagement management, DeploymentRequest request, out Library.Model.NetworkSecurityGroup nsgWithAzureRules, out HttpResponseMessage error)
        {
            var controllerFactory = new DeploymentTopologyControllerFactory(request);
            NetworkSecurityGroupDeploymentController networkSecurityGroupController = controllerFactory.GetNetworkSecurityGroupDeploymentController();
            if (networkSecurityGroupController == null)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Failed to create network security group controller.");
                error = this.CreateErrorResponse(ServiceErrorCode.NetworkSecurityGroup_FailedToRetrieveFromAzure);
                nsgWithAzureRules = null;
                return false;
            }

            ServiceManagement.NetworkSecurityGroup azureNSG;
            if (!networkSecurityGroupController.TryGetNetworkSecurityGroup(out azureNSG))
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Failed to retrieve RDFE network security group [{0}].", networkSecurityGroupController.NetworkSecurityGroupName);
                error = this.CreateErrorResponse(ServiceErrorCode.NetworkSecurityGroup_FailedToRetrieveFromAzure);
                nsgWithAzureRules = null;
                return false;
            }

            nsgWithAzureRules = new Library.Model.NetworkSecurityGroup(azureNSG.Name);
            nsgWithAzureRules.Rules = azureNSG.Rules.Where(r => !r.IsDefault).Select(r => r.ToModelRule()).ToList();
            error = null;
            return true;
        }

        /// <summary>
        /// Validates the update NSG parameter to see if its values are valid.
        /// </summary>
        /// <param name="networkSecurityGroup">The NSG parameter, whose rules we will soon upsert to Azure.</param>
        /// <param name="error">The error, if any.</param>
        /// <param name="allowAllInternetIP">If true, succeeds validation for * IP address. Default is false.</param>
        /// <returns>Whether we successfully validated.</returns>
        private bool TryValidateUpdateNSGParameter(Library.Model.NetworkSecurityGroup networkSecurityGroup, out HttpResponseMessage error, bool allowAllInternetIP = false)
        {
            if (string.IsNullOrWhiteSpace(networkSecurityGroup.Name))
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Network security group does not have name populated!");
                error = this.CreateErrorResponse(ServiceErrorCode.NetworkSecurityGroup_UpdateNSGParameterMissingName);
                return false;
            }

            if (networkSecurityGroup.Rules.Select(r => r.Name).Distinct().Count() != networkSecurityGroup.Rules.Count())
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Network security group parameter [{0}] has multiple rules with the same name, returning error.", networkSecurityGroup.Name);
                error = this.CreateErrorResponse(ServiceErrorCode.NetworkSecurityGroup_UpdateNSGParameterDuplicateName);
                return false;
            }

            foreach (var customerRule in networkSecurityGroup.Rules)
            {
                if (!customerRule.IsCustomerRule ||
                    customerRule.Name == null ||
                    !customerRule.Name.StartsWith(Library.Model.NetworkSecurityGroup.CustomerRulePrefix, StringComparison.OrdinalIgnoreCase))
                {
                    Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Received rule [{0}] that does not properly conform to customer rule requirements.", customerRule);
                    error = this.CreateErrorResponse(ServiceErrorCode.NetworkSecurityGroup_FailedToValidateRule, customerRule.Name, "Received rule that is not tagged as a customer rule");
                    return false;
                }
            }

            if (this.HasInvalidNsgRules(networkSecurityGroup, out error, allowAllInternetIP))
            {
                return false;
            }

            error = null;
            return true;
        }

        /// <summary>
        /// Validates that the rules in the Client NSG are of Customer type.
        /// </summary>
        /// <param name="networkSecurityGroup">The network security group to be validated.</param>
        /// <param name="error">The error.</param>
        /// <returns>True if validation succeeded, false otherwise.</returns>
        private bool TryValidateClientNSGCustomerRules(NetworkSecurityGroupClientModel networkSecurityGroup, out HttpResponseMessage error)
        {
            foreach (var customerRule in networkSecurityGroup.Rules)
            {
                if (!customerRule.IsCustomerRule)
                {
                    Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Received rule [{0}] that does not properly conform to customer rule requirements.", customerRule);
                    error = this.CreateErrorResponse(ServiceErrorCode.NetworkSecurityGroup_FailedToValidateRule, customerRule.Name, "Received rule that is not tagged as a customer rule");
                    return false;
                }
            }

            error = null;
            return true;
        }

        /// <summary>
        /// Validate if Https Nsg rule is in lockdown state.
        /// </summary>
        /// <param name="entity">The topology instance.</param>
        /// <param name="tenantRegistration">The tenant registration.</param>
        /// <param name="isLockdown">The count of the port.</param>
        /// <param name="error">The error.</param>
        /// <returns>True if validation succeeded, false otherwise.</returns>
        private bool TryValidateHttpsNSGRule(TopologyInstance entity, TenantRegistration tenantRegistration, out bool isLockdown, out HttpResponseMessage error)
        {
            Library.Model.NetworkSecurityGroup nsgRules = null;
            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Getting NSG rules from ARM");
            using (var manager = tenantRegistration.CreateAzureResourceManager(entity.ARM.ResourceGroupName))
            {
                if (!this.TryGetNSGRulesFromAzureARM(manager, entity, out nsgRules, out error))
                {
                    isLockdown = false;
                    return false;
                }
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Sucessfully fetched NSG rules from ARM.");
            string nsgRulePort = Library.Constants.Https1RulePort;

            var IsPortExists = new Func<string, bool>(port =>
            {
                bool isPortExists = false;
                if (string.IsNullOrEmpty(port))
                {
                    return isPortExists;
                }

                if (port.IndexOf("-") > -1)
                {
                    int[] splittedPortsWithDash = port.Split('-').Select(i => Convert.ToInt32(i)).ToArray();
                    var nsgRulePortInt = Convert.ToInt32(nsgRulePort);
                    if (splittedPortsWithDash[0] <= nsgRulePortInt && splittedPortsWithDash[1] >= nsgRulePortInt)
                    {
                        isPortExists = true;
                    }
                }
                else if (port == nsgRulePort)
                {
                    isPortExists = true;
                }
                return isPortExists;
            });

            var deniedInternetRules = nsgRules.Rules.Where(r => (r.SourceAddressPrefix == "Internet" || r.SourceAddressPrefix == "*")
                                        && r.Access == "Deny").ToList();
            bool isDenied = false;
            foreach (var rule in deniedInternetRules)
            {
                var destinationPortRanges = rule.DestinationPortRanges;
                if (destinationPortRanges.Count() > 0)
                {
                    isDenied = destinationPortRanges.Any(b => IsPortExists(b));
                }
                else
                {
                    isDenied = IsPortExists(rule.DestinationPortRange);
                }

                if (isDenied)
                {
                    break;
                }
            }
            isLockdown = isDenied;
            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Validation for Https NSG rule is completed.");
            return true;
        }

        /// <summary>
        /// Validates the Client NSG that that is to be updated.
        /// </summary>
        /// <param name="networkSecurityGroup">The network security group to be validated.</param>
        /// <param name="error">The error.</param>
        /// <returns>True if validation succeeded, false otherwise.</returns>
        private bool TryValidateUpdateClientNsgParameter(NetworkSecurityGroupClientModel networkSecurityGroup, out HttpResponseMessage error)
        {
            IEnumerable<string> ruleNames = networkSecurityGroup.Rules.Select(r =>
            {
                string ruleName = r.Name.StartsWith(Library.Model.NetworkSecurityGroup.CustomerRulePrefix, StringComparison.OrdinalIgnoreCase)
                                ? r.Name.Substring(Library.Model.NetworkSecurityGroup.CustomerRulePrefix.Length)
                                : r.Name;
                return ruleName;
            });

            // Validate rule name isn't empty
            if (ruleNames.Where(n => string.IsNullOrWhiteSpace(n)).Any())
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Received rule [{0}] that does not properly conform to rule name requirements.", string.Empty);
                error = this.CreateErrorResponse(ServiceErrorCode.NetworkSecurityGroup_FailedToValidateRule, string.Empty, "Received rule that has no name.");
                return false;
            }

            // Validate that there are no duplicate rule names
            if (ruleNames.Distinct().Count() != networkSecurityGroup.Rules.Count())
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Network security group parameter [{0}] has multiple rules with the same name, returning error.", networkSecurityGroup.Name);
                error = this.CreateErrorResponse(ServiceErrorCode.NetworkSecurityGroup_UpdateNSGParameterDuplicateName);
                return false;
            }

            if (this.HasInvalidNsgRules(networkSecurityGroup.Rules, out error))
            {
                return false;
            }

            error = null;
            return true;
        }

        /// <summary>
        /// Determines whether the rules' IP/CIDR and CIDR ranges, if any, are valid.
        /// </summary>
        /// <param name="nsg">The network security group.</param>
        /// <param name="error">The error, if any.</param>
        /// <param name="allowAllInternetIP">If true, succeeds validation for * IP address.</param>
        /// <returns>True if at least one rule is invalid.</returns>
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "String passed in so as to concatenate the error messages.")]
        private bool HasInvalidNsgRules(Library.Model.NetworkSecurityGroup nsg, out HttpResponseMessage error, bool allowAllInternetIP = false)
        {
            List<string> invalidBaseIpRules = new List<string>();
            List<string> invalidIpRangeRules = new List<string>();
            foreach (Library.Model.NetworkSecurityGroup.Rule rule in nsg.Rules)
            {
                if (allowAllInternetIP && rule.SourceAddressPrefix.Equals("*"))
                {
                    continue;
                }

                ServiceErrorCode serviceError;
                if (!NetworkSecurityGroupExtensions.IsNsgRuleIpFormatValid(rule.SourceAddressPrefix, out serviceError))
                {
                    if (serviceError.Equals(ServiceErrorCode.NetworkSecurityGroup_InvalidAddressPrefix))
                    {
                        invalidBaseIpRules.Add(rule.Name.Substring(Library.Model.NetworkSecurityGroup.CustomerRulePrefix.Length));
                    }
                    else if (serviceError.Equals(ServiceErrorCode.NetworkSecurityGroup_InvalidAddressRange))
                    {
                        invalidIpRangeRules.Add(rule.Name.Substring(Library.Model.NetworkSecurityGroup.CustomerRulePrefix.Length));
                    }
                }
            }

            bool hasInvalidBaseIpRules = invalidBaseIpRules.Count() > 0;
            bool hasInvalidIpRangeRules = invalidIpRangeRules.Count() > 0;

            if (hasInvalidBaseIpRules || hasInvalidIpRangeRules)
            {
                string errorResponseMessage = string.Empty;
                string invalidBaseIpRuleNames = string.Join(", ", invalidBaseIpRules.ToArray());
                string invalidIpRangeRuleNames = string.Join(", ", invalidIpRangeRules.ToArray());

                if (hasInvalidBaseIpRules)
                {
                    DeploymentError invalidBaseError = new DeploymentError(ServiceErrorCode.NetworkSecurityGroup_InvalidBaseIpRules, null, invalidBaseIpRuleNames);
                    errorResponseMessage += invalidBaseError.ResolveMessage();
                }

                if (hasInvalidIpRangeRules)
                {
                    DeploymentError invalidRangeError = new DeploymentError(ServiceErrorCode.NetworkSecurityGroup_InvalidIpRangeRules, null, invalidIpRangeRuleNames);
                    errorResponseMessage += " " + invalidRangeError.ResolveMessage();
                }

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, errorResponseMessage);
                error = this.CreateErrorResponse(errorResponseMessage);

                return true;
            }

            error = null;
            return false;
        }

        /// <summary>
        /// Determines whether the rules' IP/CIDR and CIDR ranges, if any, are valid.
        /// </summary>
        /// <param name="clientRules">The client NSG rules.</param>
        /// <param name="error">The error, if any.</param>
        /// <returns>True if at least one rule is invalid.</returns>
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters", Justification = "String passed in so as to concatenate the error messages.")]
        private bool HasInvalidNsgRules(List<NetworkSecurityGroupClientModel.ClientRule> clientRules, out HttpResponseMessage error)
        {
            List<string> invalidBaseIpRules = new List<string>();
            List<string> invalidIpRangeRules = new List<string>();
            foreach (Library.Model.NetworkSecurityGroupClientModel.ClientRule rule in clientRules)
            {
                ServiceErrorCode serviceError;
                if (rule.Service.Equals(EnvironmentNetworkSecurityRuleService.AzureSQL.ToString(), StringComparison.OrdinalIgnoreCase))
                {
                    // SQL Firewall rules can only be in IPv4 format
                    if (!NetworkSecurityGroupExtensions.IsIPv4(rule.IpOrCidr))
                    {
                        invalidBaseIpRules.Add(rule.Name.Substring(Library.Model.NetworkSecurityGroup.CustomerRulePrefix.Length));
                    }
                }

                if (!NetworkSecurityGroupExtensions.IsNsgRuleIpFormatValid(rule.IpOrCidr, out serviceError))
                {
                    if (serviceError.Equals(ServiceErrorCode.NetworkSecurityGroup_InvalidAddressPrefix))
                    {
                        invalidBaseIpRules.Add(rule.Name.Substring(Library.Model.NetworkSecurityGroup.CustomerRulePrefix.Length));
                    }
                    else if (serviceError.Equals(ServiceErrorCode.NetworkSecurityGroup_InvalidAddressRange))
                    {
                        invalidIpRangeRules.Add(rule.Name.Substring(Library.Model.NetworkSecurityGroup.CustomerRulePrefix.Length));
                    }
                }
            }

            bool hasInvalidBaseIpRules = invalidBaseIpRules.Count() > 0;
            bool hasInvalidIpRangeRules = invalidIpRangeRules.Count() > 0;

            if (hasInvalidBaseIpRules || hasInvalidIpRangeRules)
            {
                string errorResponseMessage = string.Empty;
                string invalidBaseIpRuleNames = string.Join(", ", invalidBaseIpRules.ToArray());
                string invalidIpRangeRuleNames = string.Join(", ", invalidIpRangeRules.ToArray());

                if (hasInvalidBaseIpRules)
                {
                    DeploymentError invalidBaseError = new DeploymentError(ServiceErrorCode.NetworkSecurityGroup_InvalidBaseIpRules, null, invalidBaseIpRuleNames);
                    errorResponseMessage += invalidBaseError.ResolveMessage();
                }

                if (hasInvalidIpRangeRules)
                {
                    DeploymentError invalidRangeError = new DeploymentError(ServiceErrorCode.NetworkSecurityGroup_InvalidIpRangeRules, null, invalidIpRangeRuleNames);
                    errorResponseMessage += " " + invalidRangeError.ResolveMessage();
                }

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, errorResponseMessage);
                error = this.CreateErrorResponse(errorResponseMessage);

                return true;
            }

            error = null;
            return false;
        }

        /// <summary>
        /// Updates the rules in Azure with that which is in the topology.
        /// </summary>
        /// <param name="manager">The manager to communicate with Azure.</param>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="nsgWithCustomerRules">The NSG object that contains the customer rules to update.</param>
        /// <param name="error">The error, if any.</param>
        /// <returns>Whether we were able to fetch the rules successfully.</returns>
        private bool TryUpdateCustomerARMNSGSecurityRules(AzureResourceManager manager, TopologyInstance topologyInstance, Library.Model.NetworkSecurityGroup nsgWithCustomerRules, out HttpResponseMessage error)
        {
            try
            {
                ARMHelper.UpdateCustomerNetworkSecurityGroupRules(manager, topologyInstance, nsgWithCustomerRules.Rules);
            }
            catch (ServiceException ex)
            {
                error = this.CreateErrorResponse(ex);
                return false;
            }

            error = null;
            return true;
        }

        /// <summary>
        /// Reconciles Primary and Seconday Elastic Pool Customizations so that
        /// if the parameter didn't exist in the previous topology to disable it in the new topology.
        /// </summary>
        /// <param name="primaryTopology">The Primary TopologyInstance object.</param>
        /// <param name="stagingTopology">The Secondary TopologyInstance object.</param>
        private void ReconcileElasticDatabaseCustomization(TopologyInstance primaryTopology, TopologyInstance stagingTopology)
        {
            CustomizationGroup primaryAzureSQLDbPerfLevel = primaryTopology.CustomizationGroups.FirstOrDefault(cg => string.Equals(cg.Name, CommonCustomizationNames.AzureSQLDbPerfLevel, StringComparison.OrdinalIgnoreCase));
            CustomizationGroup stagingAzureSQLDbPerfLevel = stagingTopology.CustomizationGroups.FirstOrDefault(cg => string.Equals(cg.Name, CommonCustomizationNames.AzureSQLDbPerfLevel, StringComparison.OrdinalIgnoreCase));

            string deploymentLocation = stagingTopology.CloudStorageLocation;
            string deploymentFailoverLocation = stagingTopology.DisasterRecoveryLocation;

            string topologySkuType;
            bool isElasticPoolSupported = true;

            // Checking if DBMS is supported as well as making sure the regions are supported.
            if (string.IsNullOrEmpty(DbmsConfig.DbmsManagementEndpoint) ||
                string.IsNullOrEmpty(DbmsConfig.DbmsManagementResource) ||
                !AzureSQLLocations.IsElasticPoolSupported(deploymentLocation) ||
                (stagingTopology.TryGetCustomizationValue(CommonCustomizationNames.LcsEnvironmentTag, out topologySkuType) && string.Equals(topologySkuType, CommonCustomizationNames.LcsEnvironmentTagProd, StringComparison.OrdinalIgnoreCase) && !AzureSQLLocations.IsElasticPoolSupported(deploymentFailoverLocation)))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Elastic pool for topology [{0}] is not supported.", primaryTopology.TopologyName);
                isElasticPoolSupported = false;
            }

            foreach (Group stagingGroup in stagingAzureSQLDbPerfLevel.Groups)
            {
                Group primaryGroup = primaryAzureSQLDbPerfLevel.Groups.FirstOrDefault(g => string.Equals(g.Name, stagingGroup.Name, StringComparison.OrdinalIgnoreCase));
                if (primaryGroup != null)
                {
                    Customization stagingElasticPoolEnabledCustomization = stagingGroup.Customizations
                        .FirstOrDefault(c => string.Equals(c.FieldName, CommonCustomizationNames.ElasticPoolEnabled, StringComparison.OrdinalIgnoreCase));

                    if (stagingElasticPoolEnabledCustomization != null)
                    {
                        Customization primaryElasticPoolEnabledCustomization = primaryGroup.Customizations.FirstOrDefault(c => string.Equals(c.FieldName, CommonCustomizationNames.ElasticPoolEnabled, StringComparison.OrdinalIgnoreCase));

                        if (primaryElasticPoolEnabledCustomization == null)
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The customization [{0}\\{1}\\{2}] does not exist in the primary topology [{3}]. Overriding the default value for elastic pool to be ['No']", CommonCustomizationNames.AzureSQLDbPerfLevel, stagingGroup.Name, CommonCustomizationNames.ElasticPoolEnabled, primaryTopology.TopologyName);

                            stagingElasticPoolEnabledCustomization.SelectedValue = CommonCustomizationNames.EnabledNo;
                        }
                        else
                        {
                            // Need to check the primary deployment items as there is some regional changes if the regions were not supported by DBMS/Spartan.
                            string targetItem = stagingGroup.TargetItem;
                            DeploymentItem primaryDatabaseItem = primaryTopology.DeploymentItems.GetFirst(targetItem);
                            DeploymentItem stagingDatabaseItem = stagingTopology.DeploymentItems.GetFirst(targetItem);

                            if (!isElasticPoolSupported)
                            {
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The elastic pools for deployment item [{0}] is not valid for the staging topology [{1}]. Overriding the default value for elastic pool to be ['No']", primaryDatabaseItem, primaryTopology.TopologyName);
                                stagingElasticPoolEnabledCustomization.SelectedValue = CommonCustomizationNames.EnabledNo;
                                stagingDatabaseItem.SetCustomizationValue(CommonCustomizationNames.ElasticPoolEnabled, CommonCustomizationNames.EnabledNo);
                            }
                            else if (primaryDatabaseItem != null)
                            {
                                string elasticPoolEnabledValue;
                                if (primaryDatabaseItem.TryGetCustomizationValue(CommonCustomizationNames.ElasticPoolEnabled, out elasticPoolEnabledValue))
                                {
                                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The deployment item customization [{0}\\{1}] was found in the primary topology [{2}]. Setting the staging customization [{1}] to ['{3}']", primaryDatabaseItem, CommonCustomizationNames.ElasticPoolEnabled, primaryTopology.TopologyName, elasticPoolEnabledValue);
                                    stagingElasticPoolEnabledCustomization.SelectedValue = elasticPoolEnabledValue;
                                    stagingDatabaseItem.SetCustomizationValue(CommonCustomizationNames.ElasticPoolEnabled, elasticPoolEnabledValue);
                                }
                                else
                                {
                                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The deployment item customization [{0}\\{1}] does not exist in the primary topology [{2}]. Overriding the default value for elastic pool to be ['No']", primaryDatabaseItem, CommonCustomizationNames.ElasticPoolEnabled, primaryTopology.TopologyName);
                                    stagingElasticPoolEnabledCustomization.SelectedValue = CommonCustomizationNames.EnabledNo;
                                    stagingDatabaseItem.SetCustomizationValue(CommonCustomizationNames.ElasticPoolEnabled, CommonCustomizationNames.EnabledNo);
                                }
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Gets the SQL db firewall rules of the environment.
        /// </summary>
        /// <param name="topologyInstance"> The topology instance.</param>
        /// <param name="firewallRules">The list containing the firewall rules.</param>
        /// <param name="error">The error.</param>
        /// <param name="tenantId">The tenant ID.</param>
        /// <param name="azureSubscriptionId">The Azure Subscription ID.</param>
        /// <param name="dbItemName">The DB item name.</param>
        /// <returns>True if it retrieved the DB firewall rules, else false.</returns>
        [SuppressMessage("Microsoft.StyleCop.CSharp.NamingRules", "SA1305:FieldNamesMustNotUseHungarianNotation", Justification = "Not a hungarian notation.")]
        private bool TryGetSQLDbFirewallRules(TopologyInstance topologyInstance, out List<AzureSQLFireWall> firewallRules, out HttpResponseMessage error, Guid tenantId, Guid azureSubscriptionId, string dbItemName)
        {
            this.UpdateDSUFirewallRuleForSQL(topologyInstance, tenantId, azureSubscriptionId, createRule: true);
            firewallRules = new List<AzureSQLFireWall>();
            IEnumerable<DeploymentItem> azureSQLDatabaseItems = topologyInstance.DeploymentItems
                .Where(di => di.IsItemType(DeploymentItemType.AzureSQLDatabase) && AzureSQLDatabaseDeploymentWorkflow.DatabaseItemIsValid(di));

            if (!string.IsNullOrWhiteSpace(dbItemName))
            {
                azureSQLDatabaseItems = azureSQLDatabaseItems.Where(di => string.Equals(di.ItemName, dbItemName, StringComparison.OrdinalIgnoreCase));
            }

            foreach (DeploymentItem azureSQLDatabase in azureSQLDatabaseItems)
            {
                DeploymentItem azureSQLServer = topologyInstance.DeploymentItems.Where(azureSQLServerItem => azureSQLServerItem.IsItemType(DeploymentItemType.AzureSQLServer)
                    && String.Equals(azureSQLServerItem.ItemName, azureSQLDatabase.ParentItemName, StringComparison.OrdinalIgnoreCase)).FirstOrDefault();

                string azureSQLServerName;
                string fullyQualifiedName;
                if (azureSQLServer.TryGetCustomizationValue(CommonCustomizationNames.AzureSQLServerName, out azureSQLServerName)
                    && azureSQLServer.TryGetCustomizationValue(CommonCustomizationNames.AzureSQLServerFullyQualifiedDomainName, out fullyQualifiedName))
                {
                    string serverLoginName;
                    string serverPassword;
                    azureSQLServer.GetAzureSQLServerItemCredentials(out serverLoginName, out serverPassword);

                    AzureSQLDatabaseInfo databaseInfo = azureSQLDatabase.GetAzureSqlDatabaseConnectionInfo(azureSQLServer);
                    DatabaseOperations databaseOps = new DatabaseOperations(databaseInfo.FullyQualifiedDomainName, databaseInfo.DatabaseName, serverLoginName, serverPassword);
                    IEnumerable<Azure.Management.Sql.Models.FirewallRule> rules = databaseOps.GetDatabaseFirewallRules();

                    foreach (Azure.Management.Sql.Models.FirewallRule rule in rules)
                    {
                        AzureSQLFireWall azureSqlFirewallRule = new AzureSQLFireWall();
                        azureSqlFirewallRule.Name = rule.Name;
                        azureSqlFirewallRule.StartIPAddress = rule.StartIpAddress;
                        azureSqlFirewallRule.EndIPAddress = rule.EndIpAddress;

                        if (!firewallRules.Select(r => r.Name).Contains(rule.Name))
                        {
                            firewallRules.Add(azureSqlFirewallRule);
                        }
                    }
                }
            }

            this.UpdateDSUFirewallRuleForSQL(topologyInstance, tenantId, azureSubscriptionId, createRule: false);

            error = null;
            return true;
        }

        /// <summary>
        /// Tries to update the SQL database firewall rules with firewall rules provided.
        /// </summary>
        /// <param name="topologyInstance"> The topology instance.</param>
        /// <param name="firewallRules">The list containing the firewall rules to udpate.</param>
        /// <param name="error">The error.</param>
        /// <param name="tenantId">The tenant ID.</param>
        /// <param name="azureSubscriptionId">The Azure Subscription ID.</param>
        /// <param name="dbItemName">The item name of the database.</param>
        /// <returns>True if it updated the customer SQL database firewall rules, else false.</returns>
        [SuppressMessage("Microsoft.StyleCop.CSharp.NamingRules", "SA1305:FieldNamesMustNotUseHungarianNotation", Justification = "Not a hungarian notation.")]
        private bool TryUpdateSQLDbFirewallRules(TopologyInstance topologyInstance, List<AzureSQLFireWall> firewallRules, out HttpResponseMessage error, Guid tenantId, Guid azureSubscriptionId, string dbItemName)
        {
            List<AzureSQLFireWall> existingFirewallRules;
            if (!this.TryGetSQLDbFirewallRules(topologyInstance, out existingFirewallRules, out error, tenantId, azureSubscriptionId, dbItemName))
            {
                ServiceException failedToGetSQLFirewallRules = new ServiceException(ServiceErrorCode.NetworkSecurityGroup_FailedToRetrieveFromAzureSQL);
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceEngine, failedToGetSQLFirewallRules, "Failed to get the sql firewall rules for DB with item name [{0}].", dbItemName);
                throw failedToGetSQLFirewallRules;
            }

            IEnumerable<AzureSQLFireWall> firewallRulesToAdd = firewallRules
                .Where(cr => cr.Name != null && !existingFirewallRules.Any(er => string.Equals(cr.Name, er.Name, StringComparison.OrdinalIgnoreCase)));

            IEnumerable<AzureSQLFireWall> firewallRulesToRemove = existingFirewallRules
                .Where(er => er.Name != null && !firewallRules.Any(cr => string.Equals(er.Name, cr.Name, StringComparison.OrdinalIgnoreCase)));

            this.UpdateDSUFirewallRuleForSQL(topologyInstance, tenantId, azureSubscriptionId, true);

            IEnumerable<DeploymentItem> azureSQLDatabaseItems = topologyInstance.DeploymentItems
                .Where(di => di.IsItemType(DeploymentItemType.AzureSQLDatabase) && AzureSQLDatabaseDeploymentWorkflow.DatabaseItemIsValid(di));

            if (!string.IsNullOrWhiteSpace(dbItemName))
            {
                azureSQLDatabaseItems = azureSQLDatabaseItems.Where(di => string.Equals(di.ItemName, dbItemName, StringComparison.OrdinalIgnoreCase));
            }

            foreach (DeploymentItem azureSQLDatabase in azureSQLDatabaseItems)
            {
                DeploymentItem azureSQLServer = topologyInstance.DeploymentItems.Where(azureSQLServerItem => azureSQLServerItem.IsItemType(DeploymentItemType.AzureSQLServer)
                   && String.Equals(azureSQLServerItem.ItemName, azureSQLDatabase.ParentItemName, StringComparison.OrdinalIgnoreCase)).FirstOrDefault();

                string azureSQLServerName;
                string fullyQualifiedName;
                if (azureSQLServer.TryGetCustomizationValue(CommonCustomizationNames.AzureSQLServerName, out azureSQLServerName)
                    && azureSQLServer.TryGetCustomizationValue(CommonCustomizationNames.AzureSQLServerFullyQualifiedDomainName, out fullyQualifiedName))
                {
                    string serverLoginName;
                    string serverPassword;
                    azureSQLServer.GetAzureSQLServerItemCredentials(out serverLoginName, out serverPassword);

                    AzureSQLDatabaseInfo databaseInfo = azureSQLDatabase.GetAzureSqlDatabaseConnectionInfo(azureSQLServer);
                    DatabaseOperations databaseOps = new DatabaseOperations(databaseInfo.FullyQualifiedDomainName, databaseInfo.DatabaseName, serverLoginName, serverPassword);

                    foreach (AzureSQLFireWall firewallRule in firewallRulesToAdd)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Adding firewall rule [{0}] to database [{1}].", firewallRule.Name, databaseInfo.DatabaseName);
                        databaseOps.CreateDatabaseFirewallRule(firewallRule.Name, firewallRule.StartIPAddress, firewallRule.EndIPAddress);
                    }

                    foreach (AzureSQLFireWall firewallRule in firewallRulesToRemove)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removing firewall rule [{0}] from database [{1}]", firewallRule.Name, databaseInfo.DatabaseName);
                        databaseOps.DeleteDatabaseFirewallRule(firewallRule.Name);
                    }
                }
            }

            this.UpdateDSUFirewallRuleForSQL(topologyInstance, tenantId, azureSubscriptionId, false);

            error = null;
            return true;
        }

        /// <summary>
        /// Action used to execute SQL Queries against an environment.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <param name="version">The version of public WebAPI is using, this determins the out of the request.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Needs to be robust.")]
        [SuppressMessage("Microsoft.Reliability", "CA2000:DisposeObjectsBeforeLosingScope", Justification = "WebApi will handle the disposal the HttpResponseMessage returned in this function.")]
        private HttpResponseMessage InvokeFastSQLHelper(
            Guid tenantId,
            Guid azureSubscriptionId,
            string topologyInstanceId,
            ODataActionParameters parameters,
            int version)
        {
            try
            {
                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Performing SQL action for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}' using version '{3}' for the InvokeFastSQL API.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    version);

                DeploymentState deploymentState = DeploymentState.ExecutingSQLCommand;

                EnvironmentGroup environmentGroup = this.GetEnvironmentGroupParameter(parameters);
                TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ExecuteSQLCommand;

                string sqlQueryName = this.GetParameterOrDefault(parameters, CommonDeploymentActionParameters.SQLQueryName, String.Empty);

                if (string.IsNullOrEmpty(sqlQueryName))
                {
                    return this.CreateErrorResponse(
                        ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                        action.ToString(),
                        sqlQueryName,
                        CommonDeploymentActionParameters.SQLQueryName);
                }

                string databaseDeploymentItemName = this.GetParameterOrDefault(parameters, CommonDeploymentActionParameters.DatabaseDeploymentItemName, String.Empty);

                if (string.IsNullOrEmpty(databaseDeploymentItemName))
                {
                    return this.CreateErrorResponse(
                        ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                        action.ToString(),
                        databaseDeploymentItemName,
                        CommonDeploymentActionParameters.DatabaseDeploymentItemName);
                }

                SQLActionTableItem sqlActionTableItem = SQLActionDAC.GetSQLAction(sqlQueryName);

                if (sqlActionTableItem == null)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The SQL query [{0}] was not found in the DeploymentSettings storage table.", sqlQueryName);
                    return this.CreateErrorResponse(ServiceErrorCode.SQLQueryWasNotFound);
                }

                if (!sqlActionTableItem.FastQuery && !sqlActionTableItem.SupportsAllQueryPaths)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The SQL action [{0}] is not defined as a fast executing action.", sqlQueryName);
                    return this.CreateErrorResponse(ServiceErrorCode.SlowSQLQuery);
                }

                // Pulled from the the GetParameterOrDefault() which fails with trying to convert IEnumberable to List.
                HttpResponseMessage throwaway;
                IEnumerable<SQLActionParameter> sqlActionParameters;
                if (parameters == null || !this.TryProcessParameter(parameters, CommonDeploymentActionParameters.SQLQueryParameters, out sqlActionParameters, out throwaway))
                {
                    sqlActionParameters = new List<SQLActionParameter>();
                }

                TopologyInstance topologyInstance;
                DeploymentInstance deploymentInstance;
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage message;
                TopologyInstanceTableItem topologyInstanceRow;
                SqlOperation sqlOperation;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, out topologyInstance, out message, out topologyInstanceRow))
                {
                    return message;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out message))
                {
                    return message;
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                if (!string.Equals(topologyInstance.DeploymentItems.GetFirst(CommonCustomizationNames.AXDbDeploymentItemName).ItemType, DeploymentItemType.AzureSQLDatabase.ToString(), StringComparison.OrdinalIgnoreCase))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] on topology [{1}] but the environment is running on a DevTest or Demo.", action, topologyInstance);
                    return this.CreateErrorResponse(ServiceErrorCode.UnableToRunSQLOnDevTestOrDemoTopology);
                }

                // Prevent multiple writes from being performed against the database.
                if ((deploymentInstance.DeploymentStatus == DeploymentApi.Model.DeploymentStatus.Failed) ||
                    (deploymentInstance.DeploymentState != DeploymentState.Finished &&
                    (string.Equals(deploymentInstance.DeploymentAction, DeploymentRequest.DeploymentAction.ExecuteSQLCommand.ToString(), StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(deploymentInstance.DeploymentAction, DeploymentRequest.DeploymentAction.ExecuteGenevaAction.ToString(), StringComparison.OrdinalIgnoreCase)) &&
                    deploymentInstance.DeploymentActionParameters.HasValue(CommonDeploymentActionParameters.SQLActionOutput) &&
                    string.Equals(deploymentInstance.GetSQLActionOutput(), DeploymentConstants.InvokeSQLCommand, StringComparison.OrdinalIgnoreCase)))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}] with a status of [{3}].", action, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, deploymentState);
                }

                sqlOperation = new SqlOperation(topologyInstance.InstanceId);
                sqlOperation.Initialize(topologyInstance);

                // Adding to Deployment Action Parameters so we know what has passed for this request.
                sqlOperation.DeploymentActionParameters = new DeploymentInstance.ActionParameters();
                sqlOperation.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SQLQueryName, sqlActionTableItem.Name);
                string sqlActionOutput = sqlActionTableItem.ReturnsResults ? DeploymentConstants.InvokeSQLQueryResults : DeploymentConstants.InvokeSQLCommand;
                sqlOperation.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SQLActionOutput, sqlActionOutput);
                sqlOperation.SQLOperationName = sqlQueryName;
                sqlOperation.AzureSubscriptionID = azureSubscriptionId.ToString();
                sqlOperation.TenantID = tenantId.ToString();
                sqlOperation.TopologyInstanceId = topologyInstance.InstanceId;

                Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "Performing SQL action '{0}' on database '{1}' for topology Instance Id '{2}' in Azure Subscription '{3}' of tenant '{4}'.",
                    sqlQueryName,
                    databaseDeploymentItemName,
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                var deploymentAPIType = AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceType.API;

                DeploymentItem azureSQLDatabaseItem = topologyInstance.DeploymentItems.GetFirst(databaseDeploymentItemName);
                DeploymentItem azureSQLServerItem = topologyInstance.DeploymentItems.GetFirst(azureSQLDatabaseItem.ParentItemName);

                try
                {
                    if (azureSQLDatabaseItem.IsElasticPoolEnabled())
                    {
                        AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceDBMSFirewallOperation(topologyInstance, azureSQLServerItem, deploymentAPIType, true, sqlActionTableItem.RowKey);
                    }
                    else
                    {
                        ARMOperationData operationData = new ARMOperationData(
                            tenantRegistration.ActiveDirectorySubscriptionTenantID,
                            tenantRegistration.AzureSubscriptionId.ToString(),
                            topologyInstance.GetResourceGroup(azureSQLServerItem),
                            topologyInstance.InstanceId);

                        AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceARMFirewallOperation(operationData, azureSQLServerItem, deploymentAPIType, true, sqlActionTableItem.RowKey);
                    }

                    IEnumerable<SQLActionParameter> tableParameters = string.IsNullOrWhiteSpace(sqlActionTableItem.Parameters) ? new List<SQLActionParameter>() : CommonUtilities.DeserializeJson<IEnumerable<SQLActionParameter>>(sqlActionTableItem.Parameters);

                    if (!this.ValidateSQLParameters(sqlActionParameters, tableParameters, out message))
                    {
                        return message;
                    }

                    string serverLoginName;
                    string serverPassword;
                    azureSQLServerItem.GetAzureSQLServerItemCredentials(out serverLoginName, out serverPassword);

                    AzureSQLDatabaseInfo databaseInfo;
                    if (!azureSQLDatabaseItem.TryGetAzureSqlDatabaseConnectionInfo(azureSQLServerItem, out databaseInfo))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Failed to get database connection info for [{0}].", azureSQLDatabaseItem);
                        return this.CreateErrorResponse(ServiceErrorCode.UnableToRetrieveSQLConnectionInformation, topologyInstanceId);
                    }

                    DatabaseOperations databaseOps = new DatabaseOperations(databaseInfo.FullyQualifiedDomainName, databaseInfo.DatabaseName, serverLoginName, serverPassword);

                    string queryMessage;
                    string outputObject = null;
                    bool isSuccess = false;

                    // Keep the queries as short as possible to prevent the API from hanging.
                    TimeSpan queryTimeout = TimeSpan.FromSeconds(30);

                    if (sqlActionTableItem.ReturnsResults)
                    {
                        using (DataTable datatable = databaseOps.ExecuteSQLTemplateQuery(sqlActionTableItem.QueryTemplate, tableParameters, out queryMessage, queryTimeout))
                        {
                            if (datatable != null)
                            {
                                isSuccess = true;
                                outputObject = JsonConvert.SerializeObject(datatable);
                            }
                        }
                    }
                    else
                    {
                        if (databaseOps.ExecuteSQLTemplateCommand(sqlActionTableItem.QueryTemplate, tableParameters, out queryMessage, queryTimeout))
                        {
                            isSuccess = true;
                        }
                    }

                    SqlActionResponse response = new SqlActionResponse()
                    {
                        IsFastActionResponse = true,
                        IsSuccessful = isSuccess,
                        OutputObjectOrBlobLink = outputObject,
                        MessageOrBlobLink = queryMessage
                    };

                    if (!isSuccess)
                    {
                        Tracer.WriteExecutionEvent(
                           TraceComponent.DeploymentServiceApi,
                           "Unable to invoke SQL action for Sql query '{0}' on topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'. Query failed with message '{4}'.",
                           sqlQueryName,
                           topologyInstanceId,
                           azureSubscriptionId,
                           tenantId,
                           response.MessageOrBlobLink);

                        sqlOperation.DeploymentWarnings.Add(new DeploymentError(queryMessage));
                    }

                    if (!this.CreateSqlOperationInstanceBlob(sqlOperation, tenantRegistration, topologyInstance, azureSubscriptionId, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out message))
                    {
                        return message;
                    }

                    if (version == 1)
                    {
                        if (response.IsSuccessful)
                        {
                            return Request.CreateResponse(HttpStatusCode.OK, response.OutputObjectOrBlobLink);
                        }

                        // Backwards compatility, current LCS expects an error response when the query fails.
                        return this.CreateErrorResponse(ServiceErrorCode.UnableToRunSQLOperation, topologyInstanceId);
                    }
                    else
                    {
                        return Request.CreateResponse(HttpStatusCode.OK, response);
                    }
                }
                catch (Exception e)
                {
                    Tracer.WriteErrorEvent(
                           TraceComponent.DeploymentServiceApi,
                           e,
                           "Unable to invoke SQL action for Sql query '{0}' on topology Instance Id '{1}' in Azure Subscription '{2}' of tenant '{3}'.",
                           sqlQueryName,
                           topologyInstanceId,
                           azureSubscriptionId,
                           tenantId);

                    return this.CreateErrorResponse(ServiceErrorCode.UnableToRunSQLOperation, topologyInstanceId);
                }
                finally
                {
                    if (azureSQLDatabaseItem.IsElasticPoolEnabled())
                    {
                        AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceDBMSFirewallOperation(topologyInstance, azureSQLServerItem, deploymentAPIType, false, sqlActionTableItem.RowKey);
                    }
                    else
                    {
                        ARMOperationData operationData = new ARMOperationData(
                            tenantRegistration.ActiveDirectorySubscriptionTenantID,
                            tenantRegistration.AzureSubscriptionId.ToString(),
                            topologyInstance.GetResourceGroup(azureSQLServerItem),
                            topologyInstance.InstanceId);

                        AzureSQLDatabaseDeploymentWorkflow.DeploymentServiceARMFirewallOperation(operationData, azureSQLServerItem, deploymentAPIType, false, sqlActionTableItem.RowKey);
                    }
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Unable to invoke SQL action for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return this.CreateErrorResponse(serviceException);
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Unable to invoke SQL action for topology Instance Id '{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                throw;
            }
        }

        /// <summary>
        /// Process topology for scale out input.
        /// </summary>
        /// <param name="scaleoutParameters">List of scaleout parameters, one for each deployment item to scale.</param>
        /// <param name="instance">The current topology instance.</param>
        /// <param name="tenantRegistration">The tenant registration info.</param>
        /// <param name="errorMessage">The error messare if a failure is detected.</param>
        /// <returns>True if processing is successful, else false.</returns>
        private bool ProcessScaleOutInput(IEnumerable<ScaleoutParameter> scaleoutParameters, TopologyInstance instance, TenantRegistration tenantRegistration, EnvironmentGroup environmentGroup, out HttpResponseMessage errorMessage)
        {
            int newVMCount = 0;
            int scaleoutCoresNeeded = 0;

            if (!instance.ShouldUseAzureResourceManager())
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutOperationNotSupported);
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Attempted to perform a scale out operation on RDFE that is not supported");
                return false;
            }

            // some consistency check on input parameters: no duplicates, items should exist. Other validation checks are below.
            foreach (ScaleoutParameter parameter in scaleoutParameters)
            {
                if (scaleoutParameters.Count(scaleparam => string.Equals(scaleparam.DeploymentItemName, parameter.DeploymentItemName, StringComparison.OrdinalIgnoreCase)) > 1)
                {
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutParametersDuplicateItemName, parameter.DeploymentItemName, instance.ToString());
                    Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Scaleout operation input has a duplicated item name [{0}], topology instance [{1}].", parameter.DeploymentItemName, instance.ToString());
                    return false;
                }

                if (!instance.DeploymentItems.Any(di => string.Equals(di.ItemName, parameter.DeploymentItemName, StringComparison.OrdinalIgnoreCase)))
                {
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutParametersItemNameNotFound, parameter.DeploymentItemName, instance.ToString());
                    Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Scaleout operation input contains a deployment item name [{0}] that does not exist in topology instance [{1}].", parameter.DeploymentItemName, instance.ToString());
                    return false;
                }
            }

            // verify input and set scale out customizations
            using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager(instance.ARM.ResourceGroupName))
            {
                // before we proceed, check if the recovery service deployment item exists and if not, create one with default values
                DeploymentItem recoveryVaultItem = instance.GetExistingOrCreateRecoveryVaultItem(manager);
                if (recoveryVaultItem == null)
                {
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutNoRecoveryServiceItem, instance.ToString());
                    Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Invalid recovery vault item in topology [{0}], erroring out with: {1}", instance.ToString(), this.GetMessageError(errorMessage));
                    return false;
                }

                // pass the scale out input parameters as customization of deployment items
                List<DeploymentItem> deploymentItems = instance.GetActiveVirtualMachineItems(environmentGroup).ToList();
                foreach (DeploymentItem deploymentItem in deploymentItems)
                {
                    // first clear out all customizations related to ScaleOut in the current topology instance so we do not leave one behind from previous runs
                    this.CleanupScaleoutItem(instance, deploymentItem);

                    ScaleoutParameter paramItem = scaleoutParameters.FirstOrDefault(scaleparam => string.Equals(scaleparam.DeploymentItemName, deploymentItem.ItemName, StringComparison.OrdinalIgnoreCase));

                    if (paramItem != null)
                    {
                        // skip any item that did not provide a scale out instance count
                        if (paramItem.InstanceCount == 0)
                        {
                            Tracer.WriteExecutionEvent(
                                TraceComponent.DeploymentServiceApi,
                                "ScaleOut: input scaleout InstanceCount value is 0, no scale out operation for deployment item [{0}].",
                                deploymentItem.ItemName);
                            continue;
                        }

                        Tracer.WriteExecutionEvent(
                            TraceComponent.DeploymentServiceApi,
                            "ScaleOut: Scale out instance count for deployment item [{0}] set to [{1}].",
                            deploymentItem.ItemName,
                            paramItem.InstanceCount);

                        deploymentItem.SetCustomizationValue(CommonCustomizationNames.ScaleOutInstanceCount, paramItem.InstanceCount);
                        newVMCount += paramItem.InstanceCount;
                        scaleoutCoresNeeded += paramItem.InstanceCount * deploymentItem.RoleSizeToCoreCount();

                        // optional parameters for source vm and restore point
                        string sourceVMName = paramItem.SourceVMName;
                        if (!string.IsNullOrEmpty(sourceVMName))
                        {
                            if (deploymentItem.Instances == null || deploymentItem.Instances.FirstOrDefault(i => string.Equals(i.MachineName, sourceVMName, StringComparison.OrdinalIgnoreCase)) == null)
                            {
                                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutInvalidSourceVM, sourceVMName, deploymentItem.ItemName, instance.ToString());
                                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Invalid source VM for scale out, erroring out with: {0}", this.GetMessageError(errorMessage));
                                return false;
                            }
                        }
                        else
                        {
                            // select the first instance
                            if (!deploymentItem.Instances.Any())
                            {
                                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutVMDeploymentItemMissingInstances, deploymentItem.ItemName, instance.ToString());
                                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Deployment item for scale out has no instances, erroring out with: {0}", this.GetMessageError(errorMessage));
                                return false;
                            }

                            sourceVMName = deploymentItem.Instances.First().MachineName;
                        }

                        // error out if we could not determine a source VM
                        if (string.IsNullOrEmpty(sourceVMName))
                        {
                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutSourceVMNameMissing, deploymentItem.ItemName, instance.ToString());
                            Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "The source VM for scaleout is expected but missing, erroring out with: {0}", this.GetMessageError(errorMessage));
                            return false;
                        }

                        Tracer.WriteExecutionEvent(
                            TraceComponent.DeploymentServiceApi,
                            "ScaleOut: Scale out source VM for deployment item [{0}] set to [{1}].",
                            deploymentItem.ItemName,
                            sourceVMName);
                        deploymentItem.SetCustomizationValue(CommonCustomizationNames.ScaleOutSourceVMName, sourceVMName);

                        string recoveryPointName = paramItem.RecoveryPointName;
                        if (!string.IsNullOrEmpty(recoveryPointName))
                        {
                            // Validate recovery point availability
                            if (!this.ValidateRecoveryPointAvailability(manager, instance, recoveryVaultItem, sourceVMName, recoveryPointName, out errorMessage))
                            {
                                return false;
                            }

                            Tracer.WriteExecutionEvent(
                                TraceComponent.DeploymentServiceApi,
                                "ScaleOut: Recovery point for deployment item [{0}] set to [{1}].",
                                deploymentItem.ItemName,
                                recoveryPointName);

                            deploymentItem.SetCustomizationValue(CommonCustomizationNames.ScaleOutRecoveryPointName, recoveryPointName);
                        }

                        string selectedRestoreJob = paramItem.SelectedRestoreJob;
                        if (!string.IsNullOrEmpty(selectedRestoreJob))
                        {
                            // Validate restore job is in completed state
                            if (!this.ValidateRestoreJobAvailability(manager, instance, recoveryVaultItem, sourceVMName, selectedRestoreJob, out errorMessage))
                            {
                                return false;
                            }

                            Tracer.WriteExecutionEvent(
                                TraceComponent.DeploymentServiceApi,
                                "ScaleOut: Restore job selected for deployment item [{0}], set to [{1}].",
                                deploymentItem.ItemName,
                                selectedRestoreJob);

                            deploymentItem.SetCustomizationValue(CommonCustomizationNames.ScaleOutSelectedRestoreJobName, selectedRestoreJob);
                        }
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Could not find matching item with name [{0}] in scaleout parameters.", deploymentItem.ItemName);
                    }
                }

                // if the input did not provide any new VMs, then return error ScaleOutNoChanges
                if (newVMCount == 0)
                {
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutNoChanges);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Input topology instance did not specify any new VMs, erroring out with [{0}].", this.GetMessageError(errorMessage));
                    return false;
                }

                // Check count of available cores
                if (scaleoutCoresNeeded > 0)
                {
                    List<TopologyInstance> ongoingTopologyInstances;
                    this.GetDeployingTopologyInstances(tenantRegistration.TenantId, out ongoingTopologyInstances);

                    // filter to deloyents within the same region
                    ongoingTopologyInstances = ongoingTopologyInstances.Where(d => d.ShouldUseAzureResourceManager() && string.Equals(d.CloudServiceLocation, instance.CloudServiceLocation, StringComparison.OrdinalIgnoreCase)).ToList();

                    if (!this.ValidateTopologyARMCoresAvailabilityForUpdate(tenantRegistration.AzureSubscriptionId, instance, out errorMessage, ongoingTopologyInstances, manager, scaleoutCoresNeeded))
                    {
                        return false;
                    }
                }

                // Check count of available IPs
                if (newVMCount > 0 && instance.UsesExistingInfrastructure(CommonCustomizationNames.VnetName, CommonCustomizationNames.UseExistingVnet))
                {
                    if (!this.ValidateARMAvailableIPs(newVMCount, instance, tenantRegistration, out errorMessage))
                    {
                        return false;
                    }
                }
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Clear all data that may have been left over from a previous execution of the scale out: customization, incomplete instances.
        /// </summary>
        /// <param name="instanceTopology">The current topology instance.</param>
        /// <param name="deploymentItem">Deployment item to cleanup.</param>
        private void CleanupScaleoutItem(TopologyInstance instanceTopology, DeploymentItem deploymentItem)
        {
            Contract.Requires(instanceTopology != null);
            Contract.Requires(deploymentItem != null);

            // first clear out all customizations related to ScaleOut in the current topology instance so we do not leave one behind from previous runs
            deploymentItem.TryRemoveCustomization(CommonCustomizationNames.ScaleOutInstanceCount);
            deploymentItem.TryRemoveCustomization(CommonCustomizationNames.ScaleOutSourceVMName);
            deploymentItem.TryRemoveCustomization(CommonCustomizationNames.ScaleOutRecoveryPointName);
            deploymentItem.TryRemoveCustomization(CommonCustomizationNames.ScaleOutBackupJobName);
            deploymentItem.TryRemoveCustomization(CommonCustomizationNames.ScaleOutRestoreJobName);
            deploymentItem.TryRemoveCustomization(CommonCustomizationNames.ScaleOutSelectedRestoreJobName);
            deploymentItem.TryRemoveCustomization(CommonCustomizationNames.ScaleOutStartVMIndex);
            deploymentItem.TryRemoveCustomization(CommonCustomizationNames.ScaleOutAddToLivePool);
            deploymentItem.TryRemoveCustomization(CommonCustomizationNames.ScaleOutExecuteWinRMExtension);

            // clear all instances that have been added but left in the preparation state (VM resource was not created)
            deploymentItem.Instances.RemoveAll(instance => !string.IsNullOrEmpty(instance.DisplayStatusResourceId) &&
                                                           (string.Equals(instance.DisplayStatusResourceId, Instance.DisplayStatusId.ScaleOutPreparedInstance.ToString(), StringComparison.OrdinalIgnoreCase) ||
                                                            string.Equals(instance.DisplayStatusResourceId, Instance.DisplayStatusId.ScaleOutInstanceDeployed.ToString(), StringComparison.OrdinalIgnoreCase)));
        }

        /// <summary>
        /// Validates recovery point availability.
        /// </summary>
        /// <param name="manager">Azure resource manager.</param>
        /// <param name="instance">Current topology instance.</param>
        /// <param name="recoveryVaultItem">Deployment item for recovery vault.</param>
        /// <param name="sourceVMName">Source VM name.</param>
        /// <param name="recoveryPointName">Recovery point for the given VM.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True if validation passed, false otherwise.</returns>
        private bool ValidateRecoveryPointAvailability(AzureResourceManager manager, TopologyInstance instance, DeploymentItem recoveryVaultItem, string sourceVMName, string recoveryPointName, out HttpResponseMessage errorMessage)
        {
            Contract.Requires(manager != null);
            Contract.Requires(instance != null);
            Contract.Requires(recoveryVaultItem != null);
            Contract.Requires(!string.IsNullOrEmpty(sourceVMName));
            Contract.Requires(!string.IsNullOrEmpty(recoveryPointName));

            // to start with, verify we have a recovery vault available to check against
            Vault existingVault = instance.AssociateExistingScaleoutVault(manager, recoveryVaultItem);
            if (existingVault == null)
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutRecoveryPointNoRecoveryVault, instance.ToString());
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Recovery point validation requires an existing recovery vault, but none exists, erroring out with: {0}", this.GetMessageError(errorMessage));
                return false;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Checking protected items for VM [{0}] in recovery vault [{1}].", sourceVMName, existingVault.Name);
            RecoveryServicesBackup.ProtectedItemResource protectedItem = manager.RecoveryServicesBackup.Value.GetBackupProtectedItem(existingVault.Name, sourceVMName);

            if (protectedItem == null)
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutRecoveryPointNoProtectedItem, recoveryPointName, sourceVMName, existingVault.Name);
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Recovery point validation requires a backup protected item, but none exists, erroring out with: {0}", this.GetMessageError(errorMessage));
                return false;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Found protected item [{0}] for VM [{1}] in recovery vault [{2}].", protectedItem.Name, sourceVMName, existingVault.Name);

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Checking recovery point [{0}] for VM [{1}] in recovery vault [{2}].", recoveryPointName, sourceVMName, existingVault.Name);
            RecoveryServicesBackup.RecoveryPointResource recoveryPoint = manager.RecoveryServicesBackup.Value.GetVMRecoveryPoint(existingVault.Name, protectedItem, recoveryPointName);

            if (recoveryPoint == null)
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutRecoveryPointRecoveryPointNotFound, recoveryPointName, sourceVMName, existingVault.Name);
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Recovery point not found, erroring out with: {0}", this.GetMessageError(errorMessage));
                return false;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Verified the recovery point [{0}] exists for VM [{1}] in recovery vault [{2}].", recoveryPointName, sourceVMName, existingVault.Name);

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates recovery point availability.
        /// </summary>
        /// <param name="manager">Azure resource manager.</param>
        /// <param name="instance">Current topology instance.</param>
        /// <param name="recoveryVaultItem">Deployment item for recovery vault.</param>
        /// <param name="sourceVMName">Source VM name.</param>
        /// <param name="selectedRestoreJobName">Restore job selecetd for this operation.</param>
        /// <param name="errorMessage">The error message.</param>
        /// <returns>True if validation passed, false otherwise.</returns>
        private bool ValidateRestoreJobAvailability(AzureResourceManager manager, TopologyInstance instance, DeploymentItem recoveryVaultItem, string sourceVMName, string selectedRestoreJobName, out HttpResponseMessage errorMessage)
        {
            Contract.Requires(manager != null);
            Contract.Requires(instance != null);
            Contract.Requires(recoveryVaultItem != null);
            Contract.Requires(!string.IsNullOrEmpty(sourceVMName));
            Contract.Requires(!string.IsNullOrEmpty(selectedRestoreJobName));

            // to start with, verify we have a recovery vault available to check against
            Vault existingVault = instance.AssociateExistingScaleoutVault(manager, recoveryVaultItem);
            if (existingVault == null)
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutRecoveryPointNoRecoveryVault, instance.ToString());
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Recovery point validation requires an existing recovery vault, but none exists, erroring out with: {0}", this.GetMessageError(errorMessage));
                return false;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Checking protected items for VM [{0}] in recovery vault [{1}].", sourceVMName, existingVault.Name);
            RecoveryServicesBackup.ProtectedItemResource protectedItem = manager.RecoveryServicesBackup.Value.GetBackupProtectedItem(existingVault.Name, sourceVMName);

            if (protectedItem == null)
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutRestoreJobNoProtectedItem, selectedRestoreJobName, sourceVMName, existingVault.Name);
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Selected restore job validation requires a backup protected item, but none exists, erroring out with: {0}", this.GetMessageError(errorMessage));
                return false;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Found protected item [{0}] for VM [{1}] in recovery vault [{2}].", protectedItem.Name, sourceVMName, existingVault.Name);

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Checking restore job [{0}] for VM [{1}] in recovery vault [{2}].", selectedRestoreJobName, sourceVMName, existingVault.Name);
            RecoveryServicesBackup.JobResource restoreJob = manager.RecoveryServicesBackup.Value.GetVMBackupJobById(existingVault.Name, selectedRestoreJobName);

            if (restoreJob == null)
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.RecoveryVaultJobIdNotFound, selectedRestoreJobName, existingVault.Name);
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Selected restore job not found, erroring out with: {0}", this.GetMessageError(errorMessage));
                return false;
            }

            if (!string.Equals(restoreJob.Properties.Status, RecoveryServicesBackup.JobStatus.Completed, StringComparison.OrdinalIgnoreCase))
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutRestoreJobNotCompleted, selectedRestoreJobName, sourceVMName, existingVault.Name);
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Selected restore job is not in Completed state, erroring out with: {0}", this.GetMessageError(errorMessage));
                return false;
            }

            // check also the sourceVMName matches the VM corresponding to this restore job
            if (!string.Equals(restoreJob.Properties.EntityFriendlyName, sourceVMName, StringComparison.OrdinalIgnoreCase))
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ScaleOutRestoreJobVMNamesNoMatch, selectedRestoreJobName, restoreJob.Properties.EntityFriendlyName, sourceVMName, existingVault.Name);
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "Selected restore job was executed on a different VM, erroring out with: {0}", this.GetMessageError(errorMessage));
                return false;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Verified the restore job point [{0}] exists and is in completed state, VM [{1}] in recovery vault [{2}].", selectedRestoreJobName, sourceVMName, existingVault.Name);

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates that the Ax database container application version information needed for data upgrade.
        /// </summary>
        /// <param name="tenantRegistration">The tenant registration.</param>
        /// <param name="topologyInstance">The topology instance for the primary / old environment.</param>
        /// <returns>True if an application version record exists; otherwise false.</returns>
        private bool ValidateApplicationVersionExistsForAxDatabaseUpgrade(TenantRegistration tenantRegistration, TopologyInstance topologyInstance)
        {
            Action cleanupFirewallRules;

            var sqlDatabase = this.GetSqlDatabase(
                tenantRegistration,
                topologyInstance,
                CommonCustomizationNames.AXDbDeploymentItemName,
                CommonCredentialNames.AXDatabaseAdminUserName,
                out cleanupFirewallRules);

            bool versionExists = sqlDatabase.ApplicationVersionExists();
            if (cleanupFirewallRules != null)
            {
                cleanupFirewallRules();
            }

            return versionExists;
        }

        /// <summary>
        /// Convert <see cref="GenericResource"/> to <see cref="TopologyInstanceAzureResource"/>.
        /// </summary>
        /// <param name="resource">The <see cref="GenericResource"/>.</param>
        /// <returns>The <see cref="TopologyInstanceAzureResource"/>.</returns>
        private TopologyInstanceAzureResource ConvertToAzureResourceResponse(GenericResource resource)
        {
            if (resource == null)
            {
                return null;
            }

            TopologyInstanceAzureResource azureResource = new TopologyInstanceAzureResource();
            azureResource.Id = resource.Id;
            azureResource.Name = resource.Name;
            azureResource.Type = resource.Type;
            azureResource.Location = resource.Location;
            azureResource.Tags = this.ConvertToAzureResourceTagResponse(resource.Tags);
            azureResource.Kind = resource.Kind;
            azureResource.ManagedBy = resource.ManagedBy;
            azureResource.Plan = this.ConvertToAzureResourcePlanResponse(resource.Plan);
            azureResource.Sku = this.ConvertToAzureResourceSkuResponse(resource.Sku);
            azureResource.Identity = this.ConvertToAzureResourceIdentityResponse(resource.Identity);

            return azureResource;
        }

        /// <summary>
        /// Convert a dictionary of tags to a serializable list of tags.
        /// </summary>
        /// <param name="tags">The dictionary of tags.</param>
        /// <returns>The serializable list of tags.</returns>
        private List<TopologyInstanceAzureResourceTag> ConvertToAzureResourceTagResponse(IDictionary<string, string> tags)
        {
            if (tags == null)
            {
                // OData serializer cannot serialize null collections. To bypass this, assign empty collection.
                return new List<TopologyInstanceAzureResourceTag>();
            }

            return tags.Select(kvp => new TopologyInstanceAzureResourceTag
            {
                Tag = kvp.Key,
                Value = kvp.Value,
            }).ToList();
        }

        /// <summary>
        /// Convert <see cref="Plan"/> to <see cref="TopologyInstanceAzureResourcePlan"/>.
        /// </summary>
        /// <param name="plan">The <see cref="Plan"/>.</param>
        /// <returns>The <see cref="TopologyInstanceAzureResourcePlan"/>.</returns>
        private TopologyInstanceAzureResourcePlan ConvertToAzureResourcePlanResponse(Plan plan)
        {
            if (plan == null)
            {
                return null;
            }

            TopologyInstanceAzureResourcePlan azureResourcePlan = new TopologyInstanceAzureResourcePlan();
            azureResourcePlan.Name = plan.Name;
            azureResourcePlan.Publisher = plan.Publisher;
            azureResourcePlan.Product = plan.Product;
            azureResourcePlan.PromotionCode = plan.PromotionCode;

            return azureResourcePlan;
        }

        /// <summary>
        /// Convert <see cref="Sku"/> to <see cref="TopologyInstanceAzureResourceSku"/>.
        /// </summary>
        /// <param name="sku">The <see cref="Sku"/>.</param>
        /// <returns>The <see cref="TopologyInstanceAzureResourceSku"/>.</returns>
        private TopologyInstanceAzureResourceSku ConvertToAzureResourceSkuResponse(Sku sku)
        {
            if (sku == null)
            {
                return null;
            }

            TopologyInstanceAzureResourceSku azureResourceSku = new TopologyInstanceAzureResourceSku();
            azureResourceSku.Name = sku.Name;
            azureResourceSku.Tier = sku.Tier;
            azureResourceSku.Size = sku.Size;
            azureResourceSku.Family = sku.Family;
            azureResourceSku.Model = sku.Model;
            azureResourceSku.Capacity = sku.Capacity;

            return azureResourceSku;
        }

        /// <summary>
        /// Convert <see cref="Identity"/> to <see cref="TopologyInstanceAzureResourceIdentity"/>.
        /// </summary>
        /// <param name="identity">The <see cref="Identity"/>.</param>
        /// <returns>The <see cref="TopologyInstanceAzureResourceIdentity"/>.</returns>
        private TopologyInstanceAzureResourceIdentity ConvertToAzureResourceIdentityResponse(Identity identity)
        {
            if (identity == null)
            {
                return null;
            }

            var azureResourceIdentity = new TopologyInstanceAzureResourceIdentity();
            azureResourceIdentity.PrincipalId = identity.PrincipalId;
            azureResourceIdentity.TenantId = identity.TenantId;
            if (identity.Type.HasValue)
            {
                azureResourceIdentity.Type = identity.Type.Value.ToString("G");
            }

            return azureResourceIdentity;
        }

        /// <summary>
        /// Removes shared resource entries from a previously migrated <see cref="TopologyInstance"/> and updates the source document.
        /// </summary>
        /// <param name="topologyInstance">The topology instance document.</param>
        /// <returns>The updated topology instance document.</returns>
        private TopologyInstance RemoveSharedResourcesFromMigratedTopology(
            TopologyInstance topologyInstance)
        {
            // If topology instance 'MigratedToSf' then strip shared resources from topology, otherwise return...
            string migrated;
            if (!topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.IsMigratedToSF, out migrated))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Skipping removal of shared resources for topology: {0}, because it was not in state: {1}.", topologyInstance.InstanceId, DeploymentState.MigratedToSF.ToString());
                return topologyInstance;
            }

            // Check if we have multiple version of data encryption and signing cert. Return error if true.
            bool multipleCertificateVersionsInstalledInSF;
            if (topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.MultipleCertificateVersionsInstalledInSF, out multipleCertificateVersionsInstalledInSF) && multipleCertificateVersionsInstalledInSF)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "MultipleCertificateVersionsInstalledInSF customization is enabled for topology: {0}.", topologyInstance.InstanceId);
            }
            else
            {
                CertificateDefinition dataEncryptionCert = topologyInstance.Certificates.FirstOrDefault(cert => string.Equals(cert.Identifier, CommonCertificateIdentifiers.DataEncryptionCertificate, StringComparison.OrdinalIgnoreCase));
                if (dataEncryptionCert != null)
                {
                    var secrets = KeyVaultClient.Instance.GetAllSecretVersions(dataEncryptionCert.KeyVaultableRawData.SecretUri);
                    if (secrets.Count() > 1)
                    {
                        ServiceException exception = new ServiceException(ServiceErrorCode.MultipleVersionsOfCertificateFound, CommonCertificateIdentifiers.DataEncryptionCertificate, topologyInstance.InstanceId, secrets.Count());
                        Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "Cannot delete environment due to multiple versions of data enncryption certificate.");
                        throw exception;
                    }
                }

                CertificateDefinition dataSigningCert = topologyInstance.Certificates.FirstOrDefault(cert => string.Equals(cert.Identifier, CommonCertificateIdentifiers.DataSigningCertificate, StringComparison.OrdinalIgnoreCase));
                if (dataSigningCert != null)
                {
                    var secrets = KeyVaultClient.Instance.GetAllSecretVersions(dataSigningCert.KeyVaultableRawData.SecretUri);
                    if (secrets.Count() > 1)
                    {
                        ServiceException exception = new ServiceException(ServiceErrorCode.MultipleVersionsOfCertificateFound, CommonCertificateIdentifiers.DataSigningCertificate, topologyInstance.InstanceId, secrets.Count());
                        Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, exception, "Cannot delete environment due to multiple versions of data enncryption certificate.");
                        throw exception;
                    }
                }
            }

            // Database Cleanup
            if (topologyInstance.DeploymentItems != null)
            {
                // AX Server
                var axDbServerDeploymentItem = topologyInstance.DeploymentItems
                    .Where(x => x.ItemName == CommonDeploymentItemNames.AxDBElasticSQLName)
                    .FirstOrDefault();
                if (axDbServerDeploymentItem != null)
                {
                    topologyInstance.DeploymentItems.Remove(axDbServerDeploymentItem);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the Deployment Item: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonDeploymentItemNames.AxDBElasticSQLName, topologyInstance.InstanceId);
                }

                // AX Database
                var axDbDeploymentItem = topologyInstance.DeploymentItems
                    .Where(x => x.ItemName == CommonCustomizationNames.AXDbDeploymentItemName)
                    .FirstOrDefault();
                if (axDbDeploymentItem != null)
                {
                    topologyInstance.DeploymentItems.Remove(axDbDeploymentItem);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the Deployment Item: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonCustomizationNames.AXDbDeploymentItemName, topologyInstance.InstanceId);
                }

                // EDW Server
                var axDwServerDeploymentItem = topologyInstance.DeploymentItems
                    .Where(x => x.ItemName == CommonDeploymentItemNames.EDWDBElasticSQLName)
                    .FirstOrDefault();
                if (axDwServerDeploymentItem != null)
                {
                    topologyInstance.DeploymentItems.Remove(axDwServerDeploymentItem);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the Deployment Item: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonDeploymentItemNames.EDWDBElasticSQLName, topologyInstance.InstanceId);
                }

                // EDW Database
                var axDwDeploymentItem = topologyInstance.DeploymentItems
                    .Where(x => x.ItemName == CommonCustomizationNames.AXDWDeploymentItemName)
                    .FirstOrDefault();
                if (axDwDeploymentItem != null)
                {
                    topologyInstance.DeploymentItems.Remove(axDwDeploymentItem);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the Deployment Item: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonCustomizationNames.AXDWDeploymentItemName, topologyInstance.InstanceId);
                }

                // MR Server
                var axmrServerDeploymentItem = topologyInstance.DeploymentItems
                    .Where(x => x.ItemName == CommonDeploymentItemNames.MRDBElasticSQLName)
                    .FirstOrDefault();
                if (axmrServerDeploymentItem != null)
                {
                    topologyInstance.DeploymentItems.Remove(axmrServerDeploymentItem);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the Deployment Item: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonDeploymentItemNames.MRDBElasticSQLName, topologyInstance.InstanceId);
                }

                // MR Database
                var mrdbDeploymentItem = topologyInstance.DeploymentItems
                    .Where(x => x.ItemName == CommonCustomizationNames.MRDbDeploymentItemName)
                    .FirstOrDefault();
                if (mrdbDeploymentItem != null)
                {
                    topologyInstance.DeploymentItems.Remove(mrdbDeploymentItem);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the Deployment Item: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonCustomizationNames.MRDbDeploymentItemName, topologyInstance.InstanceId);
                }

                // HostName Cleanup
                var aosDeploymentItem = topologyInstance.DeploymentItems
                    .Where(x => x.ItemName == CommonDeploymentItemNames.AOSDeploymentItem)
                    .FirstOrDefault();
                if (aosDeploymentItem != null)
                {
                    if (aosDeploymentItem.ApplicationEndpoints != null)
                    {
                        // Clear Application Endpoints
                        aosDeploymentItem.ApplicationEndpoints.Clear();
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the Deployment Item application endpoints for: {0}, from topology: {1}, due to this environment being in a migrated state where said resources are shared and should not be deleted.", CommonDeploymentItemNames.AOSDeploymentItem, topologyInstance.InstanceId);
                    }

                    if (aosDeploymentItem.Customizations != null)
                    {
                        var axEndpoint = aosDeploymentItem.Customizations.Where(x => x.FieldName == CommonCustomizationNames.AXEndpoint).FirstOrDefault();
                        if (axEndpoint != null)
                        {
                            aosDeploymentItem.Customizations.Remove(axEndpoint);
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the Deployment Item Customization: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonCustomizationNames.AXEndpoint, topologyInstance.InstanceId);
                        }

                        if (IsRetailCSUMigrationEnabled(topologyInstance, aosDeploymentItem))
                        {
                            var retEndpoint = aosDeploymentItem.Customizations.Where(x => x.FieldName == CommonCustomizationNames.RetailEndpoint).FirstOrDefault();
                            if (retEndpoint != null)
                            {
                                aosDeploymentItem.Customizations.Remove(retEndpoint);
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the Deployment Item Customization: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonCustomizationNames.RetailEndpoint, topologyInstance.InstanceId);
                            }

                            var posEndpoint = aosDeploymentItem.Customizations.Where(x => x.FieldName == CommonCustomizationNames.WebPosEndpoint).FirstOrDefault();
                            if (posEndpoint != null)
                            {
                                aosDeploymentItem.Customizations.Remove(posEndpoint);
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the Deployment Item Customization: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonCustomizationNames.WebPosEndpoint, topologyInstance.InstanceId);
                            }
                        }
                    }
                }
            }

            // Remove AOSService DNSZone entry
            if (topologyInstance.DnsRecordSets != null)
            {
                var aosServiceRecord = topologyInstance.DnsRecordSets
                    .Where(x => x.Identifier == CommonCustomizationNames.ApplicationEndpointNameAOSService)
                    .FirstOrDefault();
                if (aosServiceRecord != null)
                {
                    topologyInstance.DnsRecordSets.Remove(aosServiceRecord);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the DNS Record Set: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonCustomizationNames.ApplicationEndpointNameAOSService, topologyInstance.InstanceId);
                }

                var legacyServiceRecord = topologyInstance.DnsRecordSets
                    .Where(x => x.Identifier == CommonCustomizationNames.ApplicationEndpointNameAOSServiceSoap)
                    .FirstOrDefault();
                if (legacyServiceRecord != null)
                {
                    topologyInstance.DnsRecordSets.Remove(legacyServiceRecord);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the DNS Record Set: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonCustomizationNames.ApplicationEndpointNameAOSServiceSoap, topologyInstance.InstanceId);
                }

                bool isRetailCSUMigrationEnabled;
                if (topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.RetailCSUMigration, out isRetailCSUMigrationEnabled) && isRetailCSUMigrationEnabled)
                {
                    var retailServiceRecord = topologyInstance.DnsRecordSets
                    .Where(x => x.Identifier == CommonCustomizationNames.ApplicationEndpointNameRetailServer)
                    .FirstOrDefault();
                    if (retailServiceRecord != null)
                    {
                        topologyInstance.DnsRecordSets.Remove(retailServiceRecord);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the DNS Record Set: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonCustomizationNames.ApplicationEndpointNameRetailServer, topologyInstance.InstanceId);
                    }

                    var posServiceRecord = topologyInstance.DnsRecordSets
                    .Where(x => x.Identifier == CommonCustomizationNames.ApplicationEndpointNameWebPos)
                    .FirstOrDefault();
                    if (posServiceRecord != null)
                    {
                        topologyInstance.DnsRecordSets.Remove(posServiceRecord);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the DNS Record Set: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonCustomizationNames.ApplicationEndpointNameWebPos, topologyInstance.InstanceId);
                    }
                }
            }

            // Application storage Account
            if (topologyInstance.StorageAccounts != null)
            {
                var applicationStorageAccount = topologyInstance.StorageAccounts
                    .Where(x => x.LogicalName == CommonCustomizationNames.ApplicationStorageAccount)
                    .FirstOrDefault();
                if (applicationStorageAccount != null)
                {
                    topologyInstance.StorageAccounts.Remove(applicationStorageAccount);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the Storage Account: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonCustomizationNames.ApplicationStorageAccount, topologyInstance.InstanceId);
                }
            }

            // Remove ServiceControllerModule
            if (topologyInstance.Modules != null)
            {
                var serviceControllerModule = topologyInstance.Modules
                    .Where(x => x.Name == CommonCustomizationNames.ServiceControllerModule)
                    .FirstOrDefault();
                if (serviceControllerModule != null)
                {
                    topologyInstance.Modules.Remove(serviceControllerModule);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Removed the Module: {0}, from topology: {1}, due to this environment being in a migrated state where said resource is shared and should not be deleted.", CommonCustomizationNames.ServiceControllerModule, topologyInstance.InstanceId);
                }
            }

            return topologyInstance;
        }

        /// <summary>
        /// Check if retail CSU migration is enabled
        /// </summary>
        /// <param name="topologyInstance">The topology instance name.</param>
        /// <param name="aosDeploymentItem">AOS deployment item.</param>
        /// <returns>Returns true if retail csu migration is enabled.</returns>
        private static bool IsRetailCSUMigrationEnabled(TopologyInstance topologyInstance, DeploymentItem aosDeploymentItem)
        {
            bool isRetailCSUMigrationEnabled = false;
            try
            {
                if (topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.RetailCSUMigration, out isRetailCSUMigrationEnabled) && isRetailCSUMigrationEnabled)
                {
                    return isRetailCSUMigrationEnabled;
                }

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} customization is not tagged for topology: {1}, check DNS host name.", CommonCustomizationNames.RetailCSUMigration, topologyInstance.InstanceId);

                // Extract hostname from "https://{envname}ret.operations.dynamics.com/Commerce"
                var retailEndpoint = aosDeploymentItem.Customizations.Where(x => x.FieldName == CommonCustomizationNames.RetailEndpoint).FirstOrDefault();
                if (retailEndpoint != null)
                {
                    // Get host name
                    string[] adressSplit = retailEndpoint.SelectedValue.Split('/');
                    if (adressSplit.Length > 2)
                    {
                        string hostName = adressSplit[2];
                        IPHostEntry hostEntry = System.Net.Dns.GetHostEntry(hostName);
                        if (hostEntry != null && !string.IsNullOrEmpty(hostEntry.HostName))
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "{0} resolved to host name {1} for topology {2}.", hostName, hostEntry.HostName, topologyInstance.InstanceId);
                            var retailHostName = topologyInstance.ReservedIPs.FirstOrDefault(x => x.EnvironmentGroup == EnvironmentGroup.Primary && x.Identifier == DeploymentConstants.RetailIdenitifier);
                            if (retailHostName != null && hostEntry.HostName != retailHostName.Address)
                            {
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Retail CSU migration is enabled for topology {0} since nslookup hostname {1} matches to hostname {2} in topology.", topologyInstance.InstanceId, hostEntry.HostName, retailHostName.Address);
                                isRetailCSUMigrationEnabled = true;
                            }
                            else
                            {
                                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Retail CSU migration is not enabled for topology {0} since nslookup hostname {1} matches to hostname in topology.", topologyInstance.InstanceId, hostEntry.HostName);
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, ex, "Failed to check retail csu migration enablement for topology {0}.", topologyInstance.InstanceId);
            }

            return isRetailCSUMigrationEnabled;
        }

        /// <summary>
        /// Stamps the request with any custom feature flags.
        /// </summary>
        /// <param name="request">The request.</param>
        /// <param name="action">The specific DeploymentAction we are running for the request.</param>
        /// <param name="errorMessage">Response containing the reason why the topology cannot be processed, if any.</param>
        /// <returns>Returns a boolean indicating if the operation was successful or not.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool TryProcessDeploymentFeature(DeploymentRequest request, DeploymentRequest.DeploymentAction action, out HttpResponseMessage errorMessage)
        {
            try
            {
                // Enables or disables certain features.
                FeatureConfiguration.DeploymentConfiguration.AddConfiguredFeatures(action, request);
                errorMessage = null;
                return true;
            }
            catch (Exception ex)
            {
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, ex, "Failed to set feature configuration on the deployment instance.");
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.ErrorStampingTheRequestWithFeatureConfiguration);
                return false;
            }
        }

        /// <summary>
        /// Action used to Migrate a deployment instance to either a Azure Server or an elastic pool.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant the topology instance belongs to.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology instance.</param>
        /// <param name="parameters">The parameters of the OData action.</param>
        /// <param name="toElasticPool">Boolean indicating the direction of the migration.</param>
        /// <returns>An HTTPResponseMessage.</returns>
        private HttpResponseMessage MigrateDatabase(Guid tenantId, Guid azureSubscriptionId, string topologyInstanceId, ODataActionParameters parameters, bool toElasticPool)
        {
            DeploymentInstance deploymentInstance = null;
            TopologyInstance topologyInstance = null;
            TopologyInstanceTableItem topologyInstanceRow = null;
            DeploymentState deploymentState = DeploymentState.Migrating;
            DeploymentRequest.DeploymentAction action = DeploymentRequest.DeploymentAction.ExecuteMigration;
            TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

            try
            {
                Uri deploymentInstanceBlobUri;
                HttpResponseMessage errorMessage;

                if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
                {
                    return errorMessage;
                }

                if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, EnvironmentGroup.Primary, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                {
                    return errorMessage;
                }

                // Migration request mode.
                string migrationRequestMode = this.GetParameterOrDefault<string>(parameters, CommonDeploymentActionParameters.RequestMode, DeploymentConstants.DBMigrationStandAloneRequest);

                // Validate deployment state.
                if (migrationRequestMode == DeploymentConstants.DBMigrationStandAloneRequest && (deploymentInstance.DeploymentState != DeploymentState.Finished || deploymentInstance.DeploymentStatus != Model.DeploymentStatus.Succeeded))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}], status: [{5}].", action, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.Finished, Model.DeploymentStatus.Succeeded);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, topologyInstanceId);
                }

                if (migrationRequestMode == DeploymentConstants.DBMigrationContinuousCopyRequest && (deploymentInstance.DeploymentState != DeploymentState.PreppedForMigration || deploymentInstance.DeploymentStatus != Model.DeploymentStatus.Succeeded))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}], status: [{5}].", action, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.PreppedForMigration, Model.DeploymentStatus.Succeeded);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, topologyInstanceId);
                }

                // Check if Database Management System Endpoint and Resource defined in the ServiceModel Configuration.
                if (string.IsNullOrEmpty(DbmsConfig.DbmsManagementEndpoint) || string.IsNullOrEmpty(DbmsConfig.DbmsManagementResource))
                {
                    Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "There is either no Database Management System Endpoint or Resource defined in the ServiceModel Configuration.");

                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_NoDatabaseManagementSystemEndpointOrResourceDefined);
                }

                // Check if elastic pool enabled for the region.
                string deploymentLocation = topologyInstance.CloudStorageLocation;
                string deploymentFailoverLocation = topologyInstance.DisasterRecoveryLocation;
                string topologySkuType;

                if (!AzureSQLLocations.IsElasticPoolSupported(deploymentLocation) ||
                (topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.LcsEnvironmentTag, out topologySkuType) && string.Equals(topologySkuType, CommonCustomizationNames.LcsEnvironmentTagProd, StringComparison.OrdinalIgnoreCase) && !AzureSQLLocations.IsElasticPoolSupported(deploymentFailoverLocation)))
                {
                    Tracer.WriteExecutionEvent(
                    TraceComponent.DeploymentServiceApi,
                    "The region and/or its failover region are not supported for elastic pool deployments.",
                    topologyInstance.InstanceId);

                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RegionNotSupportedForElasticPoolDeployments, deploymentLocation, deploymentFailoverLocation);
                }

                // Check if environment have an active staging.
                TopologyInstance stagingTopologyInstance;
                TopologyInstanceTableItem stagingTopologyInstanceRow;
                if (this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, EnvironmentGroup.Staging, out stagingTopologyInstance, out errorMessage, out stagingTopologyInstanceRow))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Found an active staging environment for topology instance '{0}' during delete of the primary environment.", topologyInstanceId);
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_DeleteStagingBeforePrimary, topologyInstanceId);
                }

                // Backwards compatibility: Migrate Topology Instance as needed.
                MigrationLibrary.MigrateTopology(topologyInstance);

                // verify input parameters
                IEnumerable<string> databaseTypes;
                if (parameters == null || !this.TryProcessParameter(parameters, CommonDeploymentActionParameters.DatabaseType, out databaseTypes, out errorMessage))
                {
                    return errorMessage;
                }

                List<string> eligibleDatabase = ReadEligibleDatabaseTypesParameterForElasticPoolMigration(databaseTypes, topologyInstance, migrationRequestMode, toElasticPool);

                if (eligibleDatabase.Count == 0)
                {
                    return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNonElasticPoolServer, string.Format(CultureInfo.InvariantCulture, "Migrate Database to {0} failed because no eligible database were found.", toElasticPool ? "ElasticPool" : "AzureServer"));
                }

                deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
                deploymentInstance.Initialize(topologyInstance, true);

                string databaseTypeParametersString = CommonUtilities.SerializeJson<List<string>>(eligibleDatabase);

                // Overriding default Gomez maintenance window.
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.HealthDowntimeWindowInHours, ((int)TimeSpan.FromHours(DeploymentConstants.DBMigrationMaintenanceWindow).TotalHours).ToString("F0", CultureInfo.CurrentCulture));
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.DatabaseType, databaseTypeParametersString);
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.RequestMode, migrationRequestMode);
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.DatabaseMigrationDirection, toElasticPool ? DeploymentConstants.DBMigrationSingleToElastic : DeploymentConstants.DBMigrationElasticToSingle);

                DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

                if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentServiceDBMigrationWorkflow.TaskNameConstant, out errorMessage, deploymentState))
                {
                    return errorMessage;
                }
                else
                {
                    return Request.CreateResponse(HttpStatusCode.OK);
                }
            }
            catch (ServiceException serviceException)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    serviceException,
                    "Failed to Migrate Database '{0}' in Azure Subscription '{1}' of tenant '{2}'. ErrorCode='{3}'",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId,
                    serviceException.ErrorCode);

                HttpResponseMessage errorMessage = this.CreateErrorResponse(serviceException);
                this.TraceCustomerActionError(tenantId, azureSubscriptionId, topologyInstanceId, action, errorMessage);

                if (tenantRegistration != null && topologyInstance != null)
                {
                    this.OnValidationFailed(topologyInstance, tenantRegistration, action, topologyInstance);
                }

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, serviceException, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                return errorMessage;
            }
            catch (Exception error)
            {
                Tracer.WriteErrorEvent(
                    TraceComponent.DeploymentServiceApi,
                    error,
                    "Failed to Migrate Database'{0}' in Azure Subscription '{1}' of tenant '{2}'.",
                    topologyInstanceId,
                    azureSubscriptionId,
                    tenantId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, error, "REQUEST: '{0}'", this.Request.RequestUri.ToString());

                throw;
            }
        }

        /// <summary>
        /// Read Migration action parameters from OData request body.
        /// </summary>
        /// <param name="parameters">OData parameters.</param>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="deploymentInstance">The deployment instance.</param>
        /// <param name="deploymentState">The deployment state.</param>
        /// <param name="actionToExecute">A Migration action to execute.</param>
        /// <param name="parameterValues">The deployment action parameters.</param>
        /// <param name="errorMessage">An error message, if any occured.</param>
        /// <returns>True if parsed successfully, false otherwise.</returns>
        private bool ReadMigrationActionParameters(
            ODataActionParameters parameters,
            DeploymentRequest.DeploymentAction action,
            TopologyInstance topologyInstance,
            DeploymentInstance deploymentInstance,
            ref DeploymentState deploymentState,
            out ElasticPoolMigrationActionType actionToExecute,
            out IDictionary<string, string> parameterValues,
            out HttpResponseMessage errorMessage)
        {
            actionToExecute = ElasticPoolMigrationActionType.None;
            parameterValues = new Dictionary<string, string>();
            errorMessage = null;
            string migrationStatus;
            string migrationState;

            string actionToExecuteString = this.GetParameterOrDefault<string>(parameters, CommonDeploymentActionParameters.ElasticPoolMigrationActionType, string.Empty);

            if (!Enum.TryParse(actionToExecuteString, out actionToExecute) || actionToExecute == ElasticPoolMigrationActionType.None)
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    actionToExecuteString,
                    CommonDeploymentActionParameters.ElasticPoolMigrationActionType);
                return false;
            }

            switch (actionToExecute)
            {
                case ElasticPoolMigrationActionType.InitiateMigrationPreChecks:
                case ElasticPoolMigrationActionType.FinishMigrationPreChecks:
                    deploymentState = DeploymentState.InfrastructureMaintenance;
                    this.ValidateMigrationPrechecks(actionToExecute, topologyInstance, deploymentInstance);
                    break;
                case ElasticPoolMigrationActionType.InitiatePrepareElasticPoolDatabaseMigration:
                case ElasticPoolMigrationActionType.FinishPrepareElasticPoolDatabaseMigration:
                    deploymentState = DeploymentState.PreparingForMigration;
                    this.ValidatePrepareElasticPoolDatabaseMigration(actionToExecute, topologyInstance, deploymentInstance);
                    break;
                case ElasticPoolMigrationActionType.InitiateElasticPoolDatabaseMigration:
                case ElasticPoolMigrationActionType.FinishElasticPoolDatabaseMigration:
                    deploymentState = DeploymentState.Migrating;
                    string migrationRequestMode;
                    string databaseMigrationDirection;

                    IEnumerable<string> databaseTypes;

                    if (!this.TryValidateElasticPoolDatabaseMigrationAction(actionToExecute, topologyInstance, deploymentInstance, parameters, out migrationRequestMode, out databaseMigrationDirection, out databaseTypes, out migrationState, out migrationStatus, out errorMessage))
                    {
                        return false;
                    }

                    // Add the deployment action parameters for migrate database action.
                    string databaseTypeParametersString = CommonUtilities.SerializeJson<IEnumerable<string>>(databaseTypes);

                    parameterValues.Add(CommonDeploymentActionParameters.RequestMode, migrationRequestMode);
                    parameterValues.Add(CommonDeploymentActionParameters.DatabaseType, databaseTypeParametersString);
                    parameterValues.Add(CommonDeploymentActionParameters.DatabaseMigrationDirection, databaseMigrationDirection);

                    if (actionToExecute == ElasticPoolMigrationActionType.FinishElasticPoolDatabaseMigration)
                    {
                        parameterValues.Add(CommonDeploymentActionParameters.ElasticPoolMigrationState, migrationState);
                        parameterValues.Add(CommonDeploymentActionParameters.ElasticPoolMigrationStatus, migrationStatus);
                    }

                    break;
                case ElasticPoolMigrationActionType.InitiateSpartanAlterScaleMigration:
                case ElasticPoolMigrationActionType.FinishSpartanAlterScaleMigration:
                    deploymentState = DeploymentState.Migrating;
                    this.ValidateMigrationPrechecks(actionToExecute, topologyInstance, deploymentInstance);
                    break;
                case ElasticPoolMigrationActionType.InitiateConfiguration:
                case ElasticPoolMigrationActionType.FinishConfiguration:
                case ElasticPoolMigrationActionType.FinishConfigurationEnableMonitoring:
                    deploymentState = DeploymentState.Migrating;
                    if (actionToExecute == ElasticPoolMigrationActionType.FinishConfiguration || actionToExecute == ElasticPoolMigrationActionType.FinishConfigurationEnableMonitoring)
                    {
                        migrationState = this.GetParameterOrDefault<string>(parameters, CommonDeploymentActionParameters.ElasticPoolMigrationState, string.Empty);
                        migrationStatus = this.GetParameterOrDefault<string>(parameters, CommonDeploymentActionParameters.ElasticPoolMigrationStatus, string.Empty);

                        parameterValues.Add(CommonDeploymentActionParameters.ElasticPoolMigrationState, migrationState);
                        parameterValues.Add(CommonDeploymentActionParameters.ElasticPoolMigrationStatus, migrationStatus);
                    }

                    break;
                default:
                    throw new NotSupportedException(actionToExecute.ToString());
            }

            return true;
        }

        /// <summary>
        /// Read eligible database types parameter for elastic pool migration.
        /// </summary>
        /// <param name="databaseTypes">The list of database types requested for migration.</param>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="migrationRequestMode">The migration request mode.</param>
        /// <param name="toElasticPool">Boolean indicating the direction of the migration.</param>
        /// <returns>List of eligible databases.</returns>
        private List<string> ReadEligibleDatabaseTypesParameterForElasticPoolMigration(
            IEnumerable<string> databaseTypes,
            TopologyInstance topologyInstance,
            string migrationRequestMode,
            bool toElasticPool)
        {
            List<string> eligibleDatabase = new List<string>();
            foreach (string database in databaseTypes)
            {
                DeploymentItem azureSQLDatabaseItem = topologyInstance.DeploymentItems.GetFirst(database);

                // Check if the selected database is single.
                if ((azureSQLDatabaseItem.IsElasticPoolEnabled() && toElasticPool) || (!azureSQLDatabaseItem.IsElasticPoolEnabled() && !toElasticPool))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The action Migrate Database to {0} is not allowed to be performed on databases already on {0}. Database is {1}", toElasticPool ? "ElasticPool" : "AzureServer", database);
                    continue;
                }

                // Continuous copy is not required for AxDW.
                if (String.Compare(database, CommonCustomizationNames.AXDWDeploymentItemName, StringComparison.OrdinalIgnoreCase) != 0)
                {
                    // Check continuous copy database stamp in topology.
                    string migration_Linked_Server = string.Empty;
                    string migration_Linked_Database = string.Empty;
                    string migration_DBMS_StatusUri = string.Empty;

                    if (migrationRequestMode == DeploymentConstants.DBMigrationContinuousCopyRequest && !(azureSQLDatabaseItem.TryGetCustomizationValue(CommonCustomizationNames.DatabaseMigrationLinkedServer, out migration_Linked_Server) && azureSQLDatabaseItem.TryGetCustomizationValue(CommonCustomizationNames.DatabaseMigrationLinkedDatabase, out migration_Linked_Database) && azureSQLDatabaseItem.TryGetCustomizationValue(CommonCustomizationNames.DatabaseMigrationDBMSStatusUri, out migration_DBMS_StatusUri)))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The continuous copy database stamp not found in topology for database type {0}. The action Migrate Database to {1} cannot be performed.", database, toElasticPool ? "ElasticPool" : "AzureServer");
                        continue;
                    }
                    else if (migrationRequestMode == DeploymentConstants.DBMigrationContinuousCopyRequest)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The continuous copy database stamp found in topology for database type {0}. migration_Linked_Server: {1}, migration_Linked_Database {2}, migration_DBMS_StatusUri {3}", database, migration_Linked_Server, migration_Linked_Database, migration_DBMS_StatusUri);
                    }
                }

                eligibleDatabase.Add(database);
            }

            return eligibleDatabase;
        }

        /// <summary>
        /// Validate migration pre-checks.
        /// </summary>
        /// <param name="migrationAction">The migration Action.</param>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="deploymentInstance">The deployment instance.</param>
        private void ValidateMigrationPrechecks(ElasticPoolMigrationActionType migrationAction, TopologyInstance topologyInstance, DeploymentInstance deploymentInstance)
        {
            string deploymentLocation = topologyInstance.CloudStorageLocation;
            string deploymentFailoverLocation = topologyInstance.DisasterRecoveryLocation;
            string topologySkuType;
            if (!AzureSQLLocations.IsElasticPoolSupported(deploymentLocation) ||
                (topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.LcsEnvironmentTag, out topologySkuType) && string.Equals(topologySkuType, CommonCustomizationNames.LcsEnvironmentTagProd, StringComparison.OrdinalIgnoreCase) && !AzureSQLLocations.IsElasticPoolSupported(deploymentFailoverLocation)))
            {
                Tracer.WriteExecutionEvent(
                  TraceComponent.DeploymentServiceApi,
                  "The azure region and/or its failover azure region are not supported for elastic pool deployments.",
                  topologyInstance.InstanceId);
                throw new ServiceException(string.Format(CultureInfo.InvariantCulture, "The azure region and/or its failover azure region are not supported for elastic pool deployments. For TopologyInstanceId {0}", topologyInstance.InstanceId));
            }

            if ((migrationAction == ElasticPoolMigrationActionType.InitiateMigrationPreChecks || migrationAction == ElasticPoolMigrationActionType.InitiateSpartanAlterScaleMigration)
                && (deploymentInstance.DeploymentState != DeploymentState.Finished || deploymentInstance.DeploymentStatus != Model.DeploymentStatus.Succeeded))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}], status: [{5}].", migrationAction, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.Finished, Model.DeploymentStatus.Succeeded);
                throw new ServiceException(string.Format(CultureInfo.InvariantCulture, "Attempted to[{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}], status: [{5}].", migrationAction, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.Finished, Model.DeploymentStatus.Succeeded));
            }
        }

        /// <summary>
        /// Validate Prepare EP database migration.
        /// </summary>
        /// <param name="migrationAction">The migration Action.</param>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="deploymentInstance">The deployment instance.</param>
        private void ValidatePrepareElasticPoolDatabaseMigration(ElasticPoolMigrationActionType migrationAction, TopologyInstance topologyInstance, DeploymentInstance deploymentInstance)
        {
            // Check if previous deployment is in expected state.
            if ((migrationAction == ElasticPoolMigrationActionType.InitiateMigrationPreChecks || migrationAction == ElasticPoolMigrationActionType.InitiatePrepareElasticPoolDatabaseMigration)
                && (deploymentInstance.DeploymentState != DeploymentState.Finished || deploymentInstance.DeploymentStatus != Model.DeploymentStatus.Succeeded))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}], status: [{5}].", migrationAction, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.Finished, Model.DeploymentStatus.Succeeded);
                throw new ServiceException(string.Format(CultureInfo.InvariantCulture, "Attempted to[{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}], status: [{5}].", migrationAction, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.Finished, Model.DeploymentStatus.Succeeded));
            }
            else if (migrationAction == ElasticPoolMigrationActionType.FinishPrepareElasticPoolDatabaseMigration
                && !(deploymentInstance.DeploymentState == DeploymentState.PreparingForMigration || deploymentInstance.DeploymentState == DeploymentState.PreppedForMigration))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}].", migrationAction, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.PreparingForMigration);
                throw new ServiceException(string.Format(CultureInfo.InvariantCulture, "Attempted to[{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}].", migrationAction, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.PreparingForMigration));
            }
        }

        /// <summary>
        /// Validate elastic pool migration action.
        /// </summary>
        /// <param name="migrationAction">The migration action to execute.</param>
        /// <param name="topologyInstance">The topology instance.</param>
        /// <param name="deploymentInstance">The deployment instance.</param>
        /// <param name="parameters">OData parameters.</param>
        /// <param name="migrationRequestMode">The migration request mode.</param>
        /// <param name="databaseMigrationDirection">The database migration direction.</param>
        /// <param name="databaseTypes">The list of database types to migrate.</param>
        /// <param name="migrationState">The state of migration.</param>
        /// <param name="migrationStatus">The status of migration.</param>
        /// <param name="errorMessage">An error message, if any occured.</param>
        /// <returns>Is validation successful</returns>
        private bool TryValidateElasticPoolDatabaseMigrationAction(ElasticPoolMigrationActionType migrationAction, TopologyInstance topologyInstance, DeploymentInstance deploymentInstance, ODataActionParameters parameters, out string migrationRequestMode, out string databaseMigrationDirection, out IEnumerable<string> databaseTypes, out string migrationState, out string migrationStatus, out HttpResponseMessage errorMessage)
        {
            migrationRequestMode = string.Empty;
            databaseMigrationDirection = string.Empty;
            databaseTypes = null;
            migrationState = string.Empty;
            migrationStatus = string.Empty;
            errorMessage = null;

            migrationRequestMode = this.GetParameterOrDefault<string>(parameters, CommonDeploymentActionParameters.RequestMode, DeploymentConstants.DBMigrationStandAloneRequest);

            // Check if previous deployment is in expected state.
            if (migrationAction == ElasticPoolMigrationActionType.InitiateElasticPoolDatabaseMigration && string.Equals(migrationRequestMode, DeploymentConstants.DBMigrationStandAloneRequest, StringComparison.OrdinalIgnoreCase)
                && (deploymentInstance.DeploymentState != DeploymentState.Finished || deploymentInstance.DeploymentStatus != Model.DeploymentStatus.Succeeded))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}], status: [{5}].", migrationAction, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.Finished, Model.DeploymentStatus.Succeeded);
                errorMessage = this.CreateErrorResponse(string.Format(CultureInfo.InvariantCulture, "Attempted to[{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}], status: [{5}].", migrationAction, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.Finished, Model.DeploymentStatus.Succeeded));

                return false;
            }
            else if (migrationAction == ElasticPoolMigrationActionType.InitiateElasticPoolDatabaseMigration && string.Equals(migrationRequestMode, DeploymentConstants.DBMigrationContinuousCopyRequest, StringComparison.OrdinalIgnoreCase)
                && (deploymentInstance.DeploymentState != DeploymentState.PreppedForMigration || deploymentInstance.DeploymentStatus != Model.DeploymentStatus.Succeeded))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}], status: [{5}].", migrationAction, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.PreppedForMigration, Model.DeploymentStatus.Succeeded);
                errorMessage = this.CreateErrorResponse(string.Format(CultureInfo.InvariantCulture, "Attempted to[{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}], status: [{5}].", migrationAction, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.PreppedForMigration, Model.DeploymentStatus.Succeeded));

                return false;
            }
            else if (migrationAction == ElasticPoolMigrationActionType.FinishElasticPoolDatabaseMigration
                && !(deploymentInstance.DeploymentState == DeploymentState.Migrating || deploymentInstance.DeploymentState == DeploymentState.PreppedForMigration))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}] or [{5}].", migrationAction, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.Migrating, DeploymentState.PreppedForMigration);
                errorMessage = this.CreateErrorResponse(string.Format(CultureInfo.InvariantCulture, "Attempted to[{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}], status [{3}]. Expected state: [{4}] or [{5}].", migrationAction, topologyInstance, deploymentInstance.DeploymentState, deploymentInstance.DeploymentStatus, DeploymentState.Migrating, DeploymentState.PreppedForMigration));

                return false;
            }

            // Read migrationDirection parameter.
            bool toElastic;
            string migrationDirection = this.GetParameterOrDefault<string>(parameters, CommonDeploymentActionParameters.DatabaseMigrationDirection, null);
            if (string.Equals(migrationDirection, Library.Model.ServiceConstants.DBMigrationSingleToElastic, StringComparison.OrdinalIgnoreCase))
            {
                databaseMigrationDirection = DeploymentConstants.DBMigrationSingleToElastic;
                toElastic = true;
            }
            else if (string.Equals(migrationDirection, Library.Model.ServiceConstants.DBMigrationElasticToSingle, StringComparison.OrdinalIgnoreCase))
            {
                databaseMigrationDirection = DeploymentConstants.DBMigrationElasticToSingle;
                toElastic = false;
            }
            else if (string.Equals(migrationDirection, Library.Model.ServiceConstants.DBMigrationElasticToElastic, StringComparison.OrdinalIgnoreCase))
            {
                databaseMigrationDirection = Library.Model.ServiceConstants.DBMigrationElasticToElastic;
                toElastic = false;
            }
            else
            {
                errorMessage = this.CreateErrorResponse(string.Format(CultureInfo.InvariantCulture, "Unsupported MigrationDirection  '{0}' .", migrationDirection));
                return false;
            }

            // Read database types selected for migration
            if (parameters == null || !this.TryProcessParameter(parameters, CommonDeploymentActionParameters.DatabaseType, out databaseTypes, out errorMessage))
            {
                return false;
            }

            if (migrationAction == ElasticPoolMigrationActionType.InitiateElasticPoolDatabaseMigration)
            {
                databaseTypes = ReadEligibleDatabaseTypesParameterForElasticPoolMigration(databaseTypes, topologyInstance, migrationRequestMode, toElastic);
            }

            // Get the migration state and status
            migrationState = string.Empty;
            migrationStatus = string.Empty;

            if (migrationAction == ElasticPoolMigrationActionType.FinishElasticPoolDatabaseMigration)
            {
                migrationState = this.GetParameterOrDefault<string>(parameters, CommonDeploymentActionParameters.ElasticPoolMigrationState, null);
                migrationStatus = this.GetParameterOrDefault<string>(parameters, CommonDeploymentActionParameters.ElasticPoolMigrationStatus, null);

                Dynamics.Cloud.Infrastructure.MigrationManager.DataContracts.MigrationState migrationStateValue;
                if (!Enum.TryParse<Dynamics.Cloud.Infrastructure.MigrationManager.DataContracts.MigrationState>(migrationState, out migrationStateValue))
                {
                    Tracer.WriteExecutionEvent(
                      TraceComponent.DeploymentServiceApi,
                      "The value [{0}] for parameter ElasticPoolMigrationState is invalid  for TopologyInstanceId [{1}].",
                      migrationState,
                      topologyInstance.InstanceId);

                    errorMessage = this.CreateErrorResponse(string.Format(CultureInfo.InvariantCulture, "The value [{0}] for parameter ElasticPoolMigrationState is invalid  for TopologyInstanceId [{1}].", migrationState, topologyInstance.InstanceId));

                    return false;
                }

                Dynamics.Cloud.Infrastructure.MigrationManager.DataContracts.MigrationStatus migrationStatusValue;
                if (!Enum.TryParse(migrationStatus, out migrationStatusValue))
                {
                    Tracer.WriteExecutionEvent(
                      TraceComponent.DeploymentServiceApi,
                      "The value [{0}] for parameter ElasticPoolMigrationStatus is invalid  for TopologyInstanceId [{1}].",
                      migrationStatus,
                      topologyInstance.InstanceId);

                    errorMessage = this.CreateErrorResponse(string.Format(CultureInfo.InvariantCulture, "The value [{0}] for parameter ElasticPoolMigrationState is invalid  for TopologyInstanceId [{1}].", migrationStatus, topologyInstance.InstanceId));

                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Validates if the given enviornment had pervious failed operation which supports resume.
        /// </summary>
        /// <param name="topologyInstance">Target topology instance.</param>
        /// <param name="deploymentInstance">Target deployment instance.</param>
        /// <param name="action">Target action.</param>
        /// <param name="errorMessage">Error response.</param>
        /// <returns>Whether or not the pervious resume supported operation failed.</returns>
        private bool IsResumeSupportedOperationInFailedState(TopologyInstance topologyInstance, DeploymentInstance deploymentInstance, DeploymentRequest.DeploymentAction action, out HttpResponseMessage errorMessage)
        {
            errorMessage = null;
            bool resumeSupportedOperationInFailedState = false;
            // Execute Geneva Actions is blocked when last servicing/data movement operation is in failed state.
            if (deploymentInstance.IsServicingOperation() || deploymentInstance.IsDBMovementOperation())
            {
                if (topologyInstance.DeploymentStatus == Model.DeploymentStatus.Failed || deploymentInstance.DeploymentStatus == Model.DeploymentStatus.Failed)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] on topology [{1}] but the last Servicing/Datamovement operation failed on this enviornment [{2}].", action, topologyInstance, deploymentInstance.DeploymentStatus);
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "[{0}]", topologyInstance.ToStringStateStatus());
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "[{0}]", deploymentInstance.ToStringStateStatus());
                    errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, action);
                    resumeSupportedOperationInFailedState = true;
                }
            }
            return resumeSupportedOperationInFailedState;
        }

        private bool TrySetCdsEnvironmentDefaultValues(TopologyInstance topologyInstance, out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            try
            {
                DeploymentItem cdsDeploymentItem = topologyInstance.GetCdsEnvironmentItem();
                if (cdsDeploymentItem == null)
                {
                    Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, "CDS deployment item is not in the topology. Skipping setting default CDS values.");

                    return true;
                }

                bool configureCds;
                if (!cdsDeploymentItem.TryGetCustomizationValue<bool>(CommonCustomizationNames.CdsEnvironmentConfigure, out configureCds) || !configureCds)
                {
                    Tracer.LogExecutionEvent(TraceComponent.DeploymentServiceApi, "CDS configuration is disabled in the topology. Skipping setting default CDS values.");

                    return true;
                }

                CdsConfigurationHelper.SetCdsEnvironmentDefaultValues(topologyInstance);
            }
            catch
            {
                errorMessage = this.CreateErrorResponse($"Unable to set Common Data Service environment defaults. Either process without Common Data Service environment or contact the support.");

                return false;
            }

            return true;
        }

        #endregion Helpers

        #region Geneva actions

        /// <summary>
        /// Read Geneva action parameters from OData request body.
        /// </summary>
        /// <param name="parameters">OData parameters.</param>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="environmentGroup">The environment group.</param>
        /// <param name="genevaActionToExecute">A Geneva action to execute.</param>
        /// <param name="parameterValues">A dictionary with parameters for specified Geneva action.</param>
        /// <param name="errorMessage">An error message, if any occured.</param>
        /// <returns>True if parsed successfully, false otherwise.</returns>
        private bool ReadGenevaActionParameters(
            ODataActionParameters parameters,
            DeploymentRequest.DeploymentAction action,
            EnvironmentGroup environmentGroup,
            out GenevaActionType genevaActionToExecute,
            out IDictionary<string, object> parameterValues,
            out HttpResponseMessage errorMessage)
        {
            genevaActionToExecute = GenevaActionType.None;
            parameterValues = null;
            errorMessage = null;

            string genevaActionToExecuteString = parameters.ContainsKey(CommonDeploymentActionParameters.GenevaActionToRun)
                ? (string)parameters[CommonDeploymentActionParameters.GenevaActionToRun]
                : null;

            if (!Enum.TryParse(genevaActionToExecuteString, out genevaActionToExecute) || genevaActionToExecute == GenevaActionType.None)
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    genevaActionToExecuteString,
                    CommonDeploymentActionParameters.GenevaActionToRun);
                return false;
            }
            Dictionary<string, object> parametersDictionary = new Dictionary<string, object>();

            if (genevaActionToExecute == GenevaActionType.StartApplicationGateway
                || genevaActionToExecute == GenevaActionType.StopApplicationGateway
                || genevaActionToExecute == GenevaActionType.DeleteApplicationGateway
                || genevaActionToExecute == GenevaActionType.ResizeApplicationGateway
                || genevaActionToExecute == GenevaActionType.AddToApplicationGatewayBackendPool
                || genevaActionToExecute == GenevaActionType.RemoveFromApplicationGatewayBackendPool)
            {
                parametersDictionary.Add(CommonDeploymentActionParameters.EnvironmentGroup, (string)parameters[CommonDeploymentActionParameters.EnvironmentGroup]);
            }

            string parametersJsonString = parameters.ContainsKey(CommonDeploymentActionParameters.GenevaActionParameters)
                ? (string)parameters[CommonDeploymentActionParameters.GenevaActionParameters]
                : null;

            if (!string.IsNullOrEmpty(parametersJsonString))
            {
                JObject parametersObj = JObject.Parse(parametersJsonString);

                switch (genevaActionToExecute)
                {
                    case GenevaActionType.RecycleIISAppPool:
                        if (!this.ReadRecycleIISAppPoolGenevaActionParameters(action, environmentGroup, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }

                        break;
                    case GenevaActionType.RestartVM:
                        if (!this.ReadRestartVMGenevaActionParameters(action, environmentGroup, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }

                        break;
                    case GenevaActionType.InvokeSQL:
                        if (!this.ReadInvokeSQLGenevaActionParameters(action, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }

                        break;
                    case GenevaActionType.CollectMemoryDumpAppPool:
                        if (!this.ReadCollectMemoryDumpGenevaActionParameters(action, environmentGroup, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }

                        break;
                    case GenevaActionType.ResizeDatabase:
                        if (!this.ReadResizeDatabaseGenevaActionParameters(action, environmentGroup, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }

                        break;
                    case GenevaActionType.CopyDatabaseToAnotherEnvironment:
                        if (!this.ReadCopyDatabaseGenevaActionParameters(action, environmentGroup, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }

                        break;
                    case GenevaActionType.DataMartReset:
                        break;
                    case GenevaActionType.FetchVersionInfo:
                        break;
                    case GenevaActionType.ExecutePostServicing:
                        if (!this.ReadExecutePostServicingGenevaActionParameters(action, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }

                        break;
                    case GenevaActionType.DisableEnvironment:
                        if (!this.ReadDisableTenantEnvironmentsGenevaActionParameters(action, environmentGroup, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }

                        break;

                    case GenevaActionType.EnableEnvironment:
                        if (!this.ReadEnableEnvironmentsGenevaActionParameters(action, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }

                        break;
                    case GenevaActionType.ResizeVM:
                        if (!this.ReadResizeVMGenevaActionParameters(action, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }

                        break;
                    case GenevaActionType.MigrateToSSRSService:
                        break;

                    case GenevaActionType.MigrateToBIVM:
                        break;

                    case GenevaActionType.RepublishToLocator:
                        break;

                    case GenevaActionType.IISMigrateProtocolToHttps:
                    case GenevaActionType.IISMigrateProtocolToHttp:
                        break;

                    case GenevaActionType.EnableSmartRouter:
                    case GenevaActionType.RevertToAppGateway:
                    case GenevaActionType.SetupSmartRouter:
                        break;
                    case GenevaActionType.AddToSmartRouterServerList:
                    case GenevaActionType.RemoveFromSmartRouterServerList:
                        if (!this.ReadUpdateSmartRouterServerListGenevaActionParameters(action, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }
                        break;
                    case GenevaActionType.AddToApplicationGatewayBackendPool:
                    case GenevaActionType.RemoveFromApplicationGatewayBackendPool:
                        if (!this.ReadUpdateApplicationGatewayBackendPoolGenevaActionParameters(action, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }
                        break;

                    case GenevaActionType.RemoveBIVirtualMachine:
                        break;

                    case GenevaActionType.StopApplicationGateway:
                    case GenevaActionType.StartApplicationGateway:
                    case GenevaActionType.DeleteApplicationGateway:
                        break;
                    case GenevaActionType.ResizeApplicationGateway:
                        if (!this.ReadResizeAppGatewayGenevaActionParameters(action, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }
                        break;

                    case GenevaActionType.EnableMaintenanceWindow:
                        if (!this.ReadEnableMaintenanceWindowGenevaActionParameters(action, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }
                        break;

                    case GenevaActionType.DisableMaintenanceWindow:
                        break;

                    case GenevaActionType.FetchPackageDeploymentLogs:
                        if (!this.ReadFetchPackageDeploymentLogsGenevaActionParameters(action, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }
                        break;
                    case GenevaActionType.RunPowershellScriptOnVirtualMachine:
                        if (!this.ReadRunPowershellScriptOnVmGenevaActionParameters(action, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }
                        break;
                    case GenevaActionType.RefreshMRConnections:
                        break;
                    case GenevaActionType.UpdateCdsConfigurationInWebConfig:
                        break;
                    case GenevaActionType.CleanupTopologyInstanceContainer:
                        if (!this.ReadCleanupTopologyInstanceContainerGenevaActionParameters(action, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }
                        break;
                    case GenevaActionType.VerifyReplyUrlWebConfig:
                        if (!this.ReadVerifyReplyUrlWebConfigParameters(action, parametersObj, parametersDictionary, out errorMessage))
                        {
                            return false;
                        }
                        break;
                    case GenevaActionType.RevertReplyUrlWebConfigDNSChanges:
                        break;
                    default:
                        throw new NotSupportedException(genevaActionToExecute.ToString());
                }
            }

            parameterValues = parametersDictionary;
            return true;
        }

        /// <summary>
        /// Read Topology Instance update parameters from OData request body.
        /// </summary>
        /// <param name="parameters">OData parameters.</param>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="environmentGroup">The environment group.</param>
        /// <param name="topologyInstanceUpdateType">The topology instance update type.</param>
        /// <param name="parameterValues">A dictionary with parameters for specified update type.</param>
        /// <param name="errorMessage">An error message, if any occured.</param>
        /// <returns>True if parsed successfully, false otherwise.</returns>
        private bool ReadTopologyInstanceUpdateParameters(
           ODataActionParameters parameters,
           DeploymentRequest.DeploymentAction action,
           EnvironmentGroup environmentGroup,
           out TopologyInstanceUpdateType topologyInstanceUpdateType,
           out IDictionary<string, object> parameterValues,
           out HttpResponseMessage errorMessage)
        {
            topologyInstanceUpdateType = TopologyInstanceUpdateType.None;
            parameterValues = null;
            errorMessage = null;

            string topologyInstanceUpdateTypeString = parameters.ContainsKey(CommonDeploymentActionParameters.TopologyInstanceUpdateType) ? (string)parameters[CommonDeploymentActionParameters.TopologyInstanceUpdateType] : null;

            if (!Enum.TryParse(topologyInstanceUpdateTypeString, out topologyInstanceUpdateType) || topologyInstanceUpdateType == TopologyInstanceUpdateType.None)
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    topologyInstanceUpdateTypeString,
                    CommonDeploymentActionParameters.TopologyInstanceUpdateType);
                return false;
            }

            Dictionary<string, object> parametersDictionary = new Dictionary<string, object>();
            string parametersJsonString = parameters.ContainsKey(CommonDeploymentActionParameters.TopologyInstanceUpdateParameters) ? (string)parameters[CommonDeploymentActionParameters.TopologyInstanceUpdateParameters] : null;

            if (!string.IsNullOrEmpty(parametersJsonString))
            {
                JObject parametersObj = JObject.Parse(parametersJsonString);

                switch (topologyInstanceUpdateType)
                {
                    case TopologyInstanceUpdateType.RemoveExternalMonitor:

                        string externalMonitorComponentToRemove;

                        if (!this.TryGetGenevaParameter(action, parametersObj, CommonDeploymentActionParameters.ExternalMonitorComponentToRemove, out externalMonitorComponentToRemove, out errorMessage))
                        {
                            return false;
                        }

                        parametersDictionary.Add(CommonDeploymentActionParameters.ExternalMonitorComponentToRemove, externalMonitorComponentToRemove);

                        break;

                    case TopologyInstanceUpdateType.AddCustomCACertificateGuard:

                        string customCACertificateList;

                        if (!this.TryGetGenevaParameter(action, parametersObj, CommonDeploymentActionParameters.CustomCACertificateList, out customCACertificateList, out errorMessage))
                        {
                            return false;
                        }

                        parametersDictionary.Add(CommonDeploymentActionParameters.CustomCACertificateList, customCACertificateList);

                        break;

                    case TopologyInstanceUpdateType.AddRetailCustomPaymentConnectorGuard:

                        string retailCustomPaymentConnectorPatchId;

                        if (!this.TryGetGenevaParameter(action, parametersObj, CommonDeploymentActionParameters.RetailCustomPaymentConnectorPatchId, out retailCustomPaymentConnectorPatchId, out errorMessage))
                        {
                            return false;
                        }

                        parametersDictionary.Add(CommonDeploymentActionParameters.RetailCustomPaymentConnectorPatchId, retailCustomPaymentConnectorPatchId);

                        break;

                    case TopologyInstanceUpdateType.CheckEnvironmentAdministrator:
                    case TopologyInstanceUpdateType.UpdateEnvironmentAdministrator:

                        string environmentAdministrator;

                        if (!this.TryGetGenevaParameter(action, parametersObj, CommonDeploymentActionParameters.EnvironmentAdministrator, out environmentAdministrator, out errorMessage))
                        {
                            return false;
                        }

                        parametersDictionary.Add(CommonDeploymentActionParameters.EnvironmentAdministrator, environmentAdministrator);

                        break;

                    case TopologyInstanceUpdateType.UpdateSQLServerName:

                        string databaseType;
                        string serverName;
                        string serverType;
                        if (!this.TryGetGenevaParameter(action, parametersObj, CommonDeploymentActionParameters.DatabaseType, out databaseType, out errorMessage))
                        {
                            return false;
                        }

                        if (!this.TryGetGenevaParameter(action, parametersObj, CommonDeploymentActionParameters.NewSQLServerName, out serverName, out errorMessage))
                        {
                            return false;
                        }

                        if (!this.TryGetGenevaParameter(action, parametersObj, CommonDeploymentActionParameters.SqlServerType, out serverType, out errorMessage))
                        {
                            return false;
                        }

                        parametersDictionary.Add(CommonDeploymentActionParameters.SqlServerType, serverType);
                        parametersDictionary.Add(CommonDeploymentActionParameters.DatabaseType, databaseType);
                        parametersDictionary.Add(CommonDeploymentActionParameters.NewSQLServerName, serverName);
                        break;

                    case TopologyInstanceUpdateType.UpdateEDWDatabaseAlias:

                        string sqlDBAlias;
                        if (!this.TryGetGenevaParameter(action, parametersObj, CommonDeploymentActionParameters.SQLDBAlias, out sqlDBAlias, out errorMessage))
                        {
                            return false;
                        }

                        if (string.IsNullOrEmpty(sqlDBAlias))
                        {
                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, CommonDeploymentActionParameters.SQLDBAlias, "SQLDBAlias is a required parameter");
                            return false;
                        }
                        else if (!sqlDBAlias.Contains(".database.windows.net") && !sqlDBAlias.Contains(".database.chinacloudapi.cn"))
                        {
                            errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, CommonDeploymentActionParameters.SQLDBAlias, "Alias should be fully qualified domain name");
                            return false;
                        }

                        parametersDictionary.Add(CommonDeploymentActionParameters.SQLDBAlias, sqlDBAlias);

                        break;

                    default:
                        throw new NotSupportedException(topologyInstanceUpdateType.ToString());
                }
            }

            parameterValues = parametersDictionary;
            return true;
        }


        /// <summary>
        /// Read parameters for disable environment Geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="environmentGroup">The environment group.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if parameters were read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadDisableTenantEnvironmentsGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            EnvironmentGroup environmentGroup,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;
            bool dropDRDatabase = false;

            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.DropDRDatabase, out dropDRDatabase, out errorMessage))
            {
                // If not found then skip drop db.
                dropDRDatabase = false;
            }

            this.ReadResizeDatabaseParameters(action, parametersJsonObject, parametersDictionaryToFill, out errorMessage);

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.DropDRDatabase, dropDRDatabase);

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Read parameters for disable environment Geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if parameters were read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadEnableEnvironmentsGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;
            bool deployDRDatabase = false;

            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.DeployDRDatabase, out deployDRDatabase, out errorMessage))
            {
                // if not found then skip deploying DR environment.
                deployDRDatabase = false;
            }

            this.ReadResizeDatabaseParameters(action, parametersJsonObject, parametersDictionaryToFill, out errorMessage);

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.DeployDRDatabase, deployDRDatabase);
            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Read resize database parameters.
        /// </summary>
        /// <param name="action">Deployment action.</param>
        /// <param name="parametersJsonObject">Parameters json object.</param>
        /// <param name="parametersDictionaryToFill">Parameters dictionary to fill.</param>
        /// <param name="errorMessage">Error message if any.</param>
        private void ReadResizeDatabaseParameters(DeploymentRequest.DeploymentAction action, JObject parametersJsonObject, Dictionary<string, object> parametersDictionaryToFill, out HttpResponseMessage errorMessage)
        {
            bool resizeDatabase = false;
            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.ResizeDatabase, out resizeDatabase, out errorMessage))
            {
                // if not found then skip resize DB.
                resizeDatabase = false;
            }

            if (resizeDatabase)
            {
                string sqlQueryResultType;
                string transactionThreshold;

                // If not found, use default Json file as default.
                if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.SQLQueryResultType, out sqlQueryResultType, out errorMessage) || string.IsNullOrEmpty(sqlQueryResultType))
                {
                    sqlQueryResultType = DeploymentConstants.JsonFile;
                }

                if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.TransactionThreshold, out transactionThreshold, out errorMessage))
                {
                    // If not found, set default to 60 min.
                    transactionThreshold = "60";
                }

                parametersDictionaryToFill.Add(CommonDeploymentActionParameters.SQLQueryResultType, sqlQueryResultType);
                parametersDictionaryToFill.Add(CommonDeploymentActionParameters.TransactionThreshold, transactionThreshold);
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.ResizeDatabase, resizeDatabase);
        }

        /// <summary>
        /// Read parameters for IIS application pool recycle Geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="environmentGroup">The environment group.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if parameters were read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadRecycleIISAppPoolGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            EnvironmentGroup environmentGroup,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            // App pool recycling is available only for Primary environment group
            if (environmentGroup != EnvironmentGroup.Primary)
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    environmentGroup,
                    ServiceConstants.EnvironmentGroupParameter);
                return false;
            }

            string appPoolToRecycleString;

            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.AppPoolToRecycle, out appPoolToRecycleString, out errorMessage))
            {
                return false;
            }

            RecycleIISAppPoolMetadata.AppPool appPoolToRecycle;
            if (!Enum.TryParse(appPoolToRecycleString, out appPoolToRecycle) || appPoolToRecycle == RecycleIISAppPoolMetadata.AppPool.None)
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    appPoolToRecycleString,
                    CommonDeploymentActionParameters.AppPoolToRecycle);
                return false;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.AppPoolToRecycle, appPoolToRecycle);
            return true;
        }

        /// <summary>
        /// Read parameters for Invoke SQL Geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if parameters were read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", Justification = "Relying on NewtonSoft to do the object conversion and need to be able to catch any exception it throws.")]
        private bool ReadInvokeSQLGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            string databaseItemName;
            string sqlQueryName;

            // IEnumerables, List and arrays need to be read in as a JArray and then converted with the ToObject() function.
            JArray sqlActionParameterJArray;

            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.DatabaseDeploymentItemName, out databaseItemName, out errorMessage) ||
                !this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.SQLQueryName, out sqlQueryName, out errorMessage) ||
                !this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.SQLQueryParameters, out sqlActionParameterJArray, out errorMessage))
            {
                return false;
            }

            string sqlQueryResultType;

            // If not found, use default Json file as default.
            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.SQLQueryResultType, out sqlQueryResultType, out errorMessage) || string.IsNullOrEmpty(sqlQueryResultType))
            {
                sqlQueryResultType = DeploymentConstants.JsonFile;
            }

            if (string.IsNullOrEmpty(databaseItemName))
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    databaseItemName,
                    CommonDeploymentActionParameters.DatabaseDeploymentItemName);
                return false;
            }

            if (string.IsNullOrEmpty(sqlQueryName))
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    sqlQueryName,
                    CommonDeploymentActionParameters.SQLQueryName);
                return false;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.DatabaseDeploymentItemName, databaseItemName);
            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.SQLQueryName, sqlQueryName);
            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.SQLQueryResultType, sqlQueryResultType);

            try
            {
                IEnumerable<SQLActionParameter> sqlActionParameters = sqlActionParameterJArray.ToObject<IEnumerable<SQLActionParameter>>();
                parametersDictionaryToFill.Add(CommonDeploymentActionParameters.SQLQueryParameters, sqlActionParameters);
            }
            catch (Exception e)
            {
                Tracer.WriteWarningEvent(TraceComponent.DeploymentServiceApi, e, null, "Unable to convert the [{0}] to a IEnumerable<SQLActionParameter> object.", CommonDeploymentActionParameters.SQLQueryParameters);

                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    sqlActionParameterJArray,
                    CommonDeploymentActionParameters.SQLQueryParameters);

                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Read parameters for Restart VM Geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="environmentGroup">The environment group.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadRestartVMGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            EnvironmentGroup environmentGroup,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            string virtualMachineToRestart;
            try
            {
                virtualMachineToRestart = parametersJsonObject[CommonDeploymentActionParameters.VMToRestart].Value<string>();
            }
            catch
            {
                virtualMachineToRestart = null;
            }

            if (string.IsNullOrWhiteSpace(virtualMachineToRestart))
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    virtualMachineToRestart,
                    CommonDeploymentActionParameters.VMToRestart);
                return false;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.VMToRestart, virtualMachineToRestart);
            return true;
        }

        /// <summary>
        /// Read parameters for collect memory dump Geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="environmentGroup">The environment group.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if parameters were read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadCollectMemoryDumpGenevaActionParameters(
                    DeploymentRequest.DeploymentAction action,
                    EnvironmentGroup environmentGroup,
                    JObject parametersJsonObject,
                    Dictionary<string, object> parametersDictionaryToFill,
                    out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            string appPoolToCollectMemoryDumpString;
            try
            {
                appPoolToCollectMemoryDumpString = parametersJsonObject[CommonDeploymentActionParameters.AppPoolToCollectMemoryDump].Value<string>();
            }
            catch
            {
                appPoolToCollectMemoryDumpString = null;
            }

            CollectMemoryDumpAppPoolMetadata.AppPoolName appPoolToCollectMemoryDumpName;
            if (!Enum.TryParse(appPoolToCollectMemoryDumpString, out appPoolToCollectMemoryDumpName))
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    appPoolToCollectMemoryDumpString,
                    CommonDeploymentActionParameters.AppPoolToCollectMemoryDump);
                return false;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.AppPoolToCollectMemoryDump, appPoolToCollectMemoryDumpName);
            return true;
        }

        /// <summary>
        /// Read parameters for Resize Database Geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="environmentGroup">The environment group.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if parameters were read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadResizeDatabaseGenevaActionParameters(
                    DeploymentRequest.DeploymentAction action,
                    EnvironmentGroup environmentGroup,
                    JObject parametersJsonObject,
                    Dictionary<string, object> parametersDictionaryToFill,
                    out HttpResponseMessage errorMessage)
        {
            string databaseItemName;
            string transactionThreshold;

            // IEnumerables, List and arrays need to be read in as a JArray and then converted with the ToObject() function.
            JArray sqlActionParameterJArray;

            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.DatabaseDeploymentItemName, out databaseItemName, out errorMessage) ||
                !this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.SQLQueryParameters, out sqlActionParameterJArray, out errorMessage) ||
                !this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.TransactionThreshold, out transactionThreshold, out errorMessage))
            {
                return false;
            }

            string sqlQueryResultType;

            // If not found, use default Json file as default.
            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.SQLQueryResultType, out sqlQueryResultType, out errorMessage) || string.IsNullOrEmpty(sqlQueryResultType))
            {
                sqlQueryResultType = DeploymentConstants.JsonFile;
            }

            if (string.IsNullOrEmpty(databaseItemName))
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    databaseItemName,
                    CommonDeploymentActionParameters.DatabaseDeploymentItemName);
                return false;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.DatabaseDeploymentItemName, databaseItemName);
            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.SQLQueryResultType, sqlQueryResultType);
            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.TransactionThreshold, transactionThreshold);

            try
            {
                IEnumerable<SQLActionParameter> sqlActionParameters = sqlActionParameterJArray.ToObject<IEnumerable<SQLActionParameter>>();
                parametersDictionaryToFill.Add(CommonDeploymentActionParameters.SQLQueryParameters, sqlActionParameters);
            }
            catch (Exception e)
            {
                Tracer.WriteWarningEvent(TraceComponent.DeploymentServiceApi, e, null, "Unable to convert the [{0}] to a IEnumerable<SQLActionParameter> object.", CommonDeploymentActionParameters.SQLQueryParameters);

                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    sqlActionParameterJArray,
                    CommonDeploymentActionParameters.SQLQueryParameters);

                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Read parameters for the copy database geneva action parameters.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="environmentGroup">The environment group.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if read successfully, false otherwise.</returns>
        private bool ReadCopyDatabaseGenevaActionParameters(
                    DeploymentRequest.DeploymentAction action,
                    EnvironmentGroup environmentGroup,
                    JObject parametersJsonObject,
                    Dictionary<string, object> parametersDictionaryToFill,
                    out HttpResponseMessage errorMessage)
        {
            string targetDatabaseItemName;
            string targetDatabaseName;
            string sourceTopologyTenantId;
            string sourceTopologyAzureSubscriptionId;
            string sourceTopologyInstanceId;

            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.DatabaseDeploymentItemName, out targetDatabaseItemName, out errorMessage) ||
                !this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.TargetCopyDatabaseName, out targetDatabaseName, out errorMessage) ||
                !this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.SourceTopologyTenantId, out sourceTopologyTenantId, out errorMessage) ||
                !this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.SourceTopologyAzureSubscriptionId, out sourceTopologyAzureSubscriptionId, out errorMessage) ||
                !this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.SourceTopologyInstanceId, out sourceTopologyInstanceId, out errorMessage))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "One of the geneva action [{0}] parameters retrieval unsuccessful.", action);
                return false;
            }

            if (string.IsNullOrEmpty(sourceTopologyInstanceId))
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    sourceTopologyInstanceId,
                    CommonDeploymentActionParameters.SourceTopologyInstanceId);
                return false;
            }

            // Validate the source topology is valid
            TopologyInstance topologyInstance;
            DeploymentInstance deploymentInstance;
            Uri deploymentInstanceBlobUri;

            TopologyInstanceTableItem topologyInstanceRow;

            if (!this.GetTopologyInstance(Guid.Parse(sourceTopologyTenantId), Guid.Parse(sourceTopologyAzureSubscriptionId), sourceTopologyInstanceId, EnvironmentGroup.Primary, out topologyInstance, out errorMessage, out topologyInstanceRow))
            {
                return false;
            }

            if (!this.GetDeploymentInstance(Guid.Parse(sourceTopologyTenantId), Guid.Parse(sourceTopologyAzureSubscriptionId), sourceTopologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
            {
                return false;
            }

            if (string.IsNullOrEmpty(targetDatabaseItemName))
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    targetDatabaseItemName,
                    CommonDeploymentActionParameters.DatabaseDeploymentItemName);
                return false;
            }

            if (string.IsNullOrEmpty(targetDatabaseName))
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    targetDatabaseName,
                    CommonDeploymentActionParameters.TargetCopyDatabaseName);
                return false;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.DatabaseDeploymentItemName, targetDatabaseItemName);
            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.TargetCopyDatabaseName, targetDatabaseName);
            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.SourceTopologyTenantId, sourceTopologyTenantId);
            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.SourceTopologyAzureSubscriptionId, sourceTopologyAzureSubscriptionId);
            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.SourceTopologyInstanceId, sourceTopologyInstanceId);

            return true;
        }

        /// <summary>
        /// Reads the parameters for the AddToSmartRouterServerList and RemoveFromSmartRouterServerList Geneva Actions
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if read successfully, false otherwise.</returns>
        private bool ReadUpdateSmartRouterServerListGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.VMNames, out string virtualMachineNames, out errorMessage))
            {
                return false;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.VMNames, virtualMachineNames);
            return true;
        }

        /// <summary>
        /// Reads the parameters for the AddToApplicationGatewayBackendPool and RemoveFromApplicationGatewayBackendPool Geneva Actions
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if read successfully, false otherwise.</returns>
        private bool ReadUpdateApplicationGatewayBackendPoolGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.VMNames, out string virtualMachineNames, out errorMessage))
            {
                return false;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.VMNames, virtualMachineNames);
            return true;
        }

        /// <summary>
        /// Validates the parameters for the AddToSmartRouterServerList and RemoveFromSmartRouterServerList Geneva Actions
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="genevaActionToExecute">The Geneva action being executed.</param>
        /// <param name="topologyInstance">The topology instanace</param>
        /// <param name="deploymentInstance">The deployment instance</param>
        /// <param name="parameterValues">The parameter values for the action.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if the parameters were successfully validate, false otherwise.</returns>
        private bool TryValidateUpdateSmartRouterServerListGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            GenevaActionType genevaActionToExecute,
            TopologyInstance topologyInstance,
            DeploymentInstance deploymentInstance,
            IDictionary<string, object> parameterValues,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;
            string virtualMachineNames = (string)parameterValues[CommonDeploymentActionParameters.VMNames];

            string[] vmNames = virtualMachineNames.Split(',');

            if (vmNames.Length < 1)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, $"No vm names were present after spliting up the parameter. {nameof(virtualMachineNames)} = {virtualMachineNames}");
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    virtualMachineNames,
                    CommonDeploymentActionParameters.VMNames);
                return false;
            }

            foreach (string vmName in vmNames)
            {
                bool virtualMachineExists = topologyInstance.DeploymentItems
                    .Where(di => di.IsItemType(DeploymentItemType.VirtualMachine))
                    .SelectMany(di => di.Instances)
                    .Any(instance => instance.MachineName.Equals(vmName, StringComparison.OrdinalIgnoreCase));
                if (!virtualMachineExists)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, $"No VM was found with name '{vmName}'in the topology.");
                    errorMessage = this.CreateErrorResponse(
                        ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                        action,
                        virtualMachineNames,
                        CommonDeploymentActionParameters.VMNames);
                    return false;
                }
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Scheduling update to Smart Router server list for geneva action '{0}' with machine names [{1}]", genevaActionToExecute.ToString(), virtualMachineNames);

            deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.VMNames, virtualMachineNames);

            return true;
        }

        /// <summary>
        /// Validates the parameters for the AddToApplicationGatewayBackendPool and RemoveFromApplicationGatewayBackendPool Geneva Actions
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="genevaActionToExecute">The Geneva action being executed.</param>
        /// <param name="topologyInstance">The topology instanace</param>
        /// <param name="deploymentInstance">The deployment instance</param>
        /// <param name="parameterValues">The parameter values for the action.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if the parameters were successfully validate, false otherwise.</returns>
        private bool TryValidateUpdateApplicationGatewayBackendPoolGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            GenevaActionType genevaActionToExecute,
            TopologyInstance topologyInstance,
            DeploymentInstance deploymentInstance,
            IDictionary<string, object> parameterValues,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;
            string virtualMachineNames = (string)parameterValues[CommonDeploymentActionParameters.VMNames];

            string[] vmNames = virtualMachineNames.Split(',');

            if (vmNames.Length < 1)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, $"No vm names were present after spliting up the parameter. {nameof(virtualMachineNames)} = {virtualMachineNames}");
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    virtualMachineNames,
                    CommonDeploymentActionParameters.VMNames);
                return false;
            }

            var environmentGroupString = (string)parameterValues[CommonDeploymentActionParameters.EnvironmentGroup];
            EnvironmentGroup environmentGroup = EnvironmentGroupExtensions.GetEnvironmentGroupOrDefault(environmentGroupString);
            bool isDisasterRecovery = environmentGroup == EnvironmentGroup.DisasterRecovery;

            foreach (string vmName in vmNames)
            {
                bool virtualMachineExists = topologyInstance.DeploymentItems
                    .Where(di => di.IsItemType(DeploymentItemType.VirtualMachine))
                    .Where(di => isDisasterRecovery ? di.IsDisasterRecovery() : !di.IsDisasterRecovery())
                    .SelectMany(di => di.Instances)
                    .Any(instance => instance.MachineName.Equals(vmName, StringComparison.OrdinalIgnoreCase));
                if (!virtualMachineExists)
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, $"No VM was found with name '{vmName}'in the topology.");
                    errorMessage = this.CreateErrorResponse(
                        ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                        action,
                        virtualMachineNames,
                        CommonDeploymentActionParameters.VMNames);
                    return false;
                }
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Scheduling update to Application Gateway backend pool for geneva action '{0}' with machine names [{1}]", genevaActionToExecute.ToString(), virtualMachineNames);

            deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.VMNames, virtualMachineNames);

            return true;
        }

        /// <summary>
        /// Read parameters for the resize VM geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadResizeVMGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;
            JArray resizeVmMetadataJArray;
            IList<ResizeVmMetadata> resizeVmMetadata = default(List<ResizeVmMetadata>);

            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.ResizeVmMetadata, out resizeVmMetadataJArray, out errorMessage))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "One of the geneva action [{0}] parameters retrieval unsuccessful.", action);
                return false;
            }

            try
            {
                resizeVmMetadata = resizeVmMetadataJArray.ToObject<IList<ResizeVmMetadata>>();
            }
            catch (Exception e)
            {
                Tracer.WriteWarningEvent(TraceComponent.DeploymentServiceApi, e, null, "Unable to parse the input parameter [{0}] for Resize VM action.", CommonDeploymentActionParameters.ResizeVmMetadata);

                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, resizeVmMetadataJArray, CommonDeploymentActionParameters.ResizeVmMetadata);
            }

            if (!(resizeVmMetadata != null && resizeVmMetadata.Count > 0))
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, resizeVmMetadata, CommonDeploymentActionParameters.ResizeVmMetadata);
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.ResizeVmMetadata, resizeVmMetadata);
            return true;
        }

        /// <summary>
        /// Read parameters for execute post-servicing Geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if parameters were read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadExecutePostServicingGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;
            bool useCollapsedPostServicing = true;

            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.UseCollapsedPostServicing, out useCollapsedPostServicing, out errorMessage))
            {
                // if not found then use collapsed post-servicing flow.
                useCollapsedPostServicing = true;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.UseCollapsedPostServicing, useCollapsedPostServicing);
            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Read parameters for the resize Application Gateway geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadResizeAppGatewayGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;
            JArray resizeAppGwMetadataJArray;
            IList<ResizeApplicationGatewayMetadata> resizeAppGwMetadata = default(List<ResizeApplicationGatewayMetadata>);

            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.ResizeAppGatewayMetadata, out resizeAppGwMetadataJArray, out errorMessage))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "One of the geneva action [{0}] parameters retrieval unsuccessful.", action);
                return false;
            }

            try
            {
                resizeAppGwMetadata = resizeAppGwMetadataJArray.ToObject<IList<ResizeApplicationGatewayMetadata>>();
            }
            catch (Exception e)
            {
                Tracer.WriteWarningEvent(TraceComponent.DeploymentServiceApi, e, null, "Unable to parse the input parameter [{0}] for Resize Application Gateway action.", CommonDeploymentActionParameters.ResizeAppGatewayMetadata);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, resizeAppGwMetadataJArray, CommonDeploymentActionParameters.ResizeAppGatewayMetadata);
                return false;
            }

            if (resizeAppGwMetadata == null)
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, resizeAppGwMetadata, CommonDeploymentActionParameters.ResizeAppGatewayMetadata);
                return false;
            }
            else
            {
                parametersDictionaryToFill.Add(CommonDeploymentActionParameters.ResizeAppGatewayMetadata, resizeAppGwMetadata);
                return true;
            }
        }

        /// <summary>
        /// Read parameters for the fetch package deployment logs geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadFetchPackageDeploymentLogsGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;
            string activityId = string.Empty;

            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.ActivityId, out activityId, out errorMessage))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "An attempt to retrieve the activityId parameter for the geneva action [{0}] was unsuccessful.", action);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, activityId, CommonDeploymentActionParameters.ActivityId);
                return false;
            }

            if (string.IsNullOrEmpty(activityId))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The activityId [{0}] retrieved is invalid for the geneva action [{1}].", activityId, action);
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, activityId, CommonDeploymentActionParameters.ActivityId);
                return false;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.ActivityId, activityId);
            return true;
        }

        /// <summary>
        /// Read parameters for enable maintenance Window Geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if parameters were read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadEnableMaintenanceWindowGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.MaintenanceWindowInHours, out int maintenanceWindowInHours, out errorMessage))
            {
                // if not found then throw exception.
                return false;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.MaintenanceWindowInHours, maintenanceWindowInHours);
            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Read parameters for run PS script on vm Geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if parameters were read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadRunPowershellScriptOnVmGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.ScriptName, out string scriptIdentifierString, out errorMessage))
            {
                // if not found then throw exception.
                return false;
            }
            GenevaActionPowershellScript genevaActionPowershellScript;
            if (!Enum.TryParse(scriptIdentifierString, out genevaActionPowershellScript))
            {
                return false;
            }
            JArray vmJArray;
            IList<string> vmList = default(List<string>);
            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.VMNames, out vmJArray, out errorMessage))
            {
                // if not found then throw exception.
                return false;
            }
            try
            {
                vmList = vmJArray.ToObject<IList<string>>();
            }
            catch
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, vmJArray, CommonDeploymentActionParameters.VMNames);
                return false;
            }

            if (!(vmList != null && vmList.Count > 0))
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, vmList, CommonDeploymentActionParameters.VMNames);
                return false;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.ScriptName, scriptIdentifierString);
            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.VMNames, vmList);
            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Read parameters for verifiy web config reply url.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if parameters were read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadVerifyReplyUrlWebConfigParameters(
            DeploymentRequest.DeploymentAction action,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            JArray vmJArray;
            IList<string> vmList = default(List<string>);
            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.VMNames, out vmJArray, out errorMessage))
            {
                // if not found then throw exception.
                return false;
            }
            try
            {
                vmList = vmJArray.ToObject<IList<string>>();
            }
            catch
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, vmJArray, CommonDeploymentActionParameters.VMNames);
                return false;
            }

            if (!(vmList != null && vmList.Count > 0))
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, action, vmList, CommonDeploymentActionParameters.VMNames);
                return false;
            }
            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.MarkEnvironmentFailed, out bool markEnvFailed, out errorMessage))
            {
                // if not found then throw exception.
                return false;
            }
            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.ShutdownIIS, out bool shutdownIIS, out errorMessage))
            {
                // if not found then throw exception.
                return false;
            }
            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.DocumentLink, out string documentLink, out errorMessage))
            {
                // if not found then throw exception.
                return false;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.VMNames, vmList);
            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.MarkEnvironmentFailed, markEnvFailed);
            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.ShutdownIIS, shutdownIIS);
            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.DocumentLink, documentLink);
            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Read parameters for run PS script on vm Geneva action.
        /// </summary>
        /// <param name="action">The deployment action being executed.</param>
        /// <param name="parametersJsonObject">The JSON object to parse.</param>
        /// <param name="parametersDictionaryToFill">The dictionary to store the parameters.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if parameters were read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool ReadCleanupTopologyInstanceContainerGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            JObject parametersJsonObject,
            Dictionary<string, object> parametersDictionaryToFill,
            out HttpResponseMessage errorMessage)
        {
            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.NoOfDaysToDeleteXml, out int noOfDays, out errorMessage))
            {
                // if not found then throw exception.
                return false;
            }

            if (!this.TryGetGenevaParameter(action, parametersJsonObject, CommonDeploymentActionParameters.ContainerNameToDelete, out string containerNameToDelete, out errorMessage))
            {
                // if not found then throw exception.
                return false;
            }

            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.NoOfDaysToDeleteXml, noOfDays);
            parametersDictionaryToFill.Add(CommonDeploymentActionParameters.ContainerNameToDelete, containerNameToDelete);
            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Try to schedule tasks required to execute Geneva action.
        /// </summary>
        /// <param name="tenantId">Tenant Id.</param>
        /// <param name="azureSubscriptionId">Azure subscription Id.</param>
        /// <param name="topologyInstance">Topology instance.</param>
        /// <param name="topologyInstanceRow">Topology instance DB row.</param>
        /// <param name="deploymentState">Deployment state to set for topology.</param>
        /// <param name="action">A deployment action to execute for topology.</param>
        /// <param name="genevaActionToExecute">A Geneva action to execute.</param>
        /// <param name="parameterValues">Parameter values for Geneva action.</param>
        /// <returns>True if scheduled successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Maintainability", "CA1505:AvoidUnmantainableCode", Justification = "Breaking into more function will increase code complexity.")]
        private HttpResponseMessage TryScheduleGenevaOperationTask(
            Guid tenantId,
            Guid azureSubscriptionId,
            TopologyInstance topologyInstance,
            TopologyInstanceTableItem topologyInstanceRow,
            DeploymentState deploymentState,
            DeploymentRequest.DeploymentAction action,
            GenevaActionType genevaActionToExecute,
            IDictionary<string, object> parameterValues)
        {
            HttpResponseMessage errorMessage;
            DeploymentInstance deploymentInstance = new DeploymentInstance(topologyInstance.InstanceId);
            deploymentInstance.Initialize(topologyInstance);
            deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.GenevaActionToRun, genevaActionToExecute.ToString());
            TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Preparing to schedule environment action [{0}] on topology [{1}]...", genevaActionToExecute, topologyInstance);

            switch (genevaActionToExecute)
            {
                case GenevaActionType.FetchVersionInfo:
                    break;
                case GenevaActionType.ExecutePostServicing:
                    bool useCollapsedPostServicing = (bool)parameterValues[CommonDeploymentActionParameters.UseCollapsedPostServicing];
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.UseCollapsedPostServicing, useCollapsedPostServicing.ToString());
                    break;
                case GenevaActionType.RecycleIISAppPool:
                    RecycleIISAppPoolMetadata.AppPool appPoolToRecycle = (RecycleIISAppPoolMetadata.AppPool)parameterValues[CommonDeploymentActionParameters.AppPoolToRecycle];
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Scheduling IIS Application pool reset for the [{0}] pool on topology [{1}]...", appPoolToRecycle.ToString(), topologyInstance);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.AppPoolToRecycle, appPoolToRecycle.ToString());
                    break;
                case GenevaActionType.RestartVM:
                    if (!this.TryValidateAndConfigureRestartVMGenevaActionParameters(action, topologyInstance, deploymentInstance, parameterValues, out errorMessage))
                    {
                        return errorMessage;
                    }

                    break;
                case GenevaActionType.InvokeSQL:
                    string databaseItemName = (string)parameterValues[CommonDeploymentActionParameters.DatabaseDeploymentItemName];
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.DatabaseDeploymentItemName, databaseItemName);

                    string sqlQueryName = (string)parameterValues[CommonDeploymentActionParameters.SQLQueryName];

                    SQLActionTableItem sqlActionTableItem = SQLActionDAC.GetSQLAction(sqlQueryName);

                    if (sqlActionTableItem == null || !sqlActionTableItem.Active)
                    {
                        return this.CreateErrorResponse(
                            ServiceErrorCode.SQLQueryWasNotFound,
                            string.Format(CultureInfo.InvariantCulture, "The SQL query [{0}] was either not found or marked as inactive in the DeploymentSettings storage table.", sqlQueryName));
                    }

                    string sqlQueryOutputExtension = sqlActionTableItem.OutputFileExtension != null ? sqlActionTableItem.OutputFileExtension : (string)parameterValues[CommonDeploymentActionParameters.SQLQueryResultType];

                    IEnumerable<SQLActionParameter> sqlActionParameters = (IEnumerable<SQLActionParameter>)parameterValues[CommonDeploymentActionParameters.SQLQueryParameters];
                    IEnumerable<SQLActionParameter> tableParameters = string.IsNullOrWhiteSpace(sqlActionTableItem.Parameters) ? new List<SQLActionParameter>() : CommonUtilities.DeserializeJson<IEnumerable<SQLActionParameter>>(sqlActionTableItem.Parameters);

                    if (!this.ValidateSQLParameters(sqlActionParameters, tableParameters, out errorMessage))
                    {
                        return errorMessage;
                    }

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Scheduling SQL Query [{0}] pool on topology [{1}]...", sqlQueryName, topologyInstance);

                    string sqlQueryParametersString = CommonUtilities.SerializeJson<IEnumerable<SQLActionParameter>>(tableParameters);

                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SQLQuery, sqlActionTableItem.QueryTemplate);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SQLQueryParameters, sqlQueryParametersString);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SQLQueryResultType, sqlQueryOutputExtension);

                    string sqlActionOutput = sqlActionTableItem.ReturnsResults ? DeploymentConstants.InvokeSQLQueryResults : DeploymentConstants.InvokeSQLCommand;
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SQLActionOutput, sqlActionOutput);

                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SQLQueryTimeoutInMinutes, sqlActionTableItem.QueryTimeout.ToString(CultureInfo.InvariantCulture));
                    break;
                case GenevaActionType.CollectMemoryDumpAppPool:
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Scheduling application pool memory dump on topology [{1}]...", topologyInstance);
                    var appPoolToCollectMemoryDump = parameterValues[CommonDeploymentActionParameters.AppPoolToCollectMemoryDump];
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.AppPoolToCollectMemoryDump, appPoolToCollectMemoryDump.ToString());
                    break;
                case GenevaActionType.DataMartReset:
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Scheduling datamart reset on topology [{1}]...", topologyInstance);
                    TopologyInstance sourceTopologyInstance;
                    DeploymentInstance sourceDeploymentInstance;
                    Uri sourceDeploymentInstanceBlobUri;
                    TopologyInstanceTableItem sourceTopologyInstanceRow;
                    if (!this.ValidateAndFetchDeploymentDetails(tenantId, azureSubscriptionId, topologyInstance.InstanceId, EnvironmentGroup.Primary, out sourceTopologyInstance, out errorMessage, out sourceTopologyInstanceRow, out sourceDeploymentInstance, out sourceDeploymentInstanceBlobUri, action))
                    {
                        return errorMessage;
                    }

                    deploymentInstance.DeploymentActionParameters.Add(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.SourceAxDbTopologyInstanceParameter, CommonUtilities.SerializeObject(sourceTopologyInstance));
                    break;
                case GenevaActionType.ResizeDatabase:
                    ResizeDatabaseParameters resizeDatabaseParameters = new ResizeDatabaseParameters();

                    databaseItemName = (string)parameterValues[CommonDeploymentActionParameters.DatabaseDeploymentItemName];
                    string transactionThreshold = (string)parameterValues[CommonDeploymentActionParameters.TransactionThreshold];

                    DeploymentItem azureSQLDatabaseItem = topologyInstance.DeploymentItems.GetFirst(databaseItemName);

                    if (azureSQLDatabaseItem.IsElasticPoolEnabled())
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The action Resize Database is not allowed to be performed on ElasticPool.");
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNonElasticPoolServer, "Resize Database");
                    }

                    sqlQueryName = CommonDeploymentActionParameters.ScaleDatabase;

                    sqlActionTableItem = SQLActionDAC.GetSQLActionByName(sqlQueryName);

                    if (sqlActionTableItem == null)
                    {
                        return this.CreateErrorResponse(
                            ServiceErrorCode.SQLQueryWasNotFound,
                            string.Format(CultureInfo.InvariantCulture, "The SQL query [{0}] was not found in the DeploymentSettings storage table.", sqlQueryName));
                    }

                    List<DeploymentItem> deploymentItems = topologyInstance.DeploymentItems.ToList();

                    // Looking for the Item names that match the primary database Item name.
                    DeploymentItem relatedDatabase = deploymentItems
                        .FirstOrDefault(d => d.HasCustomizationValue(CommonCustomizationNames.AzureSQLDatabasePrimaryCopy, azureSQLDatabaseItem.ItemName) && d.IsDisasterRecovery());

                    // IF DR exists
                    bool isDREnabled = false;
                    if (relatedDatabase != null)
                    {
                        resizeDatabaseParameters.DRDatabaseDeploymentItemName = relatedDatabase.ItemName;
                        isDREnabled = true;
                    }

                    sqlQueryOutputExtension = sqlActionTableItem.OutputFileExtension != null ? sqlActionTableItem.OutputFileExtension : (string)parameterValues[CommonDeploymentActionParameters.SQLQueryResultType];

                    sqlActionParameters = (IEnumerable<SQLActionParameter>)parameterValues[CommonDeploymentActionParameters.SQLQueryParameters];
                    tableParameters = string.IsNullOrWhiteSpace(sqlActionTableItem.Parameters) ? new List<SQLActionParameter>() : CommonUtilities.DeserializeJson<IEnumerable<SQLActionParameter>>(sqlActionTableItem.Parameters);

                    if (!this.ValidateSQLParameters(sqlActionParameters, tableParameters, out errorMessage))
                    {
                        return errorMessage;
                    }

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Scheduling SQL Query [{0}] pool on topology [{1}]...", sqlQueryName, topologyInstance);

                    sqlQueryParametersString = CommonUtilities.SerializeJson<IEnumerable<SQLActionParameter>>(tableParameters);
                    string sqlQueryParameterValue = sqlActionParameters.FirstOrDefault().Value;
                    sqlActionOutput = sqlActionTableItem.ReturnsResults ? DeploymentConstants.InvokeSQLQueryResults : DeploymentConstants.InvokeSQLCommand;

                    string currentPerformanceTier;
                    azureSQLDatabaseItem.TryGetCustomizationValue(CommonCustomizationNames.AzureSQLDatabasePerformanceLevel, out currentPerformanceTier);

                    // Database Resize Report has a dependancy on this message for reporting.
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Environment Details for Resize Database action: Environment ID [{0}], DB original tier [{1}], DB tier after resize [{2}]", topologyInstance, currentPerformanceTier, sqlQueryParameterValue);

                    resizeDatabaseParameters.SQLQueryParameters = sqlQueryParametersString;
                    resizeDatabaseParameters.CurrentPerformanceTier = currentPerformanceTier;
                    resizeDatabaseParameters.PerformanceLevel = sqlQueryParameterValue;
                    resizeDatabaseParameters.DatabaseDeploymentItemName = databaseItemName;
                    resizeDatabaseParameters.IsDREnabledForResize = isDREnabled;

                    List<ResizeDatabaseParameters> resizeDatabaseParametersList = new List<ResizeDatabaseParameters>();
                    resizeDatabaseParametersList.Add(resizeDatabaseParameters);
                    string resizeDatabaseParametersString = CommonUtilities.SerializeJson<IEnumerable<ResizeDatabaseParameters>>(resizeDatabaseParametersList);

                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.TransactionThreshold, transactionThreshold);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SQLQuery, sqlActionTableItem.QueryTemplate);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SQLQueryResultType, sqlQueryOutputExtension);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SQLActionOutput, sqlActionOutput);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SQLQueryTimeoutInMinutes, sqlActionTableItem.QueryTimeout.ToString(CultureInfo.InvariantCulture));
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.ResizeDatabaseParameters, resizeDatabaseParametersString);
                    break;
                case GenevaActionType.CopyDatabaseToAnotherEnvironment:
                    TopologyInstance targetTopologyInstance;
                    string targetDatabaseItemName = (string)parameterValues[CommonDeploymentActionParameters.DatabaseDeploymentItemName];
                    string targetDatabaseName = (string)parameterValues[CommonDeploymentActionParameters.TargetCopyDatabaseName];
                    string sourceTopologyTenantId = (string)parameterValues[CommonDeploymentActionParameters.SourceTopologyTenantId];
                    string sourceTopologyAzureSubscriptionId = (string)parameterValues[CommonDeploymentActionParameters.SourceTopologyAzureSubscriptionId];
                    string sourceTopologyInstanceId = (string)parameterValues[CommonDeploymentActionParameters.SourceTopologyInstanceId];
                    if (!this.GetTopologyInstance(Guid.Parse(sourceTopologyTenantId), Guid.Parse(sourceTopologyAzureSubscriptionId), sourceTopologyInstanceId, EnvironmentGroup.Primary, out sourceTopologyInstance, out errorMessage, out topologyInstanceRow))
                    {
                        return errorMessage;
                    }

                    DeploymentItem sourceDatabaseDeploymentItem = sourceTopologyInstance.DeploymentItems.GetFirst(targetDatabaseItemName);
                    if (sourceDatabaseDeploymentItem.IsElasticPoolEnabled())
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Database is on ElasticPool.");
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNonElasticPoolServer, "Source database is currently on elastic pools which is not currently supported.");
                    }

                    if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstance.InstanceId, EnvironmentGroup.Primary, out targetTopologyInstance, out errorMessage, out topologyInstanceRow))
                    {
                        return errorMessage;
                    }

                    DeploymentItem targetDatabaseDeploymentItem = targetTopologyInstance.DeploymentItems.GetFirst(targetDatabaseItemName);

                    if (targetDatabaseDeploymentItem.IsElasticPoolEnabled())
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Database is on ElasticPool.");
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresNonElasticPoolServer, "Target database is currently on elastic pools which is not currently supported.");
                    }

                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Scheduling Database Copy from [{0}] to [{1}]...", sourceTopologyInstanceId, topologyInstance.InstanceId);

                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.DatabaseDeploymentItemName, targetDatabaseItemName);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.TargetCopyDatabaseName, targetDatabaseName);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SourceTopologyTenantId, sourceTopologyTenantId);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SourceTopologyAzureSubscriptionId, sourceTopologyAzureSubscriptionId);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SourceTopologyInstanceId, sourceTopologyInstanceId);
                    break;

                case GenevaActionType.DisableEnvironment:
                    if (!this.SetDisableEnvironmentParameters(topologyInstance, parameterValues, deploymentInstance, tenantRegistration, out errorMessage))
                    {
                        return errorMessage;
                    }

                    break;

                case GenevaActionType.EnableEnvironment:
                    if (!this.SetEnableEnvironmentParameters(topologyInstance, parameterValues, deploymentInstance, tenantRegistration, out errorMessage))
                    {
                        return errorMessage;
                    }

                    break;

                case GenevaActionType.ResizeVM:
                    if (!this.TryValidateResizeVMGenevaActionParameters(action, topologyInstance, deploymentInstance, tenantRegistration, parameterValues, out errorMessage))
                    {
                        return errorMessage;
                    }

                    break;

                case GenevaActionType.MigrateToSSRSService:
                    if (!topologyInstance.IsSandboxOrProdTopology())
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "This operation is not supported for Dev or Demo topologies.");
                        return this.CreateErrorResponse(ServiceErrorCode.InvalidTopologyInstance, "Topology is Dev or Demo which is not currently supported.");
                    }

                    bool isHttpsLockdown;
                    if (!this.TryValidateHttpsNSGRule(topologyInstance, tenantRegistration, out isHttpsLockdown, out errorMessage))
                    {
                        return errorMessage;
                    }

                    if (isHttpsLockdown)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "This operation is not supported on Https lockdown environment.");
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotSupportedOnEnvironment, genevaActionToExecute.ToString(), "Https Lockdown");
                    }
                    break;

                case GenevaActionType.MigrateToBIVM:
                    if (!topologyInstance.IsSandboxOrProdTopology())
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "This operation is not supported for Dev or Demo topologies.");
                        return this.CreateErrorResponse(ServiceErrorCode.InvalidTopologyInstance, "Topology is Dev or Demo which is not currently supported.");
                    }

                    string migratedToSSRSServiceString;
                    if (!topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.MigratedToSSRSService, out migratedToSSRSServiceString) || string.Equals(migratedToSSRSServiceString, Boolean.FalseString, StringComparison.OrdinalIgnoreCase))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "SSRS Service is not configured for this topology, continuing migration to BI VM.");
                    }

                    break;

                case GenevaActionType.RepublishToLocator:
                    if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstance.InstanceId, EnvironmentGroup.Primary, out targetTopologyInstance, out errorMessage, out topologyInstanceRow))
                    {
                        return errorMessage;
                    }

                    break;

                case GenevaActionType.IISMigrateProtocolToHttps:
                case GenevaActionType.IISMigrateProtocolToHttp:

                    if (!(topologyInstance.DeploymentState == DeploymentState.Finished
                            && topologyInstance.DeploymentStatus == Model.DeploymentStatus.Succeeded))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, action);
                    }

                    break;

                case GenevaActionType.EnableSmartRouter:
                case GenevaActionType.RevertToAppGateway:
                case GenevaActionType.SetupSmartRouter:
                    if (!topologyInstance.IsSandboxOrProdTopology())
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "This operation is not supported for Dev or Demo topologies.");
                        return this.CreateErrorResponse(ServiceErrorCode.InvalidTopologyInstance, "Topology is Dev or Demo which is not currently supported.");
                    }

                    if (!(topologyInstance.DeploymentState == DeploymentState.Finished
                            && topologyInstance.DeploymentStatus == Model.DeploymentStatus.Succeeded))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, action);
                    }
                    break;

                case GenevaActionType.AddToSmartRouterServerList:
                case GenevaActionType.RemoveFromSmartRouterServerList:
                    if (!topologyInstance.IsSandboxOrProdTopology())
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "This operation is not supported for Dev or Demo topologies.");
                        return this.CreateErrorResponse(ServiceErrorCode.InvalidTopologyInstance, "Topology is Dev or Demo which is not currently supported.");
                    }

                    if (!(topologyInstance.DeploymentState == DeploymentState.Finished
                            && topologyInstance.DeploymentStatus == Model.DeploymentStatus.Succeeded))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, action);
                    }

                    if (!this.TryValidateUpdateSmartRouterServerListGenevaActionParameters(action, genevaActionToExecute, topologyInstance, deploymentInstance, parameterValues, out errorMessage))
                    {
                        return errorMessage;
                    }
                    break;

                case GenevaActionType.AddToApplicationGatewayBackendPool:
                case GenevaActionType.RemoveFromApplicationGatewayBackendPool:
                    if (!topologyInstance.IsSandboxOrProdTopology())
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "This operation is not supported for Dev or Demo topologies.");
                        return this.CreateErrorResponse(ServiceErrorCode.InvalidTopologyInstance, "Topology is Dev or Demo which is not currently supported.");
                    }

                    if (!(topologyInstance.DeploymentState == DeploymentState.Finished
                            && topologyInstance.DeploymentStatus == Model.DeploymentStatus.Succeeded))
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Attempted to [{0}] deployment instance corresponding to topology [{1}] but it is currently in state [{2}].", action, topologyInstance, deploymentInstance.DeploymentState);
                        return this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequiresFinishedState, action);
                    }

                    if (!this.TryValidateUpdateApplicationGatewayBackendPoolGenevaActionParameters(action, genevaActionToExecute, topologyInstance, deploymentInstance, parameterValues, out errorMessage))
                    {
                        return errorMessage;
                    }
                    break;

                case GenevaActionType.RemoveBIVirtualMachine:
                    if (!this.TryValidateRemoveBIVMGenevaActionParameters(action, topologyInstance, deploymentInstance, tenantRegistration, parameterValues, out errorMessage))
                    {
                        return errorMessage;
                    }
                    break;
                case GenevaActionType.StopApplicationGateway:
                    {
                        var environmentGroup = (string)parameterValues[CommonDeploymentActionParameters.EnvironmentGroup];
                        EnvironmentGroup environment = EnvironmentGroupExtensions.GetEnvironmentGroupOrDefault(environmentGroup);
                        if (environment == EnvironmentGroup.DisasterRecovery)
                        {
                            if (!this.TryValidateDisasterRecoveryAppGatewayExists(deploymentInstance, environment, genevaActionToExecute, out errorMessage))
                            {
                                return errorMessage;
                            }
                            deploymentInstance.EnvironmentGroup = EnvironmentGroup.DisasterRecovery;
                        }
                    }
                    break;
                case GenevaActionType.StartApplicationGateway:
                    {
                        var environmentGroup = (string)parameterValues[CommonDeploymentActionParameters.EnvironmentGroup];
                        Library.Enums.EnvironmentGroup environment = EnvironmentGroupExtensions.GetEnvironmentGroupOrDefault(environmentGroup);
                        if (environment == EnvironmentGroup.DisasterRecovery)
                        {
                            if (!this.TryValidateDisasterRecoveryAppGatewayExists(deploymentInstance, environment, genevaActionToExecute, out errorMessage))
                            {
                                return errorMessage;
                            }
                            deploymentInstance.EnvironmentGroup = EnvironmentGroup.DisasterRecovery;
                        }
                    }
                    break;
                case GenevaActionType.DeleteApplicationGateway:
                    {
                        var environmentGroup = (string)parameterValues[CommonDeploymentActionParameters.EnvironmentGroup];
                        Library.Enums.EnvironmentGroup environment = EnvironmentGroupExtensions.GetEnvironmentGroupOrDefault(environmentGroup);
                        if (environment == EnvironmentGroup.DisasterRecovery)
                        {
                            if (!this.TryValidateDisasterRecoveryAppGatewayExists(deploymentInstance, environment, genevaActionToExecute, out errorMessage))
                            {
                                return errorMessage;
                            }
                            deploymentInstance.EnvironmentGroup = EnvironmentGroup.DisasterRecovery;
                        }
                    }
                    break;
                case GenevaActionType.ResizeApplicationGateway:
                    {
                        var environmentGroup = (string)parameterValues[CommonDeploymentActionParameters.EnvironmentGroup];
                        Library.Enums.EnvironmentGroup environment = EnvironmentGroupExtensions.GetEnvironmentGroupOrDefault(environmentGroup);
                        if (environment == EnvironmentGroup.DisasterRecovery)
                        {
                            if (!this.TryValidateDisasterRecoveryAppGatewayExists(deploymentInstance, environment, genevaActionToExecute, out errorMessage))
                            {
                                return errorMessage;
                            }
                            deploymentInstance.EnvironmentGroup = EnvironmentGroup.DisasterRecovery;
                        }
                        if (!this.TryValidateResizeAppGwGenevaActionParameters(action, topologyInstance, deploymentInstance, tenantRegistration, parameterValues, out errorMessage))
                        {
                            return errorMessage;
                        }
                    }
                    break;
                case GenevaActionType.FetchPackageDeploymentLogs:
                    if (!this.TryValidateFetchPackageDeploymentLogsGenevaActionParameters(tenantId, azureSubscriptionId, topologyInstance.InstanceId, deploymentInstance, genevaActionToExecute, parameterValues, out errorMessage))
                    {
                        return errorMessage;
                    }
                    break;

                case GenevaActionType.EnableMaintenanceWindow:
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.HealthDowntimeWindowInHours, ((int)TimeSpan.FromHours((int)parameterValues[CommonDeploymentActionParameters.MaintenanceWindowInHours]).TotalHours).ToString("F0", CultureInfo.CurrentCulture));
                    break;

                case GenevaActionType.DisableMaintenanceWindow:
                    break;

                case GenevaActionType.RunPowershellScriptOnVirtualMachine:
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.ScriptName, (string)parameterValues[CommonDeploymentActionParameters.ScriptName]);
                    var vmNames = (List<string>)parameterValues[CommonDeploymentActionParameters.VMNames];
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.VMNames, CommonUtilities.SerializeJson<List<string>>(vmNames));
                    break;

                case GenevaActionType.RefreshMRConnections:
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Scheduling refresh MR connections on topology [{1}]...", topologyInstance);
                    if (!this.ValidateAndFetchDeploymentDetails(tenantId, azureSubscriptionId, topologyInstance.InstanceId, EnvironmentGroup.Primary, out sourceTopologyInstance, out errorMessage, out sourceTopologyInstanceRow, out sourceDeploymentInstance, out sourceDeploymentInstanceBlobUri, action))
                    {
                        return errorMessage;
                    }

                    deploymentInstance.DeploymentActionParameters.Add(Microsoft.DynamicsOnline.Deployment.Service.Library.Constants.SourceAxDbTopologyInstanceParameter, CommonUtilities.SerializeObject(sourceTopologyInstance));
                    break;
                case GenevaActionType.UpdateCdsConfigurationInWebConfig:
                    break;
                case GenevaActionType.CleanupTopologyInstanceContainer:
                    string noOfDays = Convert.ToString(parameterValues[CommonDeploymentActionParameters.NoOfDaysToDeleteXml]);
                    string containerNameToDelete = Convert.ToString(parameterValues[CommonDeploymentActionParameters.ContainerNameToDelete]);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.NoOfDaysToDeleteXml, noOfDays);
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.ContainerNameToDelete, containerNameToDelete);
                    break;

                case GenevaActionType.VerifyReplyUrlWebConfig:
                    var names = (List<string>)parameterValues[CommonDeploymentActionParameters.VMNames];
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.VMNames, CommonUtilities.SerializeJson<List<string>>(names));
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.MarkEnvironmentFailed, Convert.ToString(parameterValues[CommonDeploymentActionParameters.MarkEnvironmentFailed]));
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.ShutdownIIS, Convert.ToString(parameterValues[CommonDeploymentActionParameters.ShutdownIIS]));
                    deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.DocumentLink, Convert.ToString(parameterValues[CommonDeploymentActionParameters.DocumentLink]));
                    break;
                case GenevaActionType.RevertReplyUrlWebConfigDNSChanges:
                    break;
                default:
                    throw new NotSupportedException(genevaActionToExecute.ToString());
            }

            deploymentInstance.ExecuteGenevaActionMetadata = new ExecuteGenevaActionMetadata(genevaActionToExecute.ToString());
            deploymentInstance.ExecuteGenevaActionMetadata.Status = ExecuteGenevaActionMetadata.GenevaActionStatus.Queued.ToString();
            deploymentInstance.ExecuteGenevaActionMetadata.LastAttemptedOperaionStarted = DateTime.Now;
            deploymentInstance.ExecuteGenevaActionMetadata.LastActivityId = Tracer.GetCorrelationActivityId();

            DeploymentRequest request = new DeploymentRequest(tenantRegistration, topologyInstance, deploymentInstance, action);

            request.PreviousDeploymentStatus = topologyInstance.DeploymentStatus;

            if (!this.TryUploadBlobAndScheduleTask(request, topologyInstanceRow, DeploymentManagementPipedMasterWorkflow.TaskNameConstant, out errorMessage, deploymentState))
            {
                return errorMessage;
            }

            return Request.CreateResponse(HttpStatusCode.OK, deploymentInstance.Revision);
        }

        /// <summary>Set disable environments parameters to DeploymentActionParameters.</summary>
        /// <param name="topologyInstance">Topology instance.</param>
        /// <param name="parameterValues">Parameter values for Geneva action.</param>
        /// <param name="deploymentInstance">Deployment instance.</param>
        /// <param name="tenantRegistration">Tenant registration.</param>
        /// <param name="errorMessage">Error message, if any occurred.</param>
        /// <returns>True if parameter set successfully, false otherwise.</returns>
        private bool SetDisableEnvironmentParameters(
            TopologyInstance topologyInstance,
            IDictionary<string, object> parameterValues,
            DeploymentInstance deploymentInstance,
            TenantRegistration tenantRegistration,
            out HttpResponseMessage errorMessage)
        {
            if (!topologyInstance.ShouldUseAzureResourceManager())
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Disable environment is not supported for RDFE environments.");
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_RequireTopologyWithARMSupport);
                return false;
            }

            bool deallocateEnvironment = true;
            bool resizeDatabase = (bool)parameterValues[CommonDeploymentActionParameters.ResizeDatabase];
            bool dropDRDatabase = (bool)parameterValues[CommonDeploymentActionParameters.DropDRDatabase];

            // If already environment deallocated then skip deallocating. At parent method we have already check for other transitioning states.
            if (topologyInstance.DeploymentState == DeploymentState.Deallocated
                || topologyInstance.HasCustomizationValue(CommonCustomizationNames.IsEnvironmentDisabled, true.ToString()))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Selected environment is already in deallocated state so skipping deallocation of environment");
                deallocateEnvironment = false;
            }

            // If client requests to drop DB, check if DR is enabled and environment is ready for DR then only mark drop DR DB as true else false.
            if (dropDRDatabase)
            {
                dropDRDatabase = topologyInstance.IsDisasterRecoveryEnabled() && topologyInstance.HasCustomizationValue(CommonCustomizationNames.DisasterRecoveryReady, true.ToString());
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Setting new value for dropDRDatabase: {0}", dropDRDatabase.ToString());
            }

            if (resizeDatabase)
            {
                resizeDatabase = ValidateResizeDBOperationAndUpdateActionParameters(topologyInstance, parameterValues, deploymentInstance);
            }

            Tracer.WriteExecutionEvent(
           TraceComponent.DeploymentServiceApi,
           "deallocateEnvironment: '{0}', resizeDatabase: '{1}', dropDRDatabase: '{2}'.",
           deallocateEnvironment.ToString(),
           resizeDatabase.ToString(),
           dropDRDatabase.ToString());

            if (!deallocateEnvironment && !dropDRDatabase && !resizeDatabase)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Select at least one action(deallocate, resize, drop dr db) for executing disable environment workflow.");
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.MissingDisableEnvironmentActions);
                return false;
            }

            deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.DeallocateEnvironment, deallocateEnvironment.ToString());
            deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.ResizeDatabase, resizeDatabase.ToString());
            deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.DropDRDatabase, dropDRDatabase.ToString());

            errorMessage = null;
            return true;
        }

        /// <summary>Set enable environments parameters to DeploymentActionParameters.</summary>
        /// <param name="topologyInstance">Topology instance.</param>
        /// <param name="parameterValues">Parameter values for Geneva action.</param>
        /// <param name="deploymentInstance">Deployment instance.</param>
        /// <param name="tenantRegistration">Tenant registration.</param>
        /// <param name="errorMessage">Error message, if any occurred.</param>
        /// <returns>True if parameter set successfully, false otherwise.</returns>
        private bool SetEnableEnvironmentParameters(
            TopologyInstance topologyInstance,
            IDictionary<string, object> parameterValues,
            DeploymentInstance deploymentInstance,
            TenantRegistration tenantRegistration,
            out HttpResponseMessage errorMessage)
        {
            string environmentDisabled = null;
            bool isEnvironmentDisabled;
            bool startEnvironment = true;

            bool deployDRDatabase = (bool)parameterValues[CommonDeploymentActionParameters.DeployDRDatabase];
            bool resizeDatabase = (bool)parameterValues[CommonDeploymentActionParameters.ResizeDatabase];

            if (!topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.IsEnvironmentDisabled, out environmentDisabled))
            {
                environmentDisabled = null;
            }

            if (environmentDisabled == null || !(bool.TryParse(environmentDisabled, out isEnvironmentDisabled) && isEnvironmentDisabled))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Environment is already in enabled state. Setting start environment to false.");
                startEnvironment = false;
            }

            if (deployDRDatabase)
            {
                if (!topologyInstance.IsDisasterRecoveryEnabled())
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Topology [{0}] is not enabled for disaster recovery. Setting deploy DR to false", topologyInstance.InstanceId);
                    deployDRDatabase = false;
                }
                else if (topologyInstance.HasCustomizationValue(CommonCustomizationNames.DisasterRecoveryReady, true.ToString()))
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Disaster recovery is already deployed for topology {0}. Setting deploy DR to false", topologyInstance.InstanceId);
                    deployDRDatabase = false;
                }
                else
                {
                    if (!this.ValidateTopologyForDeployDR(topologyInstance, tenantRegistration, out errorMessage))
                    {
                        return false;
                    }

                    if (string.IsNullOrWhiteSpace(topologyInstance.DisasterRecoveryLocation))
                    {
                        topologyInstance.DisasterRecoveryLocation = AzureSQLLocations.GetGeoReplicationLocation(topologyInstance.CloudStorageLocation);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Set disaster recovery location to [{0}].", topologyInstance.DisasterRecoveryLocation);
                    }
                }
            }

            if (resizeDatabase)
            {
                resizeDatabase = ValidateResizeDBOperationAndUpdateActionParameters(topologyInstance, parameterValues, deploymentInstance);
            }

            Tracer.WriteExecutionEvent(
               TraceComponent.DeploymentServiceApi,
               "startEnvironment: '{0}', deployDRDatabase: '{1}', resizeDatabase: '{2}'.",
               startEnvironment.ToString(),
               deployDRDatabase.ToString(),
               resizeDatabase.ToString());

            if (!startEnvironment && !deployDRDatabase && !resizeDatabase)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Select at least one action(start, deploy DR, resize DB) for executing enable environment workflow.");
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.MissingEnableEnvironmentActions);
                return false;
            }

            deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.DeployDRDatabase, deployDRDatabase.ToString());
            deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.StartEnvironment, startEnvironment.ToString());
            deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.ResizeDatabase, resizeDatabase.ToString());

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validate if resize database operation is valid. If yes update deployment action parameters.
        /// </summary>
        /// <param name="topologyInstance">Topology Instance.</param>
        /// <param name="parameterValues">Parameter Values.</param>
        /// <param name="deploymentInstance">Deployment instance.</param>
        /// <returns>Returns true if resize database operation is valid else false.</returns>
        private static bool ValidateResizeDBOperationAndUpdateActionParameters(TopologyInstance topologyInstance, IDictionary<string, object> parameterValues, DeploymentInstance deploymentInstance)
        {
            if (topologyInstance.DeploymentItems.TryGetFirst(CommonCustomizationNames.AXDbDeploymentItemName, out DeploymentItem azureSQLDatabaseItem)
                && azureSQLDatabaseItem.IsItemType(DeploymentItemType.AzureSQLDatabase))
            {
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.TransactionThreshold, (string)parameterValues[CommonDeploymentActionParameters.TransactionThreshold]);
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.SQLQueryResultType, (string)parameterValues[CommonDeploymentActionParameters.SQLQueryResultType]);

                return true;
            }
            else
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Setting resize database value to [False] for DevTest or Demo environment");
                return false;
            }
        }

        /// <summary>
        /// Check if the SQL Query can be executed against an ElasticPool.
        /// </summary>
        /// <param name="sqlQueryName">Identifier of the SQL Query that needs to be executed.</param>
        /// <returns>Returns a Bool.</returns>
        private bool ValidateSQLActionForElasticPool(
            string sqlQueryName)
        {
            switch (sqlQueryName)
            {
                // Changing the performance Tier on Database should not be allowed on ElasticPool
                case DeploymentConstants.ResizeDatabase:
                    return false;
            }

            return true;
        }

        /// <summary>
        /// Retrieves a single geneva parameter with error handling.
        /// </summary>
        /// <typeparam name="T">The type of the object.</typeparam>
        /// <param name="action">The action of the deployment.</param>
        /// <param name="parametersJsonObject">The JSON parameter object.</param>
        /// <param name="parameterName">The parameter name we want to retrieve.</param>
        /// <param name="value">The value of the parameter.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if parameters were read successfully, false otherwise.</returns>
        [SuppressMessage("Microsoft.Design", "CA1031", Justification = "Need to enable catch all exception", Scope = "Just for this method")]
        private bool TryGetGenevaParameter<T>(
            DeploymentRequest.DeploymentAction action,
            JObject parametersJsonObject,
            string parameterName,
            out T value,
            out HttpResponseMessage errorMessage)
        {
            try
            {
                value = parametersJsonObject[parameterName].Value<T>();
            }
            catch (Exception e)
            {
                value = default(T);
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    parameterName,
                    e.ToString());
                return false;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Takes the SQL query parameters and merges them with the expected value from Table Storage.
        /// </summary>
        /// <param name="parameters">The parameters that need to be populated into the string.</param>
        /// <param name="tableParameters">The parameters from the Table storage. This is referenced to ensure the client passed the correct values.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if we successfully populated the SQL template, false otherwise.</returns>
        private bool ValidateSQLParameters(IEnumerable<SQLActionParameter> parameters, IEnumerable<SQLActionParameter> tableParameters, out HttpResponseMessage errorMessage)
        {
            if ((parameters == null || parameters.Count() == 0) && (tableParameters == null || tableParameters.Count() == 0))
            {
                errorMessage = null;
                return true;
            }

            // Validate the Parameters passed are expected
            IEnumerable<string> matchingNames = parameters.Select(p => p.Name).Intersect(tableParameters.Select(p => p.Name));
            if (parameters.Count() != tableParameters.Count() || matchingNames.Count() != tableParameters.Count())
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    string.Format(CultureInfo.InvariantCulture, "The parameters passed for the SQL Query do not match those that are expected."));
                return false;
            }

            foreach (SQLActionParameter parameter in parameters)
            {
                SQLActionParameter tableParameter = tableParameters.First(p => string.Equals(p.Name, parameter.Name, StringComparison.OrdinalIgnoreCase));
                bool validValue = false;

                // Added to ensure parameter value is not null for non-string values. Strings can be null or empty for some queries
                if (!string.Equals(parameter.DotNetType, DeploymentConstants.StringParameterType, StringComparison.OrdinalIgnoreCase) && string.IsNullOrEmpty(parameter.Value))
                {
                    if (!string.IsNullOrEmpty(tableParameter.DefaultValue))
                    {
                        parameter.Value = tableParameter.DefaultValue;
                    }
                    else
                    {
                        errorMessage = this.CreateErrorResponse(
                            ServiceErrorCode.OperationNotAllowed_NullOrEmptyParameterNoDefault,
                            "ValidateSQLParameters",
                            parameter.Name);

                        return false;
                    }
                }

                // Switch is here to do a type check on the values passed.
                switch (parameter.DotNetType)
                {
                    case DeploymentConstants.StringParameterType:
                        // This prevents issues when strings contain un-escaped quotes.
                        if (!string.IsNullOrEmpty(parameter.Value))
                        {
                            parameter.Value = parameter.Value.Replace("'", "''");
                        }

                        validValue = true;
                        break;
                    case DeploymentConstants.ByteParameterType:
                        byte byteValue;
                        validValue = byte.TryParse(parameter.Value, out byteValue);
                        break;
                    case DeploymentConstants.ShortParameterType:
                        short int16Value;
                        validValue = Int16.TryParse(parameter.Value, out int16Value);

                        short? shortMinValue = tableParameter.MinimumValue.HasValue ? (short?)Convert.ToInt16(tableParameter.MinimumValue.Value) : null;

                        if (shortMinValue.HasValue && int16Value < shortMinValue.Value)
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The parameter [{0}] with the value of [{1}] is less than the minimum requirement of [{2}].", parameter.Name, parameter.Value, shortMinValue.Value);
                            validValue = false;
                            break;
                        }

                        short? shortMaxValue = tableParameter.MaximumValue.HasValue ? (short?)Convert.ToInt16(tableParameter.MaximumValue.Value) : null;

                        if (shortMaxValue.HasValue && int16Value > shortMaxValue.Value)
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The parameter [{0}] with the value of [{1}] is greater than the maximum requirement of [{2}].", parameter.Name, parameter.Value, shortMaxValue.Value);
                            validValue = false;
                            break;
                        }

                        break;
                    case DeploymentConstants.IntParameterType:
                        int int32Value;
                        validValue = Int32.TryParse(parameter.Value, out int32Value);

                        int? intMinValue = tableParameter.MinimumValue.HasValue ? (int?)Convert.ToInt32(tableParameter.MinimumValue.Value) : null;

                        if (intMinValue.HasValue && int32Value < intMinValue.Value)
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The parameter [{0}] with the value of [{1}] is less than the minimum requirement of [{2}].", parameter.Name, parameter.Value, intMinValue.Value);
                            validValue = false;
                            break;
                        }

                        int? intMaxValue = tableParameter.MaximumValue.HasValue ? (int?)Convert.ToInt32(tableParameter.MaximumValue.Value) : null;

                        if (intMaxValue.HasValue && int32Value > intMaxValue.Value)
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The parameter [{0}] with the value of [{1}] is greater than the maximum requirement of [{2}].", parameter.Name, parameter.Value, intMaxValue.Value);
                            validValue = false;
                            break;
                        }

                        break;
                    case DeploymentConstants.LongParameterType:
                        long int64Value;
                        validValue = long.TryParse(parameter.Value, out int64Value);

                        long? int64MinValue = tableParameter.MinimumValue.HasValue ? (long?)Convert.ToInt64(tableParameter.MinimumValue.Value) : null;

                        if (int64MinValue.HasValue && int64Value < int64MinValue.Value)
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The parameter [{0}] with the value of [{1}] is less than the minimum requirement of [{2}].", parameter.Name, parameter.Value, int64MinValue.Value);
                            validValue = false;
                            break;
                        }

                        long? int64MaxValue = tableParameter.MaximumValue.HasValue ? (long?)Convert.ToInt64(tableParameter.MaximumValue.Value) : null;

                        if (int64MaxValue.HasValue && int64Value > int64MaxValue.Value)
                        {
                            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The parameter [{0}] with the value of [{1}] is greater than the maximum requirement of [{2}].", parameter.Name, parameter.Value, int64MaxValue.Value);
                            validValue = false;
                            break;
                        }

                        break;
                    case DeploymentConstants.BooleanParameterType:
                        bool booleanValue;
                        validValue = Boolean.TryParse(parameter.Value, out booleanValue);
                        break;
                    case DeploymentConstants.DateTimeParameterType:
                        DateTime dateTimeValue;
                        validValue = DateTime.TryParse(parameter.Value, out dateTimeValue);
                        break;
                    default:
                        validValue = false;
                        break;
                }

                if (!validValue)
                {
                    Tracer.WriteWarningEvent(TraceComponent.DeploymentServiceApi, null, null, "Invalid parameter [{0}] with the value [{1}]. The expected type was [{2}].", parameter.Name, parameter.Value, parameter.DotNetType);

                    errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    "ValidateSQLParameters",
                    parameter.Value,
                    parameter.Name);

                    return false;
                }

                tableParameter.Value = parameter.Value;
            }

            errorMessage = null;
            return true;
        }

        /// <summary>
        /// Validates Restart VM action parameters and saves them to deployment action parameters.
        /// </summary>
        /// <param name="action">A deployment action to execute for topology.</param>
        /// <param name="topologyInstance">Topology instance.</param>
        /// <param name="deploymentInstance">Deployment instance.</param>
        /// <param name="parameterValues">Parameter values for Geneva action.</param>
        /// <param name="errorMessage">Error message, if any occured.</param>
        /// <returns>True if configured successfully, false otherwise.</returns>
        private bool TryValidateAndConfigureRestartVMGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            TopologyInstance topologyInstance,
            DeploymentInstance deploymentInstance,
            IDictionary<string, object> parameterValues,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            string virtualMachineToRestart = (string)parameterValues[CommonDeploymentActionParameters.VMToRestart];
            bool virtualMachineExists = topologyInstance.DeploymentItems
                .Where(di => di.IsItemType(DeploymentItemType.VirtualMachine))
                .SelectMany(di => di.Instances)
                .Any(instance => instance.MachineName.Equals(virtualMachineToRestart, StringComparison.Ordinal));
            if (!virtualMachineExists)
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    virtualMachineToRestart,
                    CommonDeploymentActionParameters.VMToRestart);
                return false;
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Scheduling virtual machine reset for the following VMs [{0}] pool on topology [{1}]...", virtualMachineToRestart, topologyInstance);

            deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.VMToRestart, virtualMachineToRestart);
            return true;
        }

        /// <summary>
        /// Validates Resize VM action parameters and saves them to deployment action parameters.
        /// </summary>
        /// <param name="action">A deployment action to execute for topology.</param>
        /// <param name="topologyInstance">Topology instance.</param>
        /// <param name="deploymentInstance">Deployment instance.</param>
        /// <param name="tenantRegistration">Tenant registration.</param>
        /// <param name="parameterValues">Parameter values for Geneva action.</param>
        /// <param name="errorMessage">Error message if any occured.</param>
        /// <returns>True if configured successfully and false otherwise.</returns>
        private bool TryValidateResizeVMGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            TopologyInstance topologyInstance,
            DeploymentInstance deploymentInstance,
            TenantRegistration tenantRegistration,
            IDictionary<string, object> parameterValues,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            List<ResizeVmMetadata> resizeVmMetadata = (List<ResizeVmMetadata>)parameterValues[CommonDeploymentActionParameters.ResizeVmMetadata];
            IEnumerable<DeploymentItem> virtualMachineDeploymentItems = topologyInstance.GetVirtualMachines();

            int requestedCores = 0;
            int currentUsedCoresByVMs = 0;

            using (AzureResourceManager manager = tenantRegistration.CreateAzureResourceManager(topologyInstance.ARM.ResourceGroupName))
            {
                foreach (var metadata in resizeVmMetadata)
                {
                    var deploymentItem = virtualMachineDeploymentItems.Where(di => string.Equals(di.ItemName, metadata.DeploymentItemName.ToString(), StringComparison.OrdinalIgnoreCase)).FirstOrDefault();

                    if (metadata.TargetRoleSize == RoleSizeMetadata.RoleSize.Undefined || deploymentItem == null)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The value [{0}] for parameter [{1}] is invalid", resizeVmMetadata, CommonDeploymentActionParameters.ResizeVmMetadata);
                        errorMessage = this.CreateErrorResponse(
                        ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                        action,
                        resizeVmMetadata,
                        CommonDeploymentActionParameters.ResizeVmMetadata);
                        return false;
                    }
                    else
                    {
                        requestedCores += RoleSizeMetadata.GetCoreCount(metadata.TargetRoleSize.ToString()) * deploymentItem.Instances.Count;
                        currentUsedCoresByVMs += deploymentItem.GetCoreCount();
                    }

                    // Validate if the role size is supported for the VM.
                    // Just check the first instance as all instances get moved to the same size.
                    var availableVMSizes = manager.Compute.Value.GetAvailableVirtualMachineSizesForResize(deploymentItem.Instances[0].MachineName);

                    if (!(availableVMSizes != null && availableVMSizes.Any(s => String.Equals(s.Name, metadata.TargetRoleSize.ToString(), StringComparison.OrdinalIgnoreCase))))
                    {
                        Tracer.WriteExecutionEvent(
                            TraceComponent.DeploymentServiceApi,
                            "The TargetRoleSize [{0}] is not currently supported for the virtual machine [{1}], but it may become available after the VM is deallocated.",
                            metadata.TargetRoleSize.ToString(),
                            deploymentItem.Instances[0].MachineName);
                    }
                }

                // Check available compute quotas if the target compute requires more cores.
                int coresNeeded = requestedCores - currentUsedCoresByVMs;
                if (coresNeeded > 0)
                {
                    List<TopologyInstance> ongoingTopologyInstances;
                    this.GetDeployingTopologyInstances(tenantRegistration.TenantId, out ongoingTopologyInstances);

                    if (!this.ValidateTopologyARMCoresAvailabilityForUpdate(tenantRegistration.AzureSubscriptionId, topologyInstance, out errorMessage, ongoingTopologyInstances, manager, coresNeeded))
                    {
                        return false;
                    }
                }
                else
                {
                    Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The requested compute core [{0}] is less than used cores [{1}] for topology instance [{2}]. Skipping compute quota validation.", requestedCores, topologyInstance.GetCoreCount(), topologyInstance);
                }
            }

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Scheduling virtual machine resize for the following VMs [{0}] pool on topology [{1}]...", resizeVmMetadata, topologyInstance);

            deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.ResizeVmMetadata, CommonUtilities.SerializeJson<List<ResizeVmMetadata>>(resizeVmMetadata));
            return true;
        }

        /// <summary>
        /// Validate BI VM before Deletion.
        /// </summary>
        /// <param name="action">action</param>
        /// <param name="topologyInstance">topologyInstance</param>
        /// <param name="deploymentInstance">deploymentInstance</param>
        /// <param name="tenantRegistration">tenantRegistration</param>
        /// <param name="parameterValues">parameterValues</param>
        /// <param name="errorMessage">errorMessage</param>
        /// <returns>validate before vm to delete.</returns>
        private bool TryValidateRemoveBIVMGenevaActionParameters(DeploymentRequest.DeploymentAction action,
            TopologyInstance topologyInstance,
            DeploymentInstance deploymentInstance,
            TenantRegistration tenantRegistration,
            IDictionary<string, object> parameterValues,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            string vmDeploymentItemToDelete = CommonDeploymentItemNames.BIDeploymentItem;

            if (topologyInstance.IsDemoOrDevTestTopology())
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Not a valid topology for VM Deletion {0}.", topologyInstance.InstanceId);

                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    vmDeploymentItemToDelete,
                    CommonDeploymentActionParameters.VirtualMachineDeploymentItemName);
                return false;
            }

            if (!this.CanDeleteBIVM(topologyInstance.DeploymentState, topologyInstance.DeploymentStatus))
            {
                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_RequiresFinishedState,
                    action,
                    vmDeploymentItemToDelete,
                    CommonDeploymentActionParameters.VirtualMachineDeploymentItemName);
                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, $"Attempted to [{action}] deployment instance corresponding to topology [{topologyInstance}] but it is currently in state: [{deploymentInstance.DeploymentState} / status: {deploymentInstance.DeploymentStatus}].");

                return false;
            }

            if (topologyInstance.GetDisasterRecoveryVirtualMachineItems().SelectMany(d => d.Instances).Count() > 0)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Not Eligible for BI VM Deletion: Disaster recovery virtual machines found in topology {0}.", topologyInstance.InstanceId);

                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    vmDeploymentItemToDelete,
                    CommonDeploymentActionParameters.VirtualMachineDeploymentItemName);
                return false;
            }

            //Check whether Topology Consists of MigratedtoSSRS or ssrs_saas customization
            if (!topologyInstance.ShouldRemoveFromSsrsConfigService())
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Not Eligible for BI VM Deletion: SSRS customization not found in topology {0}.", topologyInstance.InstanceId);

                errorMessage = this.CreateErrorResponse(
                    ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                    action,
                    vmDeploymentItemToDelete,
                    CommonDeploymentActionParameters.VirtualMachineDeploymentItemName);
                return false;
            }

            deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.VirtualMachineDeploymentItemName, vmDeploymentItemToDelete);

            Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "valid topology for VM Deletion {0}.", topologyInstance.InstanceId);

            return true;
        }

        /// <summary>
        /// Validates Resize Application Gateway action parameters and saves them to deployment action parameters.
        /// </summary>
        /// <param name="action">A deployment action to execute for topology.</param>
        /// <param name="topologyInstance">Topology instance.</param>
        /// <param name="deploymentInstance">Deployment instance.</param>
        /// <param name="tenantRegistration">Tenant registration.</param>
        /// <param name="parameterValues">Parameter values for Geneva action.</param>
        /// <param name="errorMessage">Error message if any occured.</param>
        /// <returns>True if configured successfully and false otherwise.</returns>
        private bool TryValidateResizeAppGwGenevaActionParameters(
            DeploymentRequest.DeploymentAction action,
            TopologyInstance topologyInstance,
            DeploymentInstance deploymentInstance,
            TenantRegistration tenantRegistration,
            IDictionary<string, object> parameterValues,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            List<ResizeApplicationGatewayMetadata> resizeAppGatewayMetadata = (List<ResizeApplicationGatewayMetadata>)parameterValues[CommonDeploymentActionParameters.ResizeAppGatewayMetadata];

            if (resizeAppGatewayMetadata == null)
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "The value [{0}] for parameter [{1}] is invalid", resizeAppGatewayMetadata, CommonDeploymentActionParameters.ResizeAppGatewayMetadata);
                errorMessage = this.CreateErrorResponse(
                ServiceErrorCode.OperationNotAllowed_InvalidParameterValue,
                action,
                resizeAppGatewayMetadata,
                CommonDeploymentActionParameters.ResizeAppGatewayMetadata);
                return false;
            }
            else
            {
                deploymentInstance.DeploymentActionParameters.Add("TargetRoleSize", resizeAppGatewayMetadata.ToList().Select(i => i.TargetRoleSize).First());
                deploymentInstance.DeploymentActionParameters.Add("TargetInstanceCount", resizeAppGatewayMetadata.ToList().Select(i => i.TargetInstanceCount).First());

                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Scheduling application gateway resize for topology [{0}]...", topologyInstance);
                return true;
            }
        }

        /// <summary>
        /// Validates if the Disaster Recovery Application Gateway is part of the deployment or not.
        /// </summary>
        /// <param name="deploymentInstance">Deployment instance.</param>
        /// <param name="environment">Environment Group.</param>
        /// <param name="genevaActionToExecute">Geneva Action type.</param>
        /// <param name="errorMessage">Error message if any occured.</param>
        /// <returns>True if DR App Gateway exists and false otherwise.</returns>
        private bool TryValidateDisasterRecoveryAppGatewayExists(
            DeploymentInstance deploymentInstance,
            EnvironmentGroup environment,
            GenevaActionType genevaActionToExecute,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            if (!deploymentInstance.DeploymentItems.GetAllSecondary(DeploymentItemType.ApplicationGateway).Any())
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, Enum.GetName(typeof(GenevaActionType), genevaActionToExecute),
                                                    Enum.GetName(typeof(EnvironmentGroup), environment), CommonDeploymentActionParameters.EnvironmentGroup);
                return false;
            }
            return true;
        }

        /// <summary>
        /// Validates whether the parameters to execute the fetch package deployment logs Geneva action are valid.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology.</param>
        /// <param name="deploymentInstance">Deployment instance.</param
        /// <param name="genevaActionToExecute">Geneva Action type.</param>
        /// <param name="parameterValues">Dictionary containing the parameter values.</param>
        /// <param name="errorMessage">Error message if any occured.</param>
        /// <returns>True if the required parameters to execute the fetch package deployment logs Geneva action are valid and false otherwise.</returns>
        private bool TryValidateFetchPackageDeploymentLogsGenevaActionParameters(
            Guid tenantId,
            Guid azureSubscriptionId,
            string topologyInstanceId,
            DeploymentInstance deploymentInstance,
            GenevaActionType genevaActionToExecute,
            IDictionary<string, object> parameterValues,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;
            Guid activityId = new Guid();

            if (parameterValues.ContainsKey(CommonDeploymentActionParameters.ActivityId))
            {
                string activityIdRead = (string)parameterValues[CommonDeploymentActionParameters.ActivityId];
                deploymentInstance.DeploymentActionParameters.Add(CommonDeploymentActionParameters.ActivityId, activityIdRead);
            }

            if (!deploymentInstance.DeploymentActionParameters.TryGet(CommonDeploymentActionParameters.ActivityId, out string activityIdParam)
                || !Guid.TryParse(deploymentInstance.DeploymentActionParameters.Get(CommonDeploymentActionParameters.ActivityId), out activityId))
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, Enum.GetName(typeof(GenevaActionType), genevaActionToExecute),
                                                    CommonDeploymentActionParameters.ActivityId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "The activityId [{0}] is invalid for the geneva action [{1}].", activityId, genevaActionToExecute);

                return false;
            }

            deploymentInstance.PackageDeploymentInstanceId = this.GetPackageDeploymentInstanceId(tenantId, azureSubscriptionId, topologyInstanceId, activityId) ?? Guid.Empty;

            if (deploymentInstance.PackageDeploymentInstanceId == Guid.Empty)
            {
                errorMessage = this.CreateErrorResponse(ServiceErrorCode.OperationNotAllowed_InvalidParameterValue, Enum.GetName(typeof(GenevaActionType), genevaActionToExecute),
                                                    CommonDeploymentActionParameters.PackageDeploymentInstanceId);

                Tracer.WriteErrorEvent(TraceComponent.DeploymentServiceApi, null, "The PackageDeploymentInstanceId [{0}] is invalid for the geneva action [{1}].", activityId, genevaActionToExecute);

                return false;
            }

            return true;
        }

        /// <summary>
        /// Updates the topology instance for types requiring update on deleted instance as well.
        /// </summary>
        /// <param name="tenantId">Identifier of the tenant.</param>
        /// <param name="azureSubscriptionId">Identifier of the Azure subscription the instance belongs to.</param>
        /// <param name="topologyInstanceId">Identifier of the topology.</param>
        /// <param name="parameterValues">Dictionary containing the parameter values.</param>
        /// <param name="errorMessage">Error message if any occured.</param>
        /// <returns>Success reponse if successfully executed.</returns>
        private HttpResponseMessage UpdateTopologyInstanceIncludingDeleted(
            Guid tenantId,
            Guid azureSubscriptionId,
            string topologyInstanceId,
            EnvironmentGroup environmentGroup,
            IDictionary<string, object> parameterValues,
            TopologyInstanceUpdateType topologyInstanceUpdateType,
            out HttpResponseMessage errorMessage)
        {
            errorMessage = null;

            TopologyInstance topologyInstance;
            TopologyInstanceTableItem topologyInstanceRow;

            if (!this.GetTopologyInstance(tenantId, azureSubscriptionId, topologyInstanceId, environmentGroup, filterOutDeleted: false, out topologyInstance, out errorMessage, out topologyInstanceRow))
            {
                Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Unable to get Topology Instance [{0}] because it was not found", topologyInstanceId);
                return errorMessage;
            }

            switch (topologyInstanceUpdateType)
            {
                case TopologyInstanceUpdateType.ReEncryptTopology:
                    string reencryptGuardThumbprint = string.Empty;
                    if (topologyInstance.TryGetCustomizationValue(CommonCustomizationNames.ReEncryptThumbprint, out reencryptGuardThumbprint) &&
                        reencryptGuardThumbprint == DeploymentServiceConfig.DeploymentEncryptionCertificateThumbprint)
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Skipped ReEncrypt as topology instance already has ReEncryptThumbprint customization guard : [{0}]", reencryptGuardThumbprint);
                    }
                    else
                    {
                        DeploymentInstance deploymentInstance;
                        Uri deploymentInstanceBlobUri;

                        if (!this.GetDeploymentInstance(tenantId, azureSubscriptionId, topologyInstanceId, topologyInstanceRow, environmentGroup, out deploymentInstance, out deploymentInstanceBlobUri, out errorMessage))
                        {
                            return errorMessage;
                        }

                        this.UploadDeploymentBlob(deploymentInstanceBlobUri, deploymentInstance);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Reuploading deployment instance blob [{0}] with certificate [{1}]", deploymentInstance.Revision, DeploymentServiceConfig.DeploymentEncryptionCertificateThumbprint);

                        this.UploadTopologyBackupBlob(tenantId, azureSubscriptionId, topologyInstance, TopologyInstanceUpdateType.ReEncryptTopology.ToString());
                        topologyInstance.SetCustomizationValue(CommonCustomizationNames.ReEncryptThumbprint, DeploymentServiceConfig.DeploymentEncryptionCertificateThumbprint);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Added ReEncryptThumbprint customization guard with [{0}]", DeploymentServiceConfig.DeploymentEncryptionCertificateThumbprint);

                        this.UploadTopologyBlob(tenantId, azureSubscriptionId, topologyInstance);
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Reuploading topology instance blob [{0}] with certificate [{1}]", topologyInstance, DeploymentServiceConfig.DeploymentEncryptionCertificateThumbprint);

                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "ReEncryptTopology completed successfully [{0}]", topologyInstance);
                    }
                    break;
                case TopologyInstanceUpdateType.RemoveOrUpdateSecretsInKeyVault:
                    if (topologyInstance.DeploymentState == DeploymentState.Deleted && topologyInstance.DeploymentStatus == Model.DeploymentStatus.Succeeded)
                    {
                        TenantRegistration tenantRegistration = this.FetchTenantRegistrationFromCache(tenantId, azureSubscriptionId);
                        TopologyInstanceHelper.RemoveSecretsFromInstanceKeyVault(tenantRegistration, topologyInstance);
                    }
                    else
                    {
                        Tracer.WriteExecutionEvent(TraceComponent.DeploymentServiceApi, "Topology [{0}] is still active. Updating secret attibutes for policy compliance.", topologyInstanceId);
                        TopologyInstanceHelper.UpdateSecretAttributesForPolicyCompliance(topologyInstance);
                    }
                    break;
            }

            return Request.CreateResponse(HttpStatusCode.OK);
        }

        #endregion

        /// <summary>
        /// Class to store off-hour information for a geographic region.
        /// </summary>
        private class RegionOffHoursInfo
        {
            /// <summary>
            /// Gets or sets the name of the geographic region.
            /// </summary>
            public string Name
            {
                get;

                set;
            }

            /// <summary>
            /// Gets or sets 'from' time for the region off-hours.
            /// </summary>
            public TimeSpan From
            {
                get;

                set;
            }

            /// <summary>
            /// Gets or sets 'to' time for the region off-hours.
            /// </summary>
            public TimeSpan To
            {
                get;

                set;
            }

            /// <summary>
            /// Gets or sets regular expresson for matching Azure data center region.
            /// </summary>
            public RE.Regex Region
            {
                get;

                set;
            }
        }
    }
}
